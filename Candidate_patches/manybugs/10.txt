golden:
if (bsize == 0)
inference:
if (bsize == 0)
if (bsize  0)
if (bsize == -1)
if (bp == 0)
if (bsize)
if (bsize!= 0)
if (bsize >= 0)
if (bsize = 0)
if (asize == bsize)
if (bsize > 0)
if (bsize == 0 || bsize == 0)
if (bsize == NULL)
if (bsize == 1)
if (bp == NULL)
if (bsize == 0 && bsize == 0)
if(bsize == 0)
if (bsize == 0 || asize == bsize)
if (size == 0)
if (ssize == 0)
if (!bsize)
if (psize == 0)
if (bsize == bsize)
else if (bsize == 0)
if (bsize == (int)0)

if (bp == -1)
if (bsize == 0 && bsize  0)
if (asize == 0)
size = bsize; if (size == 0)
if (bp->bsize == 0)
if (bsize  bsize)
if (bsize && bsize == 0)
if (b)
if ( bsize == 0 )
if (bsize == 0 && bsize >= 0)
if (bsize == 0 || asize  bsize)
if (bbsize == 0)
if (bsize == SIZ)
if (b == 0)
if (bssize == 0)
if (asize  bsize)
if (bsize == 0 || bsize >= 0)
if (bsize==0)
if (bsize == 0
if (bsize == 0 || bsize  0)
if (bsize == 0.0)
if (lbsize == 0)
if (msize == 0)
if (bsize  0 || bsize == 0)
if (bsize == ap)
switch (bsize)
if (bsize == (u_int)0)
if (bsize == V)
if (0 == bsize)
if (bsize == 0 && ap == a)
if (nsize == 0)
if (buf == 0)
if (bsize == 0 || bsize == bsize)
if (bsize == -1 || bsize == 0)
if (asize == 0 && bsize == 0)
if (*bsize == 0)
if (bsize == '0')
if (bsize == 2)
if (vsize == 0)
if (bsize == 0 || size == 0)
if (bsize == 0 || bsize == -1)
if (bsize == 0 || bsize  bsize)
if (bsize == 0 && ssize == 0)
if (bp  0)
if (bp && bsize == 0)
if (bsize == 0 || ssize == 0)
if (bsize == 0 && bsize > 0)
if (bsize == size)
if (bb == 0)
if (bsize == 0 && bp == 0)
if (bsize  0 && bsize == 0)
if (bsize == 0 && size == 0)
if (bsize == 0 || asize >= bsize)
if (bsize!= -1)
if (bsize  1)
if (bsize == 0 || asize == 0)
if (bp)
if (bsize == 0 && ap == 0)
if (i == 0)
/* if (bsize == 0)
if (bsize == 0 && bsize == -1)
if (bp!= 0)
if (hsize == 0)
if (b_size == 0)
else
if (asize == bsize || bsize == 0)
if (bsize == )
if (bsize == FALSE)
if (bsize == 0 || ap == bsize)
if (bsize == 1 || bsize == 0)
if (bsize == 0 && i == 0)
if (bsize == 0 && bsize)
if (bsize == 0 || ssize == bsize)
if ((bsize == 0))
if (bsize == asize)
if (bsize == 0 || bsize > 0)
if (bsize == 0 && asize == 0)
if (bsize == i)
if (bsize || bsize == 0)
if (bsize == ssize)
if (wsize == 0)
if (bp == bsize)
if (nbsize == 0)
if (bsize == 3)
if (bsize == 0 || bsize >= bsize)
if (bp == NULL || bsize == 0)
if ((bsize) == 0)
if (bsize == 0 || i == 0)
if (bp == 0 && bsize == 0)
if (bsize == (size_t)0)
if (asize = bsize)
if (bs == 0)
if (bsize == &bsize)
if (!(bsize == 0))
if (gsize == 0)
if (fsize == 0)
if (bsize == U)
if (ssize == bsize)
if (bsize  0 || bsize  0)
if (bsize > bsize)
if (asize >= bsize)
if (dbsize == 0)
if (bsize == (long)0)
if (bsize == 0 || bp == 0)
if (bsize == 0 || bsize > bsize)
if (mbsize == 0)
if (-bsize == 0)
if (bsize == 0 || size == bsize)
if (mpz_size == 0)
if (bsize == ASIZE)
if (bsize() == 0)
if (++bsize == 0)
if (lsize == 0)
if (bsize == EINVAL)
if (bsize == -1 || bsize == -1)
if (bsize >= bsize)
if (bsize == 0 &&!bsize)
if (usize == 0)
if (bp!= NULL)
if (bp == 0 || bsize == 0)
if (csize == 0)
if (bsize >= 0 && bsize == 0)
if (bsize == a)
if (b size == 0)
if (bsize == 0 || bsize = 0)
if (bsize == 0)  #endif
if (esize == 0)
if (bsize == 0 && size >= 0)
if (BSIZE == 0)
if (bsize == (0))
if (! bsize)
if (bsize == 0);
if (bbuf == 0)
if (bsize == 0 && bsize > bsize)
if (mpsize == 0)
if (v == 0)
if (blk == 0)
if (bsize == 0 || bsize!= 0)
if (&bsize == 0)
if (rsize == 0)
if ((bsize == 0) && bsize)
if (bsize ==)
if (bsize == 0 && size  0)
if (bsize == 4)
if (bsize == 0 || (bsize == 0))
if (bsize == 0 && bp == NULL)
if (bp = 0)
if (bsize  0 && bsize  0)
if (bsize == 0 && asize >= 0)
if (bsize == 0 &&!ap)
if (bsize == 0 && a == bsize)
if (bsize == 0 && psize == 0)
if (bytes == 0)
if (bsize == 0 && asize  0)
if (bsize == 0 && ((bsize = mpz_gcdext_max)  0))
if (bsize == 0 && bsize  bsize)
if (bsize == 0 && asize  bsize)
if (bsize == 0)  /* * * Assigning to the ptr-mtr. If the size of ptr == bsize, we can't assume it. */ if (ptr == -1)
if (bsize == 0)  /* * This is not a priority, but we don't have to set the scale. */ if (bsize == 0)
if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp)  mpz_gcdext (stmp, stmp); if (stmp)  mpz_gcdext (stmp, stmp, stmp, stmp);    else  mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp);  if (stmp  0)  /*
if (bsize == 0)  /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0)  MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t);   else if (bsize == 0)
if (bsize == 0 && __mpz_struct stmp)
if (bsize == 0)  __mpz_realloc (g, asize); MPZ_COPY (g, asize); __mpz_realloc (g, asize);
if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize  bsize))  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize))  _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t);  if (bsize == 0)
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0 && asize >= V)
if (bsize == 0)  /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize)  0)
if (bsize == 0 && (*ap == bsize) && (*bp == '0'))
if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASYNC_OBJECT (ap, bp, asize))
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);  if (bsize == 0)  if (asize = 0 && mpn_cmp (ap, bp, asize)  0)  MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b);  else  MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0)  mpz__init_i(&stp, s, bsize);
if (bsize == 0 && ap = 0)
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);  else
if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize  bsize)  MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t);   if (asize  bsize)
if (bsize == 0)  /* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle)  mpz_gcdext (idle, idle, 0);
if (bsize == 0)  /* x-int size -> psize */ if (ap == bsize) _mpz_realloc (g, asize);
if (bsize == 0 && ap == bsize)
if (bsize == 0)  __mpz_realloc (g, asize); gp = PTR (g);  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize)  0)  mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t);   else  /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize)  0)  mpz_gcdext (ap,
if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize)  0)
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g);  else  mpz_size_t assize, ssize, ssize, ssize, tmp_sp;   if (bsize == 0)
if (bsize == 0)  /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize);  else if (bsize == 0)
if (bsize == 0 && (ssize = 0) && (asize = bsize))
if (bsize == 0)  if (!__mpz_struct stmp_initialized)  __mpz_struct stmp_initialized = 0;  if (__mpz_struct stmp_initialized)  __mpz_struct stmp_initialized = 0;   else  if (bsize == 0)  __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize  bsize)  __mpz_realloc (g, asize); gp = PTR
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0 &&! __mpz_struct stmp, bp)
if (bsize == 0 && ap == bsize && mpn_cmp (ap, bp, asize)  0)
if (bsize == 0)  /* */
if (bsize == 0)  __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize);  else  __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0)  MPZ_SIZE (a, b);  if (stmp!=
if (bsize == 0 && (asize  bsize || ssize  bsize))
if (bsize == 0)  /* * XXX */
if (bsize == 0 && m_iocmd_exp = 0)
if (bsize == 0)  /* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */
if (bsize == 0 && asize == bsize && ap == a)
if (bsize == 0 && (asize >= 0 && bsize  bsize))
if (bsize == 0)  /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b);  else  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);  if (bsize == 0)
if (bsize == 0)  /* a == 0 or bsize == 0 */ _mpz_realloc (g, asize);
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize);  if (mpn_gcdext (g, g)  0)  MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);  if (mpz_flags & MPZ_OPNTR)
if (bsize == 0 && mpn_cmp (ap, bp, asize)  0)
if (bsize == 0 &&!tmp_saved)
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0'))))  MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t);  else  MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0)  if (MPP_SYMBOL_LOCK_ASSERT (&mpz_ptr_symbol_cmp)) return;
if (bsize == 0 && mnt  0)
if (bsize == 0 && p == 0)
if (bsize == 0)  __mpz_free (p, bp, bsize);
if (bsize == 0)  if (mpz_size_t bsize == 0)
if (bsize == 0)  _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize);
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0 &&!mpn_cmp (ap, bp, asize))
if (bsize == 0 && (asize  0 || (bsize  0 ||!g)))
if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (__mpz_struct stmp)
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);   else if (bsize == 0)  mpz_gcdext (ap, bp, bsize);   else if (bsize == 0)
if (bsize == 0)  /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize))  MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t);   else  MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t);  if ((asize == bsize) && mpn_cmp (ap, bp, asize)  0))
if (bsize == 0)  /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g);  if (asize  bsize)  _mpz_realloc (g, asize); _mpz_realloc (g, asize);  else  MPZ_SVIRTUAL (a, b);   else  /* ptr_size_t */  /* * if it is not an gsize, * then we must strip the gsize */  /* * If we have an gsize, we need to swap U and V. */ if (asize  bsize)  MPZ_SVIRTUAL (a, b);  /* * Recycle the bsize of U as an int * size */  if (asize == bsize)  MPZ_SVIRTUAL (a, b);
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize)  0)  if (bsize == 0)  /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize)  mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t);  if (asize == bsize)
if (bsize == 0)  mpz_gcdext_ptr (ap, bp, bsize); __mpz_fcdext_ptr (ap, bp, bsize); __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR
if (bsize == 0 && __MPZ_SQL_B)
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t);  if (bsize == 0)
if (bsize == 0 && ssize == SIZ (a))
if (bsize == 0)  mpz_dvp (a, b);
if (bsize == 0)  mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g);  else  if (bsize == 0)
if (bsize == 0)  /* bsize = (ssize - bsize)/2.0*/
if (bsize == 0)  /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize))  MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t);   else  mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t);  if (bsize == 0)
if (bsize == 0)  _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_free (g);
if (bsize == 0 &&!(t = tmp_ssize))
if (bsize == 0 && __mpz_struct stmp, gp, sp, tmp_gp, tmp_sp)
if (bsize == 0 && (asize == bsize))
if (bsize == 0)  /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize))  /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0'))  /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0)  /* * Axis of the load */
if (bsize == 0 && psize = 0)
if (bsize == 0)  __mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t);  if (bsize == 0)
if (bsize == 0)  if (!__mpz_gcdext__)  /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t);  else  /* XXX: can't get bsize (e.g., bsize); bsize = 0;    if (! bsize)
if (bsize == 0)  if ((size  (u_long)0) || (size >= (u_long)0))
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0)  /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize;  else  /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0)  /* XXX it's a bsize */
if (bsize == 0 && ap == 0 &&!(a == 0 && a == bsize))
if (bsize == 0)  if ((obj = __mpz_int_objs) &&!(obj == __mpz_int_objs))
if (bsize == 0 && __mpz_object__!= NULL)
if (bsize == 0)  __mpz_free_f(bp);
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);   else if (bsize == 0)
if (bsize == 0)  if (mp_srcptr!= 0)  MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0)  /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g)  asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b);  if (bsize == 0)
if (bsize == 0 && __mpz_struct stmp, bp)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 && (ssize <= 0) && (asize = bsize))
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) __mpz_free_f(bp);
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bp <0)
if (bsize == 0 && mnt &0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else <if (bsize == 0)
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* bsize = (ssize - bsize)/2.0*/
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0 && bsize <0)
if (bsize == 0 && size 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0 && ((bsize = mpz_gcdext_max) &0))
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* XXX it's a bsize */
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* * XXX */
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &mpz_gcdext_ptr (ap, bp, bsize); __mpz_fcdext_ptr (ap, bp, bsize); __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <mpz_gcdext_ptr (ap, bp, bsize); __mpz_fcdext_ptr (ap, bp, bsize); __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize &0 || bsize 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* XXX it's a bsize */
if (bsize == 0) <if (mp_srcptr!= 0) MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 && (asize >= 0 && bsize <bsize))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (__mpz_struct stmp)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) __mpz_free (p, bp, bsize);
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &if (mpz_size_t bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) &mpz_gcdext (idle, idle, 0);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0 && (asize <bsize || ssize bsize))
if (bsize == 0 && bsize &bsize)
if (bsize 0 || bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) <if (MPP_SYMBOL_LOCK_ASSERT (&mpz_ptr_symbol_cmp)) return;
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else &if (bsize == 0)
if (bsize == 0) &/* * * Assigning to the ptr-mtr. If the size of ptr == bsize, we can't assume it. */ if (ptr == -1)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize <bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0 && (ssize = 0) && (asize &= bsize))
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0 && asize <bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <mpz_dvp (a, b);
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bp == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); <else if (bsize == 0)
if (bsize == 0) /* bsize = (ssize - bsize)/2.0*/
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize 1)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* */
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <__mpz_realloc (g, asize); MPZ_COPY (g, asize); __mpz_realloc (g, asize);
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */
if (bsize == 0) &__mpz_free (p, bp, bsize);
if (bsize == 0) </* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) <mpz_gcdext (idle, idle, 0);
if (bsize == 0) /* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) <mpz_gcdext (idle, idle, 0);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0 && psize <= 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) mpz_dvp (a, b);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize <0 || bsize 0)
if (bsize == 0) <if ((obj = __mpz_int_objs) &&!(obj == __mpz_int_objs))
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) <if ((size &(u_long)0) || (size >= (u_long)0))
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0 && (ssize = 0) && (asize <= bsize))
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) 0)
if (asize &= bsize)
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) <#endif
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bp <= 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) <0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (__mpz_struct stmp)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == '<0')
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); else if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 || bsize <= 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
&else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else &if (bsize == 0)
if (bsize == 0 && asize <0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0 && bsize &0)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else &if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) <mpz_gcdext (idle, idle, 0);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* * This is not a priority, but we don't have to set the scale. */ if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize &1)
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <if ((size (u_long)0) || (size >= (u_long)0))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* */
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize &0 && bsize &0)
if (bsize &0 || bsize &0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) &if ((obj = __mpz_int_objs) &&!(obj == __mpz_int_objs))
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 && (asize &bsize || ssize &bsize))
if (bsize == 0 && (asize <0 || (bsize <0 ||!g)))
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0 || bsize 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &if (mp_srcptr!= 0) <MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASYNC_OBJECT (ap, bp, asize))
if (bsize == 0) <mpz__init_i(&stp, s, bsize);
if (bsize == 0) if ((obj = __mpz_int_objs) &&!(obj == __mpz_int_objs))
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); &else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize 0 && bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 || bsize &0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* * This is not a priority, but we don't have to set the scale. */ if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bbsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASYNC_OBJECT (ap, bp, asize))
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (__mpz_struct stmp)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 && m_iocmd_exp = 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 || bsize <bsize)
if (bsize == 0) </* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) mpz_gcdext (idle, idle, 0);
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) if (mp_srcptr!= 0) &MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* * * Assigning to the ptr-mtr. If the size of ptr == bsize, we can't assume it. */ if (ptr == -1)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); &else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0 && (asize &bsize || ssize <bsize))
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else &if (bsize == 0)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == '0')
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0 && (asize >= 0 && bsize bsize))
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize <0 && bsize <0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) &0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &if ((size (u_long)0) || (size >= (u_long)0))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0 && mnt 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* * Axis of the load */
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* * This is not a priority, but we don't have to set the scale. */ if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (asize bsize)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == <0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bp &0)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* * * Assigning to the ptr-mtr. If the size of ptr == bsize, we can't assume it. */ if (ptr == -1)
if (bsize >= 0)
if (bsize == 0) &/* a == 0 or bsize == 0 */ _mpz_realloc (g, asize);
if (bsize == 0 && (asize <0 || (bsize &0 ||!g)))
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0 && ap &= 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* a == 0 or bsize == 0 */ _mpz_realloc (g, asize);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) mpz__init_i(&stp, s, bsize);
if (bsize == 0) <if (mp_srcptr!= 0) <MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize 0 && bsize <0)
if (bsize == 0 && bsize <bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) </* a == 0 or bsize == 0 */ _mpz_realloc (g, asize);
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) __mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize &0 && bsize 0)
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0 && m_iocmd_exp &= 0)
if (bsize == 0) if (MPP_SYMBOL_LOCK_ASSERT (&mpz_ptr_symbol_cmp)) return;
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize > 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* * XXX */
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize <0 || bsize <0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &__mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == &0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* * XXX */
if (bsize == 0) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 1)
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else &if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0 && (asize <bsize || ssize &bsize))
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize <0 || bsize &0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0 && (*ap == bsize) && (*bp == '0'))
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0 && (asize bsize || ssize <bsize))
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <if (mp_srcptr!= 0) &MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) &mpz_dvp (a, b);
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0 || asize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0 && asize bsize)
if (bsize == 0 && asize &0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize <0 && bsize &0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
<else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize <1)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_free (g);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0) &mpz__init_i(&stp, s, bsize);
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else <if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 || asize &bsize)
if (bsize == 0) mpz_gcdext_ptr (ap, bp, bsize); __mpz_fcdext_ptr (ap, bp, bsize); __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0) &/* bsize = (ssize - bsize)/2.0*/
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '<0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) <__mpz_free_f(bp);
if (bsize == 0) &__mpz_free_f(bp);
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); <else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else <if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */ /* bsize = 0 */
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &if (mp_srcptr!= 0) &MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* x-int size -> psize */ if (ap == bsize) _mpz_realloc (g, asize);
if (bsize == 0) if ((size &(u_long)0) || (size >= (u_long)0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0 && (ssize <= 0) && (asize <= bsize))
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 || asize <bsize)
if (bsize == 0 && (ssize &= 0) && (asize <= bsize))
if (bsize == bsize)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
&if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize 0 && bsize &0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0 && ap == bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize &0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0 && (ssize &= 0) && (asize &= bsize))
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (asize &bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0 && (asize bsize || ssize &bsize))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) <0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize <0 && bsize 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 && (*ap == bsize) && (*bp == '<0'))
if (bsize == 0) /* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) mpz_gcdext (idle, idle, 0);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); &else if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) if (mp_srcptr!= 0) <MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) &0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize <0 && bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (!bsize)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* x-int size -> psize */ if (ap == bsize) _mpz_realloc (g, asize);
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize &0 && bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) <0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) &mpz_gcdext (idle, idle, 0);
if (bsize == 0 && (asize 0 || (bsize &0 ||!g)))
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); <else if (bsize == 0)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize &= 0)
if (bsize == 0 && size <0)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) __mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0 && (asize &0 || (bsize &0 ||!g)))
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize 0 && bsize 0)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0 && asize 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize <0)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize = 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) if ((size (u_long)0) || (size >= (u_long)0))
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bp = 0)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (asize <bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize 0 || bsize <0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) mpz_gcdext (idle, idle, 0);
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize &0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize &0 && bsize <0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) if (mpz_size_t bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize &= 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* x-int size -> psize */ if (ap == bsize) _mpz_realloc (g, asize);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0 && ap <= 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((bsize = ap, bp, asize) &0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize &0 || bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0 && bsize 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); MPZ_COPY (g, asize); __mpz_realloc (g, asize);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize <= 0)
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0 && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0 || bsize = 0)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else <if (bsize == 0)
if (bsize == 0) &if ((size <(u_long)0) || (size >= (u_long)0))
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize <0 || bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else &if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0 && (asize >= 0 && bsize &bsize))
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else &if (bsize == 0)
if (bsize == 0 && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '<0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &if (mp_srcptr!= 0) MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) <if ((size <(u_long)0) || (size >= (u_long)0))
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t);
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else <if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; &else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
<if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0 && m_iocmd_exp <= 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize &0 || bsize <0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else </* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_free (g);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (asize <= bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); &else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else /* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0 && (asize bsize || ssize bsize))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '<0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_free (g);
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) <if (mpz_size_t bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else <if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* * Not sure if we are done here, but it's only possible that idle and idle are 0 * so we do not resize the * object's cofactor (which will eventually return the first byte). */ if (idle) &mpz_gcdext (idle, idle, 0);
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize = 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <<else if (bsize == 0)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0 && size &0)
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == -1)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else &if (bsize == 0)
if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else if (bsize == 0)
if (bsize == 0 && mpn_cmp (ap, bp, asize) 0)
if (asize = bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0 &&!((swap == '&0') || ((ap == '&0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize <bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else <if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) __mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &#endif
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0 && (asize &0 || (bsize <0 ||!g)))
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize == 0) &/* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0 || bsize bsize)
if (bsize == 0) #endif
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* */
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0 && psize &= 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0 && ap = 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 || bsize <0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <__mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <&else if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* * XXX - The pc doesn't * hold any gcs * in case the size has been removed. */ ssize = bsize; <else &/* XXX - The pc doesn't handle any gcs */ if ((bsize == 0) && mpn_cmp (ap, bp, asize) == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 && (asize &0 || (bsize 0 ||!g)))
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &__mpz_realloc (g, asize); MPZ_COPY (g, asize); __mpz_realloc (g, asize);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0 && (asize <0 || (bsize 0 ||!g)))
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <__mpz_free (p, bp, bsize);
if (bsize == 0 && mnt <0)
if (bsize == 0 && psize = 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) <mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); <else <if (bsize == 0)
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 && (asize 0 || (bsize <0 ||!g)))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) <mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else <if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <<else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 && asize &bsize)
if (bsize == 0) &/* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); <else if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0 && bsize bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (__MPZ_RX_DECL (a) == bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize <0)
if (bsize == 0 && (asize &bsize || ssize bsize))
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); <if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize 0 || bsize &0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bp &= 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); &if (bsize == 0)
if (bsize == 0 && ap == bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); &if (asize bsize)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) <if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* * Axis of the load */
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) <0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else &mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0 &&!((swap == '<0') || ((ap == '&0') || ((swap == '&0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0 &&!((swap == '<0') || ((ap == '0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize = bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) &0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) if (mp_srcptr!= 0) MPZ_SRCPTR_SWAP (a, b); MPZ_SPPTR_SWAP (ap, bp, bsize);
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize = bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '0') || ((swap == '0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &&else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0 && (ssize &= 0) && (asize = bsize))
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize);
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bp 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize &= bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <else
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); else if (bsize == 0)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) &/* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize &bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 || bsize &= 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0 &&!((swap == '&0') || ((ap == '0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) &if ((size &(u_long)0) || (size >= (u_long)0))
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) <mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); &else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0 &&!((swap == '0') || ((ap == '<0') || ((swap == '&0') || ((swap == '&0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0 &&!((swap == '0') || ((ap == '0') || ((swap == '0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize <bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize <= 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &<else if (bsize == 0)
if (bsize 0 || bsize 0)
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) if ((size <(u_long)0) || (size >= (u_long)0))
if (bsize == 0 && ((bsize = mpz_gcdext_max) 0))
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) /* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, as
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0 && (*ap == bsize) && (*bp == '&0'))
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0 || bsize &bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); <else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); if (bsize == 0)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize &= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); &if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &<else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) <if (!__mpz_gcdext__) &/* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else </* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 &&!((swap == '0') || ((ap == '&0') || ((swap == '&0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <&else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0 && (asize 0 || (bsize 0 ||!g)))
if (bsize == 0 && ap == bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0) <if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <__mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); &if (bsize == 0)
if (bsize == 0 && (asize <bsize || ssize <bsize))
if (bsize == 0) /* XXX it's a bsize */
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0 && ((bsize = mpz_gcdext_max) <0))
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) &0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <= bsize && mpn_cmp (ap, bp, asize) &0)
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) </* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); __mpz_free_src (g); else &if (bsize == 0)
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize &bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize <bsize) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0 && (ssize <= 0) && (asize &= bsize))
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize &= bsize) && (asize &= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); &if (asize bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); if (mpn_gcdext (g, g) <0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); <if (asize bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_LPZ_SWAP (a, b); <if (bsize == 0)
if (bsize == 0) </* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) &MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) <0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) &if (MPP_SYMBOL_LOCK_ASSERT (&mpz_ptr_symbol_cmp)) return;
if (bsize == 0) <if (!__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) &/* * Axis of the load */
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); else &__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else /* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &bsize) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize <= bsize) && (asize = bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); &else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, b); &else &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); if (gp == g)
if (bsize == 0) &/* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) if (!__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <<else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else <mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) &mpz_gcdext (stmp, stmp); if (stmp) mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '<0') &&!mpn_cmp (ap, bp, asize)) /* XXX */ if ((mpn_ptr_ptr[1] == '<0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) <if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <<else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) </* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) _mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); <if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize) mpz_ptr_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); if (asize == bsize)
if (bsize == 0) if (!__mpz_gcdext__) /* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) /* * No ptr with a size of a byte of size, but that's the last flag byte of the bsize. */ if (bsize == 0) <MPZ_RCPTR_SWAP (a, b); MPZ_RCPTR_SWAP (ap, bp, bsize); MPZ_PTR_SWAP (s, t); &&else if (bsize == 0)
if (bsize == 0) &/* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); <else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <else if (bsize == 0) mpz_gcdext (ap, bp, bsize); else if (bsize == 0)
if (bsize == 0) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize &bsize)) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &else if (bsize == 0)
if (bsize == 0) &if (!__mpz_gcdext__) </* XXX: can't get bsize (e.g., bsize) */ MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); else &/* XXX: can't get bsize (e.g., bsize); bsize = 0; if (! bsize)
if (bsize == 0) </* x = -c && ptr(ptr); /* XXX */ if ((mpn_ptr_ptr_str[0] == '&0') &&!mpn_cmp (ap, bp, asize)) </* XXX */ if ((mpn_ptr_ptr[1] == '&0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0') || (mpn_ptr[1] == '0')) /* XXX */ if ((mpn_ptr[1] == '0') || (mpn_ptr[2] == '0') || (mpn_ptr[3] =
if (bsize == 0) /* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize &bsize) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); &if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ asize = ABS (SIZ (a)); bsize = ABS (SIZ (b)); if (__mpz_struct stmp, stmp, stmp) mpz_gcdext (stmp, stmp); if (stmp) &mpz_gcdext (stmp, stmp, stmp, stmp); <else mpz_gcdext (stmp, stmp, stmp); mpz_gcdext (stmp, stmp, stmp); if (stmp 0) /*
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) <mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (asize == bsize && mpn_cmp (ap, bp, asize) 0) &mpz_gcdext (ap, bp, asize); MPZ_PTR_SWAP (s, t); else /* * When the cofactor should be the wrong cofactor */ if (asize == bsize && __mpz_struct stmp_stmp_unsigned (ap, bp, asize) 0) mpz_gcdext (ap,
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &&else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); gp = PTR (g); _mpz_realloc (g, asize); gp = PTR (g); <else mpz_size_t assize, ssize, ssize, ssize, tmp_sp; if (bsize == 0)
if (bsize == 0 && (ssize = 0) && (asize = bsize))
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); <if (mpz_flags & MPZ_OPNTR)
if (bsize == 0) &/* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize == bsize) && (asize <bsize)) /* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASIZED (bsize)) <_mpz_realloc (g, asize); _mpz_realloc (g, asize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &/* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); <if (mpn_gcdext (g, g) 0) MPZ_GCDROP_WAB (a, b); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (
if (bsize!= 0)
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) &MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); <if (asize bsize)
if (bsize == 0) </* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if ((asize = bsize) && (asize <= bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else mpz_srcptr ap; MPZ_SPTR_SWAP (ap, bp, asize); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); if (bsize == 0)
if (bsize == 0) &if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) __mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; &if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) __mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) <MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) &/* _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g); if (asize bsize) &_mpz_realloc (g, asize); _mpz_realloc (g, asize); else MPZ_SVIRTUAL (a, b); else /* ptr_size_t */ /* * if it is not an gsize, * then we must strip the gsize */ /* * If we have an gsize, we need to swap U and V. */ if (asize bsize) MPZ_SVIRTUAL (a, b); /* * Recycle the bsize of U as an int * size */ if (asize == bsize) MPZ_SVIRTUAL (a, b);
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); <else __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) MPZ_SIZE (a, b); if (stmp!=
if (bsize == 0) <if (!__mpz_struct stmp_initialized) <__mpz_struct stmp_initialized = 0; <if (__mpz_struct stmp_initialized) &__mpz_struct stmp_initialized = 0; else if (bsize == 0) __mpz_struct stmp; __mpz_struct stmp; /* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize bsize) __mpz_realloc (g, asize); gp = PTR
if (bsize == 0) /* * If we can't bsize, we can't be unbound, so we need to use it again. */ if ((ap == bsize) || (asize == bsize)) <MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (s, t); &else MPZ_WRAP_SWAP (a, b); MPZ_PRP (a, b); MPZ_PTR_SWAP (s, t); if ((asize == bsize) && mpn_cmp (ap, bp, asize) 0))
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) &if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0 &&!((swap == '&0') || ((ap == '<0') || ((swap == '<0') || ((swap == '<0') || ((ap == '0') || ((swap == '0') || (swap == '0')) || (swap == '0')) || (swap == '0')) || (swap == '0')))) MPZ_SRCPTR_SWAP (a, b); MPZ_PTR_SWAP (ap, asize, bp, bsize); MPZ_PTR_SWAP (s, t); else MPZ_PRINT_WRITE (a, b); MPZ_PRINT_WRITE (a,
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); else if (bsize == 0)
if (bsize == 0) <__mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (ap, asize); &else <__mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); __mpz_realloc (g, asize); MPZ_SYSTEM_SIZE (a, b); __mpz_struct stmp; __mpz_struct stmp; if (stmp!= 0) &MPZ_SIZE (a, b); if (stmp!=
if (bsize == '&0')
if (bsize == 0) &/* mpn_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ ap = PTR (a); bp = PTR (b); if (asize &= bsize && mpn_cmp (ap, bp, asize) 0)
if (bsize == 0) </* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) &asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); &&else if (bsize == 0)
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (s, t); if (bsize == 0) if (asize = 0 && mpn_cmp (ap, bp, asize) 0) MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); else MPZ_WRITE_SIZE (b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (a, b); MPZ_WRITE_SIZE (
if (bsize == 0) /* g = |a|, s = sign(a), t = 0. */ ssize = SIZ (a) >= 0? 1 : -1; if (ALLOC (g) <asize) _mpz_realloc (g, asize); gp = PTR (g); MPN_COPY (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); _mpz_realloc (g, asize); MPN_COPY (g, asize); _mpz_realloc (g, asize); _mp
if (bsize == 0) </* mpz_gcdext requires that U >= V. Therefore, we often have to swap U and V. This in turn leads to a lot of complications. The computed cofactor will be the wrong one, so we have to fix that up at the end. */ if (!ASYNC_OBJECT (ap, bp, asize))
