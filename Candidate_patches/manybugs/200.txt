golden:
<extra_id_0>
inference:

initialized = 0;
flush_std_files();
initialized = 0; flush_std_files();
initialized = 1; flush_std_files();
initialized = PR_FALSE; flush_std_files();
initialized = FALSE; flush_std_files();
initialized = -1; flush_std_files();
initialized = NULL; flush_std_files();
initialized = 1;
if (initialized) flush_std_files();
initialized = false; flush_std_files();
initialized = PR_TRUE; flush_std_files();
initialized = TRUE; flush_std_files();
initialized = flush_std_files();
initialized = true; flush_std_files();
initialized = 0; flush_std_files(0);
call_py_exitfuncs();
Initialized = 0; flush_std_files();
Initialized = 0;
stdout = flush_std_files();
initialized = 0, flush_std_files();
if (interp) flush_std_files();
initialized = (0); flush_std_files();
initialized = PR_FALSE;
initialized = -1;
(void) flush_std_files();
fflush_std_files();
initialized = NULL;
initialize = 0; flush_std_files();
initialized = false;
initialized = initialized; flush_std_files();
initialized = 0; flush_std_files(1);
wait_for_thread_shutdown();
initialized = 0; flush_std_files(NULL);
initialized = False; flush_std_files();
initialized=0; flush_std_files();
initialized = 0; flush_std_files ();
PZ_FiniInterrupts();
return 0;
return (0);
initialized = 0; flush_std_files(interp);
stdout.flush_std_files();
if (interp->interp) flush_std_files();
initialized |= 0; flush_std_files();
initialized = True; flush_std_files();
initialized = 0; flush_std_files;
py_flush_std_files();
initialized = 2; flush_std_files();
#endif
py_exitfuncs();
Initialized = 1; flush_std_files();
initialized++; flush_std_files();
__flush_std_files();
first = 0; flush_std_files();
int initialized = 0; flush_std_files();
if (!initialized) flush_std_files();
return;
initialized = 0; flush_stderr_files();
initialized = FALSE;
Initialize(); flush_std_files();
initialized = 0; flush_std_files = 0;
uninitialized = 0; flush_std_files();
initialized = true;
stdout = 0; flush_std_files();
initialized = 0; flush_stds();
return false;
stdout->flush_std_files();
initialized = initialized = 0; flush_std_files();
initialized = 0; flush_std_files = NULL;
/* Flush stdout+stderr */
PZ_Flush_std_files();
immediateized = 0; flush_std_files();
tstate->interp = tstate->interp;
finalized = 0; flush_std_files();
stdout_flush_std_files();
initialized = 0; flush_std_files(void);
initialized = 0; flush_std_files(fd);
initialized = 0; free_std_files();
return initialized;
run_std_files();
initialized = '0'; flush_std_files();
initialized = 0; (void) flush_std_files();
initialized = False;
initialized = 0; flush_std_files(); #endif
initialized = 1; flush_std_files(initialized);
flush_std_files(); initialized = 0;
start = 0; flush_std_files();
tstate = PyThreadState_GET();
initialize_std_files();
initialized = (void *)0; flush_std_files();
initialized = 0; else flush_std_files();
instantiated = 0; flush_std_files();
clear_std_files();
initialized = PR_TRUE;
initialized = 0; flush_std_files(); */
else flush_std_files();
initialized = 0; break;
initialized = 1; flush_std_files(0);
return true;
initialized = TRUE;
internalized = 0; flush_std_files();
initialized = 0; flush_std_files(p);
/* flush_std_files(); */
/* Get current thread state and interpreter pointer */
initialized = wait_for_thread_shutdown();
initialized = 0; flush_stderr();
initialized = 0; clear_std_files();
initialized = 1; flush_std_files(stderr);
initialized = 0; flush_std_files(true);
free_std_files();
initialized; flush_std_files();
initialized = 0; flush_std_files(tstate);
*initialized = 0; flush_std_files();
initialization = 0; flush_std_files();
initialized = 1; flush_std_files(interp);
call_py_exitfuncs(); initialized = 0;
initialized = 0; flush_std_fds();
initialized = EINVAL; flush_std_files();
initialized = 1; flush_std_files(1);
initialized = rv; flush_std_files();
if (!initialized) return;
if(initialized) flush_std_files();
initialized = 0; flush_std_flags();
return initialized = 0;
initialized -= 0; flush_std_files();
stdout = 0;
initialized = NS_OK; flush_std_files();
if (stderr) flush_std_files();
initialized = 0; flush_std_files(flags);
initialized = 0; flush_std();
PZ_FiniInterrupts(interp);
internalized = 0;
initialized = flags; flush_std_files();
if (Initialized) flush_std_files();
break;
initialized = 0; flush__std_files();
initialized = ret; flush_std_files();
initialized = 0; flush_stdout();
initialized = FAILURE; flush_std_files();
initialized = 0; flush_std_files(buf);
initialized = 0; flush_std_initialized();
if(interp) flush_std_files();
initialized = S_OK; flush_std_files();
initialized = 1; flush_std_files(NULL);
initialized -= 1; flush_std_files();
initialized = 0; flush();
PZ_FiniInterrupt();
initialized = (0);
initialized = 0; flush_std_files(); break;
initialized = (int)0; flush_std_files();
initialized = 0; flush_initialized_files();
initialized = True;
initialized = PR_0; flush_std_files();
initialize = 0;
initialized = stdout; flush_std_files();
initialized = 0; flush_std_files(fp);
initialized = 0; flush_std_files(&interp);
initialized = 0; #endif flush_std_files();
initialized = 0; flush_std_paths();
initialized = 0; flush_std_args();
initialized = 0; flush_std_files(); return;
initialized = 0; flush_std_files(pid);
deprecated_initialized = 0;
initialized = initialized = 0;
set_std_files();
initialized = 0; flush_std_files() = 0;
initialized = 0; flush_initialized();
initialized = 0; flush_std_path();
initialized = 0; flush_std_fs();
initialized = 0; flush_std_cache();
initialized = 0; flush_std_exitfuncs();
i = 0; flush_std_files();
initialized = 0; flush_std_files = 1;
Init();
flags = 0;
initialized = PZ_Flush_std_files();
Initialize();
initialized = -1; flush_std_files(0);
initialized = initialized;
stdout+=stderr;
if (interp->interp)  initialized = 0; flush_std_files();
/* Initialize, flush std_files(); */
/* Flush stdout+stderr */ flush_std_files();
if (tstate->interp!= 0)  initialized = 0; flush_std_files();
/* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); /* Disable signal handling */ PyOS_FiniInterrupts(); /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't happen. */ flush_std_files(); /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); initialized = 0; /* Clear type lookup cache
p = Py_Status_FiniInterrupts(); /* If p == NULL, p is p from the last pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending pending
initialized = 0; flush_std_files(); /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */
initialized = 0; flush_std_files(aMode);
/* We can have a neg_std_doupdate. */
initialized = 0; flush_std_files(PR_TRUE);
if (!iocmd_is_alive())  /* * Note that threading.py uses an exit func to do a join on all the * threads created via Threading. */ flush_std_files();
/* Flush stdout+stderr */ flush_std_files(); /* XXX We should do better, e.g. wipe out all interpreters and threads.) Locking: as above. */ void Py_Finalize(void)  PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * Note that Threading.py uses an exit func to do a join on all the * threads created thru it, so this also protects pending imports in * the
if (interp->interp->flags & Py_WARNING) flush_std_files(); else if (interp->interp->flags & Py_WARNING) flush_std_files();
/* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * Note that Threading.py uses an exit func to do a join on all the * threads created thru it, so this also protects pending imports in * the threads created via Threading. */ flush_std_files();
initialized = 0; flush_std_files(initialized);
initialized = 0; flush_std_files(&initialized);
/* Remove pending threads; */ flush_std_files();
if (!interp)  /* Get current thread state and interpreter pointer */ interp = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */
if (nitialized) flush_std_files();
if (!initialized)  /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); int retstate; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */ flush_std_files(); /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); initialized = 0; /* Clear type lookup cache */
/* XXX flush the ioctlr() code of the thread state and interpreter pointer, except for I/O mismatch */
/* * Get current thread state and interpreter pointer */
/* * Remove thread state and interpreter pointer */ initialized = 0; flush_std_files();
initialized = 0; flush_std_files(); /* Disable signal handling */
initialized = 0; flush_std_files(); /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts();
/* Remove from queue, then flush the threads. */ initialized = 0; flush_std_files(); /* Remove from threads, and flush_std_files(); */
/* * If the current thread is still completely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * Note that Threading.py uses an exit func to do a join on all the * threads created thru it, so this also protects pending imports in * the threads created via Threading. */ flush_std_files();
if (!initialized) return; flush_std_files();
if (initialized)  /* Failed to get the current thread state. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used.) Locking: as above. */ initialized = 0; flush_std_files();
if (tstate == PyThreadState_GET()) return; tstate = PyThreadState_GET(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * Note that Threading.py uses an exit func to do a join on all the * threads created thru it, so this also protects pending imports in * the threads created via Threading. */ flush_std_files();
if (nsnull!= initialized) initialized = 0; flush_std_files();
if (py_xstderr!= 0)  initialized = 0; flush_std_files();
/* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); /* Disable signal handling */ PyOS_FiniInterrupts();
/* * Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); /* Disable signal handling */ PyOS_FiniInterrupts(); /* Disable signal handling */ PyOS_FiniInterrupts(); /* Clear type lookup cache */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */ call_py_exitfuncs(); initialized = 0; /* Flush stdout+stderr */ flush_std_files(); /* Get current thread state and interpreter pointer */
/* First we must handle this function */ return;
/* * Clear type lookup cache */ PyType_ClearCache();
/* * First look up the /cache. */ initialized = 0; flush_std_files();
/* Find current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp;
if (tstate->interp == tstate->interp)  if (interp->interp == NULL)  wait_for_thread_shutdown();
initialized = 0; flush_std_files((u_long)stderr);
initialized = 0; flush_std_files(); /* Flush stdout+stderr */
/* * Check for thread state in partialized state, try again. */ initialized = 0; flush_std_files();
/* Initialized, it's only clear the * thread state and interpreter pointer */ flush_std_files();
if (!initialized)  if (is_open(interp))  if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
/* Set up, since ni-interps do not really care about the state of a thread, so we have a memory of '%s' of this thread, so we use the * funcs to do that and do it. */ initialized = 0; flush_std_files(INTERP);
/* Initialize*/ flush_std_files();
if (!initialized)  flush_std_files(); return;
if (!initialized)  /* We've wiped out the interrupter state. */ flush_std_files();
initialized = 0; flush_std_files(stderr);

if (!initialized) &if (is_open(interp)) &if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (!initialized) if (is_open(interp)) if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (!interp) &/* Get current thread state and interpreter pointer */ interp = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */
/* Flush stdout+stderr */ flush_std_files(); /* XXX We should do better, e.g. wipe out all interpreters and threads.) Locking: as above. */ void Py_Finalize(void) PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * Note that Threading.py uses an exit func to do a join on all the * threads created thru it, so this also protects pending imports in * the
initialized = '<0'; flush_std_files();
if (!initialized) <if (is_open(interp)) if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (!initialized) if (is_open(interp)) <if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (!interp) </* Get current thread state and interpreter pointer */ interp = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */
if (!iocmd_is_alive()) /* * Note that threading.py uses an exit func to do a join on all the * threads created via Threading. */ flush_std_files();
if (initialized) /* Failed to get the current thread state. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used.) Locking: as above. */ initialized = 0; flush_std_files();
if (tstate->interp == tstate->interp) <if (interp->interp == NULL) &wait_for_thread_shutdown();
initialized = 1; flush_std_files();
if (tstate->interp == tstate->interp) &if (interp->interp == NULL) &wait_for_thread_shutdown();
initialized = NULL; flush_std_files();
if (py_xstderr!= 0) <initialized = 0; flush_std_files();
if (!initialized) <if (is_open(interp)) <if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (py_xstderr!= 0) &initialized = 0; flush_std_files();
if (!initialized) &flush_std_files(); return;
if (!initialized) </* We've wiped out the interrupter state. */ flush_std_files();
/* Flush stdout+stderr */ flush_std_files();
if (tstate->interp == tstate->interp) &if (interp->interp == NULL) <wait_for_thread_shutdown();
if (!initialized) /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); int retstate; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */ flush_std_files(); /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); initialized = 0; /* Clear type lookup cache */
if (!initialized) &/* We've wiped out the interrupter state. */ flush_std_files();
if (py_xstderr!= 0) initialized = 0; flush_std_files();
if (interp->interp) initialized = 0; flush_std_files();
/* Flush stdout+stderr */ flush_std_files(); /* XXX We should do better, e.g. wipe out all interpreters and threads.) Locking: as above. */ void Py_Finalize(void) &PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * Note that Threading.py uses an exit func to do a join on all the * threads created thru it, so this also protects pending imports in * the
if (initialized) &/* Failed to get the current thread state. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used.) Locking: as above. */ initialized = 0; flush_std_files();
/* Flush stdout+stderr */ flush_std_files(); /* XXX We should do better, e.g. wipe out all interpreters and threads.) Locking: as above. */ void Py_Finalize(void) <PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * Note that Threading.py uses an exit func to do a join on all the * threads created thru it, so this also protects pending imports in * the
if (!initialized) <if (is_open(interp)) &if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (interp->interp) &initialized = 0; flush_std_files();
initialized = -1; flush_std_files();
if (tstate->interp!= 0) <initialized = 0; flush_std_files();
Initialized = 0; flush_std_files();
initialized = '&0'; flush_std_files();
if (tstate->interp!= 0) &initialized = 0; flush_std_files();
if (!initialized) &/* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); int retstate; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */ flush_std_files(); /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); initialized = 0; /* Clear type lookup cache */
flush_std_files();
if (initialized) </* Failed to get the current thread state. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used.) Locking: as above. */ initialized = 0; flush_std_files();
if (tstate->interp == tstate->interp) &if (interp->interp == NULL) wait_for_thread_shutdown();
if (!initialized) flush_std_files(); return;
if (!initialized) <flush_std_files(); return;
if (!initialized) </* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); int retstate; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */ flush_std_files(); /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyOS_FiniInterrupts(); initialized = 0; /* Clear type lookup cache */
if (tstate->interp == tstate->interp) <if (interp->interp == NULL) wait_for_thread_shutdown();
initialized = 0;
if (!iocmd_is_alive()) &/* * Note that threading.py uses an exit func to do a join on all the * threads created via Threading. */ flush_std_files();
if (interp->interp) <initialized = 0; flush_std_files();
if (!interp) /* Get current thread state and interpreter pointer */ interp = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can't be used. */
initialized = 0; flush_std_files();
if (!initialized) &if (is_open(interp)) if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (!initialized) /* We've wiped out the interrupter state. */ flush_std_files();
if (!iocmd_is_alive()) </* * Note that threading.py uses an exit func to do a join on all the * threads created via Threading. */ flush_std_files();
initialized = '0'; flush_std_files();
if (tstate->interp!= 0) initialized = 0; flush_std_files();
if (tstate->interp == tstate->interp) <if (interp->interp == NULL) <wait_for_thread_shutdown();
if (tstate->interp == tstate->interp) if (interp->interp == NULL) &wait_for_thread_shutdown();
if (!initialized) if (is_open(interp)) &if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (!initialized) &if (is_open(interp)) <if (interp->interp->info->intr_state &&!interp->interp->info->intr_state) return; wait_for_thread_shutdown();
if (tstate->interp == tstate->interp) if (interp->interp == NULL) wait_for_thread_shutdown();
if (tstate->interp == tstate->interp) if (interp->interp == NULL) <wait_for_thread_shutdown();
