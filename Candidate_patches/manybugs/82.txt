golden:
if->tif_flags &= ~TIFF_BUF4WRITE;
inference:
#endif

tif->tif_flags |= TIFF_CODERSETUP;
return (0);
if (tif->tif_flags & TIFF_CODERSETUP) return (0);
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
tif->tif_rawcp = NULL;
/* * Set state to appear as if a * tile has just been read in. */
tif->tif_curtile = tile;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0);
splx(s);
if (!(tif->tif_flags & TIFF_CODERSETUP)) return (0);
tif->tif_flags &= TIFF_CODERSETUP;
tif->tif_rawcc = NULL;
else  tif->tif_rawcp = NULL;
tif->tif_col = NULL;
return 0;
else tif->tif_rawcp = NULL;
else  tif->tif_rawcp = NULL; td->td_rawcc = 0;
return NULL;
TIFFStartTile(tif, uint32 tile);
TIFF_UNLOCK(tif);
tif->tif_flags |= TIFF_CODESETUP;
/* Set state to appear as if a * tile has just been read in. */
#ifdef DEBUG
tif->tif_col = 0;
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
tif->tif_flags |= TIFFCODERSETUP;
free(tif->tif_flags);
/* XXX */
if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0);
break;
tif->tif_rawcc = 0;
if (!tif->tif_flags || TIFF_CODERSETUP) return (0);
if(tif->tif_flags & TIFF_CODERSETUP) return (0);
if (!(tif->tif_setupdecode)(tif)) return (0);
if (!(*tif->tif_setupdecode)(tif)) return (0);
free(tile);
if (!tif->tif_flags & TIFF_CODERSETUP) return (0);
tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
@endif
*tif->tif_flags |= TIFF_CODERSETUP;
else tif->tif_rawcc = NULL;
else  tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
tif->tif_flags |= TIF_CODERSETUP;
if (tif->tif_flags & TIFF_CODERSETUP) return 0;
(*tif->tif_flags & TIFF_CODERSETUP) = 0;
td->td_flags |= TIFF_CODERSETUP;
#else return (0); #endif
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return ((0));
*/
free(tif);
if (tif->tif_flags & TIFF_CODESETUP) return (0);
if (tif->tif_flags & TIFF_CODERSETUP) return ((0));
TIFF_LOCK(tif);
int i;
if (tif->tif_rawcp == NULL) return (0);
tif->tif_rawc = NULL;
return ((*tif->tif_rawcp = tif->tif_rawdata));
tif->tif_rawdata = NULL;
TIFFStartTile(tif);
tif->tif_lock = 0;
tif->tif_iocmd = 0;
tif->tif_freecp = NULL;
tif->tif_cp = NULL;
TIFF_LOCK_ASSERT(tif);
tif->tif_size = 0;
tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CODERSETUP)  return (0);
tif->tif_width = 0;
return (NULL);
else
if (tif->tif_flags & TIFF_CODERSETUP) continue;
if (*tif->tif_flags & TIFF_CODERSETUP) return (0);
else  tif->tif_rawcp = tif->tif_rawdata;
return (tif->tif_flags & TIFF_CODERSETUP);
continue;
tif->tif_curtile = tif->tif_curtile;
i = 0;
tif->tif_row = 0;
tif->tif_line = NULL;
if (tif->tif_flags & TIFF_CODERSETUP)
tif->tif_curtile = 0;
if (tif->tif_flags & TIFF_CODERSETUP) return (NULL);
#if 0
else return (0);
TIFFStartTile(tif, &tif->tif_dir);
tif->tif_rawcp = 0;
tif->tif_col = NULL; tif->tif_rawcc = 0;
if (tif->tif_rawcp == NULL) return 0;
else  tif->tif_rawcc = NULL;
if (tif->tif_flags | TIFF_CODERSETUP) return (0);
if (tif->tif_rawcp == NULL) tif->tif_rawcc = 0;
mtx_unlock(&tif->tif_lock);
if (!tif->tif_setupdecode) return (0);
if (!(*tif->tif_flags & TIFF_CODERSETUP)) return (0);
#else
tif->tif_rawcp = tif->tif_rawdata;
tif->tif_cflags |= TIFF_CODERSETUP;
if (tif->tif_flags & TIFF_CODERSETUP) break;
if ((tif->tif_flags & TIFF_CODERSETUP)!= 0) return (0);
tif->tif_type = tif->tif_type;
tif->tif_flags = TIFF_CODERSETUP;
else tif->tif_rawcp = NULL; td->td_rawcc = 0;
free(tif->tif_rawcp);
tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
if (tif->tif_curtile == 0) return (0);
tif->tif_end = 0;
tif->tif_length = 0;
if (tif->tif_flags&TIFF_CODERSETUP) return (0);
if ((*tif->tif_flags & TIFF_CODERSETUP) == 0) return (0);
tif->tif_line = 0;
return TRUE;
if (tif->tif_curtile) return (0);
else  tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
tif->tif_cnt = 0;
TIFFStartTile(tif, tile);
tif->tif_cleanup = 0;
return ((*tif->tif_flags & TIFF_CODERSETUP)(tif));
tif->tif_cc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) return (TIFF_CODERSETUP);
if((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0);
return ((*tif->tif_flags & TIFF_CODERSETUP) == 0);
tif->tif_len = 0;
/*
tif->tif_link = 0;
if (tif->tif_rawcp == NULL) return (NULL);
#else tif->tif_flags |= TIFF_CODERSETUP; #endif
else tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
return (tif->tif_rawcp = NULL);
else tif->tif_rawcc = 0;
mtx_unlock(&tif->tif_mtx);
if ((tif->tif_flags & TIFF_CODESETUP) == 0) return (0);
tif->tif_curtile = tif;
if (tif->tif_flags & TIFF_CODERSETUP) return (1);
tif->tif_rawcp = NULL; td->td_rawcc = 0;
tif->tif_size = tif->tif_size;
/* * Set state to appear as if * a * tile has just been read in. */
if ((tif->tif_flags & TIFF_CODERSETUP) == 0)
return ((*tif->tif_rawcp = tif->tif_rawdata);
if (tif->tif_flags & TIFF_CODERSETUP) return(0);
else  tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
if (!(tif->tif_flags & TIFF_CODERSETUP)) return 0;
tif->tif_flags |= TIFF_CODERSETUP; #endif
tif->tif_width = tile;
;
tif->tif_freecp = NULL; tif->tif_freecc = 0;
tif->tif_predecode = 0;
else  tif->tif_rawc = NULL; tif->tif_rawcc = 0;
tif->tif_rawc = NULL; tif->tif_rawcc = 0;
else if (tif->tif_flags & TIFF_CODERSETUP) return (0);
/* * Set state to appear as a * tile has just been read in. */
/* * Set state to appear as if a * tile has just been read in */
tif->tif_flags |= TIFF_CODERSETUP | TIFF_CODERSETUP;
if (tif->tif_curtile) tif->tif_curtile = tile;
if (!((tif->tif_flags & TIFF_CODERSETUP))) return (0);
tif->tif_curtile = td->td_curtile;
if (tif->tif_flags & TIFF_MODESETUP) return (0);
else tif->tif_rawcp = tif->tif_rawdata;
tif->tif_predecode = tif->tif_predecode;
if (tif->tif_needs_clear)  tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP;  if (tif->tif_curtile && tif->tif_curtile!= 0)  tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = 0;
if ((tif->tif_data->tif_negs)!= 0) return ((0));
if (tif->tif_flags & TIFF_CMD_NOT_SET)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;  if
tif->tif_backend = NULL;
if (tif->tif_flags & TIFF_CODERSETUP)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP;  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_filetype = tif->tif_filetype;
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP)  if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!(tif->tif_flags & TIFF_CODERSETUP) || (tif->tif_curtile = tile)) return (0);
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0))  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));  return (0);
return ((*tif->tif_flags & TIFF_CODERSETUP)(tif, &tif->tif_table)(tile));
tif->tif_wrapper = NULL;
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0))  tif->tif_rawcc = NULL;  else  tif->tif_rawcc = NULL;
/* * Set state to appear as if a * tile has just been read in. */ tif->tif_ro_sep_hash = tif->tif_ro_sep_hash_resolve(tif, tif->tif_ro_sep_hash_resolve); tif->tif_ro_sep_hash = tif->tif_ro_sep_hash_resolve(tif->tif_ro_sep_hash_resolve); tif->tif_ro_sep_hash_resolve(tif->tif_ro_sep_hash_resolve); tif->tif_ro_sep_hash = tif->tif_ro_sep_hash_resolve; tif->tif_ro_sep_hex_resolve = tif->tif_ro_se
/* * XXX FIXME: XXX need to fixup. */ tif->tif_ctrl = tif->tif_ctrl;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;  else  tif->
if (tif->tif_idx  TIFF_IDX)  tif->tif_idx++;
else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_POINTER) return (TIFFPOINTER);
if (tif->tif_flags & TIFF_CMD)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
tif->tif_tif_sendtd(tif);
/* * A partition is set and we can't * return it * as * a '0'. This is needed for this to * do this. */ if (tif->tif_flags & TIFF_CODERSETUP) return (EINVAL); if (tif->tif_curtile && (tif->tif_row  td->td_imagewidth)) return (EINVAL); if (tif->tif_col == td->td_tilewidth) return (EINVAL);
else if (tif->tif_flags & TIFF_RUNTIMEWAVE)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_type == TIFFTYPE_PREDELAY) && tif->tif_flags & TIFF_CODERSETUP) return (0);
if (tif->tif_flags & TIFF_CODERSETUP)  if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_dialog = 0;
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_type == TIFFTYPE_DEV)  tif->tif_flags |= TIFFTYPE_DEV;  if (tif->tif_mode == TIFFTYPE_FOREGROUND)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc =
return ((*tif->tif_init_data)(tif, (uint32)(tile)));
return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_linkmap = 0;
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0))  if (tif->tif_names & TIFF_NO_DEBUG)  tif->tif_names &= TIFF_NO_DEBUG;
if (tif->tif_curtile) return (_(TIFFIO)(tif->tif_curtile));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP)  tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_unrefs = 0;
tif->tif_removed = 1;
if (tif->tif_flags & TIFF_CODERSETUP) return ((*tif->tif_flags & TIFF_CODERSETUP))? 0 : 0;
return ((*tif->tif_unrefs)(tif, uint32)(tile/td->td_stripsperimage)));
if (tif->tif_irq_ref_map == 0)  if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0);  tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
if (tif->tif_flags & TIFF_DEBUG)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16
tif->tif_dst = (tif->tif_dst_map == 0)? 0 : 0;
tif->tif_file = NULL;
if (tif->tif_sflags & TIFF_CSTRING_SYNC) return (0);
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP)  if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_freelist = NULL;
return ((tif->tif_rawcp = NULL); tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_sc_rawdata!= NULL)  if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL;  else  tif->tif_sc_rawdata = NULL;
/* * If a * tile has just been read in, this will always set it. */ if (tif->tif_freecp == NULL)  tif->tif_freecp = NULL;
else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile];  return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (!tif->tif_flags || TIFF_CODERSETUP)  if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
/* * Set state to appear as if a * tile has just been read in. */ tif->tif_operator = NULL;
tif->tif_freecp = NULL; tif->tif_freecc = 0;  else  tif->tif_freecp = NULL; tif->tif_freecc = 0;
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_noreaddress) tif->tif_noreaddress = ((tif->tif_flags & TIFF_UNREACHED) == 0)? 0 : 0; if (tif->tif_renderer) tif->tif_renderer = ((tif->tif_renderer) && ((tif->tif_renderer) && ((tif->tif_renderer) && ((tif->tif_renderer) && ((tif->tif_renderer) && (tif->tif_renderer) && ((tif->tif_renderer) && (tif->tif_renderer) && (tif->tif_renderer) && ((tif->tif_renderer) && (tif->tif_renderer) && (tif->t
/* * We will now set the right tile from the top of the tile. */ if (!(tif->tif_setupdecode)(tif)) return (0);
if ((tif->tif_flags & TIFF_CODERSETUP) == 0)  if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile];  return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));  return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_strip_tx = 0;
tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0)  if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0;  else  tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_sflags & TIFF_SOFT) tif->tif_sflags |= TIFF_SOFT;
tif->tif_freespace = 0;
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
tif->tif_eolflags |= TIFF_EOOL;
tif->tif_rawcc = 0;  else  tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
return (tif->tif_drag)(tif, (uint16)(tile/td->td_stripsperimage));
tif->tif_free = NULL;
tif->tif_ctrl = TIFFTYPE(tif);
tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile];  return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_table = NULL; tif->tif_table = NULL;
/* * * FIXME: * The order is just to use the image size *. */ if (!tif->tif_isalpha)  tif->tif_segment = TIFFSAFE_FROM;
if (!(tif->tif_console_flags & TIFF_CONSOLE_ON)(tif)) return (0);
tif->tif_li = tile;
else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
return ((*tif->tif_decode)(tif, (uint32)(tile/td->td_decode)));
/* * XXX if we have an TIFF directory, don't change TIFF */ tif->tif_newname = tif->tif_newname; tif->tif_nextname = tif->tif_nextname; tif->tif_flags |= TIFF_CODERSETUP;
if (tif->tif_iocmd == TIFF_IO_INVALID)  return (0);
return (tif->tif_rawcp % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;
if (tif->tif_rawcp == NULL)  tif->tif_rawcc = NULL;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_wc = NULL;
if (tif->tif_btn)  if ((tif->tif_flags & TIFF_OFFSETUP) == 0)  if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0);   tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_
else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_relx == 0) return (0);
tif->tif_reset = 0;
if (!tif->tif_flags || TIFF_CODERSETUP)  return (0);
if (tif->tif_curtile && (tif->tif_curtile == 0) && (tif->tif_curtile == 0)) return (0);
tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile];  return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef M_PTR_2 if (tif->tif_tif_table == 0) return (NULL); #endif
if (tif->tif_type == TIFFTYPE_GOTO) return (0);
tif->tif_cleanup = (tif->tif_cleanup == 0)? 0 : 0;
if (tif->tif_flags & TIFF_POINTUP) return (EXCLUSIVE);
/* * Reset to the if 0 of * the other files are at least 1 or 0 of them. */ tif->tif_cr = 0;
if (tif->tif_ptr == '0')  return (0);
if (tif->tif_flags & TIFF_CODERSETUP)  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile];  return ((*tif->tif_predecode)(tif, (u
tif->tif_free = 0;
if (tif->tif_flags & TIFF_POINTER)  tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP;  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_flags & TIFF_CODERSETUP)  if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcc = 0;  else  tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0)  if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];  return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP)  if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth;  else  tif->tif_rawcp = NULL; tif->tif_rawcc = 0;  else  tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_stripbytecount!= 0)  if ((tif->tif_flags & TIFF_CODERSETUP) == 0)  if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0);  tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW)  tif->tif_rawcp = NULL; tif->tif_rawcc =

/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; else tif->tif_rawcc = NULL;
&else
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_freecp = NULL; tif->tif_freecc = 0; &else tif->tif_freecp = NULL; tif->tif_freecc = 0;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (!tif->tif_flags || TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= TIFF_NO_DEBUG;
&else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; <else &tif->tif_rawcc = NULL;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else tif->tif_rawcp = NULL;
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
&else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
/* * If a * tile has just been read in, this will always set it. */ if (tif->tif_freecp == NULL) tif->tif_freecp = NULL;
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_freecp = NULL; tif->tif_freecc = 0; &else &tif->tif_freecp = NULL; tif->tif_freecc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_irq_ref_map == 0) &if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; t
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#endif
#endif
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else
else <tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; else <tif->tif_rawcc = NULL;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_ptr == '&0') &return (0);
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
return NULL;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
return (tif->tif_flags & TIFF_CODERSETUP);
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
<else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) <if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else tif->tif_rawcp = NULL; td->td_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; <else <tif->tif_rawcc = NULL;
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; else tif->tif_rawcc = NULL;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&if (tif->tif_flags & TIFF_CODERSETUP) return (0);
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
else &tif->tif_rawcp = tif->tif_rawdata;
<else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; t
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; &else tif->tif_rawcc = NULL;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; <else <tif->tif_rawcc = NULL;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= <TIFF_NO_DEBUG;
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
return (0);
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_freecp = NULL; tif->tif_freecc = 0; <else tif->tif_freecp = NULL; tif->tif_freecc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawc = NULL; tif->tif_rawcc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcc = NULL;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_POINTER) <tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else &tif->tif_sc_rawdata = NULL;
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
<else <tif->tif_rawcp = NULL;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
&else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) return (0);
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; td->td_rawcc = 0;
else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
&#endif
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_flags || TIFF_CODERSETUP) <return (0);
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; &else tif->tif_rawcc = NULL;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; else &tif->tif_rawcc = NULL;
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else &tif->tif_sc_rawdata = NULL;
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_flags || TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; t
else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; <else &tif->tif_rawcc = NULL;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
&else tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (!tif->tif_flags || TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else <tif->tif_sc_rawdata = NULL;
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; <else tif->tif_rawcc = NULL;
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else tif->tif_rawcp = NULL; td->td_rawcc = 0;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= <TIFF_NO_DEBUG;
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else <tif->tif_sc_rawdata = NULL;
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_POINTER) <tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
if (tif->tif_idx &TIFF_IDX) tif->tif_idx++;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; t
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
/* * * FIXME: * The order is just to use the image size *. */ if (!tif->tif_isalpha) tif->tif_segment = TIFFSAFE_FROM;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
<else tif->tif_rawcp = NULL; td->td_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; td->td_rawcc = 0;
<else <tif->tif_rawcp = NULL; td->td_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
/* * A partition is set and we can't * return it * as * a '0'. This is needed for this to * do this. */ if (tif->tif_flags & TIFF_CODERSETUP) return (EINVAL); if (tif->tif_curtile && (tif->tif_row <td->td_imagewidth)) return (EINVAL); if (tif->tif_col == td->td_tilewidth) return (EINVAL);
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; t
else <tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else tif->tif_sc_rawdata = NULL;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
<else <tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else <tif->tif_rawcp = NULL;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else tif->tif_sc_rawdata = NULL;
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else tif->tif_sc_rawdata = NULL;
else tif->tif_rawcp = tif->tif_rawdata;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_POINTER) tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
else tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_idx <TIFF_IDX) <tif->tif_idx++;
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= <TIFF_NO_DEBUG;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; t
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
else &tif->tif_rawc = NULL; tif->tif_rawcc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else tif->tif_rawcp = tif->tif_rawdata;
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
/* * If a * tile has just been read in, this will always set it. */ if (tif->tif_freecp == NULL) <tif->tif_freecp = NULL;
&else <tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
return ((tif->tif_rawcp = NULL); tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
else &tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
<else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) <if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
else
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; else <tif->tif_rawcc = NULL;
if (tif->tif_iocmd == TIFF_IO_INVALID) return (0);
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_irq_ref_map == 0) if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); <tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
if (tif->tif_idx TIFF_IDX) <tif->tif_idx++;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; t
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
else tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
return ((*tif->tif_flags & TIFF_CODERSETUP) == 0);
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
/* * A partition is set and we can't * return it * as * a '0'. This is needed for this to * do this. */ if (tif->tif_flags & TIFF_CODERSETUP) return (EINVAL); if (tif->tif_curtile && (tif->tif_row td->td_imagewidth)) return (EINVAL); if (tif->tif_col == td->td_tilewidth) return (EINVAL);
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else <tif->tif_sc_rawdata = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = tif->tif_rawdata;
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else <tif->tif_sc_rawdata = NULL;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= <TIFF_NO_DEBUG;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= TIFF_NO_DEBUG;
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_flags &= <TIFF_CODERSETUP;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; t
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_idx <TIFF_IDX) tif->tif_idx++;
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else tif->tif_sc_rawdata = NULL;
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else &tif->tif_sc_rawdata = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
if (!tif->tif_flags || TIFF_CODERSETUP) &return (0);
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else &tif->tif_sc_rawdata = NULL;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * If a * tile has just been read in, this will always set it. */ if (tif->tif_freecp == NULL) &tif->tif_freecp = NULL;
tif->tif_flags &= <TIFF_CODERSETUP;
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (!tif->tif_flags || TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
else tif->tif_rawcp = NULL;
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (!tif->tif_flags || TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else <tif->tif_sc_rawdata = NULL;
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = tif->tif_rawdata;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) &if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
else tif->tif_rawcc = NULL;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags &= TIFF_CODERSETUP;
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; else tif->tif_rawcc = NULL;
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
/* * A partition is set and we can't * return it * as * a '0'. This is needed for this to * do this. */ if (tif->tif_flags & TIFF_CODERSETUP) return (EINVAL); if (tif->tif_curtile && (tif->tif_row &td->td_imagewidth)) return (EINVAL); if (tif->tif_col == td->td_tilewidth) return (EINVAL);
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_idx TIFF_IDX) &tif->tif_idx++;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_idx <TIFF_IDX) &tif->tif_idx++;
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->
tif->tif_flags &= TIFF_CODERSETUP;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_freecp = NULL; tif->tif_freecc = 0; else tif->tif_freecp = NULL; tif->tif_freecc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
else <tif->tif_rawcp = NULL; td->td_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= <TIFF_NO_DEBUG;
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else tif->tif_rawc = NULL; tif->tif_rawcc = 0;
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) &if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
tif->tif_freecp = NULL; tif->tif_freecc = 0; &else <tif->tif_freecp = NULL; tif->tif_freecc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<return (0);
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; &else tif->tif_rawcc = NULL;
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else &tif->tif_rawcc = NULL;
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; t
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
<else &tif->tif_rawc = NULL; tif->tif_rawcc = 0;
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else <tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
else &tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_iocmd == TIFF_IO_INVALID) &return (0);
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= &TIFF_NO_DEBUG;
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; t
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; <else <tif->tif_rawcc = NULL;
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&return (0);
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= TIFF_NO_DEBUG;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
<else tif->tif_rawcp = NULL;
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_POINTER) tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_ptr == '&0') <return (0);
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
return 0;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= TIFF_NO_DEBUG;
&else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
if (tif->tif_idx TIFF_IDX) tif->tif_idx++;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
&else &tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if ((tif->tif_flags & TIFF_CODERSETUP) == 0)
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= &TIFF_NO_DEBUG;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; td->td_rawcc = 0;
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags &= &TIFF_CODERSETUP;
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
<else tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP)
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= TIFF_NO_DEBUG;
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else <tif->tif_sc_rawdata = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; &else <tif->tif_rawcc = NULL;
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
&else tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else tif->tif_sc_rawdata = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else &tif->tif_rawcp = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_
if (tif->tif_flags & TIFF_CODERSETUP) <return (0);
tif->tif_freecp = NULL; tif->tif_freecc = 0; <else &tif->tif_freecp = NULL; tif->tif_freecc = 0;
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_irq_ref_map == 0) <if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); &tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; else &tif->tif_rawcc = NULL;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_irq_ref_map == 0) if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); &tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else tif->tif_sc_rawdata = NULL;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= &TIFF_NO_DEBUG;
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
<else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_ptr == '0') <return (0);
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; &else <tif->tif_rawcc = NULL;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; else &tif->tif_rawcc = NULL;
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * * FIXME: * The order is just to use the image size *. */ if (!tif->tif_isalpha) <tif->tif_segment = TIFFSAFE_FROM;
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else &tif->tif_sc_rawdata = NULL;
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_freecp = NULL; tif->tif_freecc = 0; <else <tif->tif_freecp = NULL; tif->tif_freecc = 0;
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= <TIFF_NO_DEBUG;
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
<else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) &if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_POINTER) tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= <TIFF_NO_DEBUG;
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else &tif->tif_rawcp = NULL; td->td_rawcc = 0;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_iocmd == TIFF_IO_INVALID) <return (0);
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
&else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
<else &tif->tif_rawcp = tif->tif_rawdata;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_
&else &tif->tif_rawc = NULL; tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
&else tif->tif_rawcp = NULL;
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_flags |= TIFF_CODESETUP;
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_flags |= TIFF_CODERSETUP;
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) return (0);
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; td->td_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else &tif->tif_sc_rawdata = NULL;
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_freecp = NULL; tif->tif_freecc = 0; else &tif->tif_freecp = NULL; tif->tif_freecc = 0;
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; t
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else <tif->tif_rawcp = NULL;
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else <tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
return (0);
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_POINTER) &tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (!tif->tif_flags || TIFF_CODERSETUP) return (0);
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_irq_ref_map == 0) if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= &TIFF_NO_DEBUG;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; else <tif->tif_rawcc = NULL;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; &else <tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_POINTER) &tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= TIFF_NO_DEBUG;
<else &tif->tif_rawcp = NULL;
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= TIFF_NO_DEBUG;
<else &tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0;
return ((*tif->tif_unrefs)(tif, uint32)(tile/td->td_stripsperimage)));
tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
<else <tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; &else &tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_ptr == '&0') return (0);
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= TIFF_NO_DEBUG;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcc = NULL;
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
else tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else &tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; <else tif->tif_rawcc = NULL;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= &TIFF_NO_DEBUG;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags &= &TIFF_CODERSETUP;
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
/* * Set state to appear as if a * tile has just been read in. */
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
<else &tif->tif_rawcp = NULL;
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else <tif->tif_sc_rawdata = NULL;
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->
&else &tif->tif_rawcc = NULL;
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_irq_ref_map == 0) <if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); <tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) &tif->tif_names &= TIFF_NO_DEBUG;
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else tif->tif_sc_rawdata = NULL;
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; t
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (!tif->tif_flags || TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= <TIFF_NO_DEBUG;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_ptr == '<0') return (0);
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_irq_ref_map == 0) &if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); &tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_ptr == '<0') &return (0);
<if (tif->tif_flags & TIFF_CODERSETUP) return (0);
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else &tif->tif_rawcp = NULL;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else &tif->tif_sc_rawdata = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else &tif->tif_sc_rawdata = NULL;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawc = NULL; tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawc = NULL; tif->tif_rawcc = 0;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
<else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_idx &TIFF_IDX) &tif->tif_idx++;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else &tif->tif_rawcp = NULL;
else <tif->tif_rawcp = NULL;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->
tif->tif_freecp = NULL; tif->tif_freecc = 0; else <tif->tif_freecp = NULL; tif->tif_freecc = 0;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawc = NULL; tif->tif_rawcc = 0;
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; <else tif->tif_rawcc = NULL;
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= &TIFF_NO_DEBUG;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return (0);
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
<else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else &tif->tif_sc_rawdata = NULL;
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else tif->tif_rawc = NULL; tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_POINTER) <tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_irq_ref_map == 0) <if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; td->td_rawcc = 0;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; t
&else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
else &tif->tif_rawcp = NULL; td->td_rawcc = 0;
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) <tif->tif_rawcc = NULL; &else &tif->tif_rawcc = NULL;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (tif->tif_flags & TIFF_POINTER) &tif->tif_op = tif->tif_op; tif->tif_p = tif->tif_p; tif->tif_p = tif->tif_p; tif->tif_w = tif->tif_w; tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOR
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
/* * * FIXME: * The order is just to use the image size *. */ if (!tif->tif_isalpha) &tif->tif_segment = TIFFSAFE_FROM;
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0;
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else <tif->tif_sc_rawdata = NULL;
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcc = NULL;
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_flags || TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) &if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= &TIFF_NO_DEBUG;
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_sc_rawdata!= NULL) <if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; <else tif->tif_sc_rawdata = NULL;
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; t
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else <tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_flags & TIFF_CODERSETUP) &return (0);
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; t
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; else tif->
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0;
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; t
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= <TIFF_NO_DEBUG;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
<else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
/* * The "set" state * has been set. */ if (tif->tif_flags & TIFF_CODERSETUP) <if (!(tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawc
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) <tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) &tif->tif_rawcc = NULL; <else &tif->tif_rawcc = NULL;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_ptr == '0') return (0);
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) if (tif->tif_names & TIFF_NO_DEBUG) tif->tif_names &= &TIFF_NO_DEBUG;
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; td->tif_rawcc = (tm
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_sc_rawdata!= NULL) &if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; &else tif->tif_sc_rawdata = NULL;
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef XP_MAC if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; td->tif_rawcc = (tm
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
&else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0;
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
/* * We could not copy data if it is not a safe target; */ if (tif->tif_flags & TIFF_CTORSETUP) &tif->tif_curtile = tif; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc == 0)) tif->tif_rawcc = NULL; &else &tif->tif_rawcc = NULL;
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else <tif->tif_rawcp = tif->tif_rawdata;
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
&else tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_flags & TIFF_DEBUG) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
&else tif->tif_rawcp = tif->tif_rawdata;
if (!tif->tif_flags || TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; t
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0;
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; &return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_names && ((tif->tif_flags & TIFF_NO_DEBUG) == 0)) <if (tif->tif_names & TIFF_NO_DEBUG) <tif->tif_names &= &TIFF_NO_DEBUG;
else &tif->tif_rawcp = NULL;
<else
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_stripbytecount!= 0) if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0;
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_ptr == '0') &return (0);
if (tif->tif_type == TIFFTYPE_DEV) tif->tif_flags |= TIFFTYPE_DEV; <if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL;
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawcc; tif->tif
/* XXX::set state to appear as if a * tile has just been read in. */ if (!tif->tif_flags & TIFF_CODERSETUP) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; t
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
<else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
&else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; <if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_needs_clear) &tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; &if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->t
if (tif->tif_stripbytecount!= 0) &if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
/* * XXX * If there is no TIFF in TIFF_SOFTS, then we get the 'to' tile in the default default to a TIFF. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawc
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0;
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
#ifdef USE_STREAM_LOCK if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawcc; tif->tif
&else <tif->tif_rawcp = NULL;
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_idx &TIFF_IDX) <tif->tif_idx++;
if (tif->tif_flags & TIFF_CMD) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc
<else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; <return ((*tif->tif_rawdecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * Set state to appear as if a * tile has just been read in. */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->
if (tif->tif_flags & TIFF_CMD_NOT_SET) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; &else tif->
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; &if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) <tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if (tif->tif_type == TIFFTYPE_DEV) &tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
/* * XXX - I must have already done the tile. */ tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
if (tif->tif_type == TIFFTYPE_DEV) <tif->tif_flags |= TIFFTYPE_DEV; if (tif->tif_mode == TIFFTYPE_FOREGROUND) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc =
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
tif->tif_flags |= TIFF_CODERSETUP; &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(tile
tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile /td->td_stripsperimage)));
if (tif->tif_ptr == '<0') <return (0);
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); &return (0);
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_rawcp == NULL) &tif->tif_rawcc = NULL; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_stripbytecount!= 0) <if ((tif->tif_flags & TIFF_CODERSETUP) == 0) if (!(*tif->tif_flags & TIFF_CODERSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc =
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_flags & TIFF_DEBUG) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16
if (tif->tif_flags & TIFF_CMD_NOT_SET) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (!tif->tif_flags || TIFF_CODERSETUP) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc;
else <tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_rawcp == NULL) tif->tif_rawcc = NULL; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
if (tif->tif_flags & TIFF_CODERSETUP) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
/* * XXX This must always be implemented by the XXX * version of XXX */ if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_flags |= TIFF_CODERSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)
/* * If a * tile has just been read in, * then * We must set a tile to an unsigned -tx-int32 format. */ if (tif->tif_flags & TIFF_CODERSETUP) <if ((tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc =
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata;
if (tif->tif_flags & TIFF_CMD_NOT_SET) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = td->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; if
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
/* XXX if we're using a tif as we are in the last ctx: */ if ((tif->tif_rawcp = NULL) && (tif->tif_rawcc = 0)) <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); <return (0);
<else &tif->tif_rawcp = tif->tif_rawdata;
if (tif->tif_btn) if ((tif->tif_flags & TIFF_OFFSETUP) == 0) if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
&else &tif->tif_rawcp = NULL; tif->tif_rawcc = NULL;
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_rawrawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) &tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
if (tif->tif_flags & TIFF_CODERSETUP) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage))); return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else tif->tif_rawcc = NULL; tif->tif_rawcc = NULL;
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_predecode)(tif, (uint16)(
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; &else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawcc; <else tif->
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <<tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) &if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
if (tif->tif_flags & TIFF_CODERSETUP) if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else tif->tif_rawcc = 0; else tif->tif_rawcc = td->td_rawdata; tif->tif_raw
else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = NULL; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
&else <tif->tif_rawcc = NULL; tif->tif_rawcc = 0;
if (tif->tif_btn) &if ((tif->tif_flags & TIFF_OFFSETUP) == 0) &if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); <&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (!tif->tif_tif_flags || tif->tif_tif_flags || TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_
if (tif->tif_rawcp == NULL) <tif->tif_rawcc = NULL; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; <return ((*tif->tif_rawcp)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_flags & TIFF_CMD) <tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawdata; t
/* * Get the tile's' to the bottom of the tile. */ tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_
&else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if ((tif->tif_flags & TIFF_CODERSETUP) == 0) <if (!(*tif->tif_setupdecode)(tif)) return (0); tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcc = (tmsize_t)td->td_rawdata; tif->tif_rawcc = (t
else &tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
<else if (tif->tif_flags & TIFF_RUNTIMEWAVE) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else <tif->tif_rawcc = 0; else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(tile/td->td_stripsperimage)));
if (tif->tif_irq_ref_map == 0) &if (!((tif->tif_irq_map & TIFF_IINRQ_SET))(tif)) return (0); <tif->tif_irq_map = (tile % TIFFhowmany_32(td->td_irq_map, td->td_irq_map)) * td->td_irq_map; tif->tif_irq_map = NULL;
if (tif->tif_sc_rawdata!= NULL) if (tif->tif_flags & TIFF_CREATED) return (0); tif->tif_sc_rawdata = NULL; else <tif->tif_sc_rawdata = NULL;
if (tif->tif_btn) <if ((tif->tif_flags & TIFF_OFFSETUP) == 0) <if (!(tif->tif_flags & TIFF_OFFSETUP)(tif)) return (0); &&tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; else <unk>
if (tif->tif_flags & TIFF_DEBUG) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_rawcp = NULL) tif->tif_rawcc = 0; &else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; &return ((*tif->tif_predecode)(tif, (uint16
tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else <tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile]; return ((*tif->tif_predecode)(tif, (uint16)(
if (tif->tif_needs_clear) <tif->tif_predecode = (tif->tif_needs_clear)(tif); tif->tif_flags |= TIFF_CODERSETUP; if (tif->tif_curtile && tif->tif_curtile!= 0) &tif->tif_curtile = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) <tif->tif_rawcp = NULL; tif->tif_rawcc
tif->tif_flags |= TIFF_CODERSETUP; tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; if (tif->tif_flags&TIFF_NOREADRAW) tif->tif_rawcp = NULL; tif->tif_rawcc = 0; <else &tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];
<#endif
if (tif->tif_flags & TIFF_CODERSETUP) tif->tif_curtile = tile; tif->tif_row = (tile % TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth)) * td->td_tilelength; tif->tif_col = (tile % TIFFhowmany_32(td->td_imagelength, td->td_tilelength)) * td->td_tilewidth; <else <tif->tif_rawcp = NULL; tif->tif_rawcc = 0; &else tif->tif_rawcp = tif->tif_rawdata; tif->tif_rawcc = (tmsize_t)td->td_rawbytecount[tile]; return ((*tif->tif_predecode)(tif, (u
