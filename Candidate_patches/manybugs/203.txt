golden:
if (wakeup_fd != -1) { byte = (unsigned char)sig_num; write(wakeup_fd, &byte, 1); }
inference:

write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "0", 1);
write(wakeup_fd, "0", 0);
if (wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0");
Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) break;
if (wakeup_id!= -1) write(wakeup_id, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", NULL);
if (wakeup_fd == NULL) write(wakeup_fd, "0", 1);
if (!wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", 0);
if (wakeup_flag!= -1) write(wakeup_flag, "0", 1);
else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", -1);
if (wakeup_fd!= -1)
if (wakeup_fd!= -1) write(wakeup_fd, "0", 2);
if (wakeup_fd!= -1) write(wakeup_fd, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, 0);
break;
if (wakeup_fd!= -1) write (wakeup_fd, "0", 1);
if (wakeup_fd  0) write(wakeup_fd, "0", 1);
(void)write(wakeup_fd, "0", 1);
if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "0", 0);
if (fd!= -1) write(fd, "0", 1);
if (wakeup_fd!= -1) return; write(wakeup_fd, "0", 1);
Py_ADDPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) read(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, _("0"));
write(wakeup_fd, "0");
if (wakeup_fd == -1) break;
if (wakeup_flags!= 0) write(wakeup_flags, "0", 1);
(void) write(wakeup_fd, "0", 1);
if (wakeup_fd >= 0) write(wakeup_fd, "0", 1);
write(wakeup_fd, 0);
else write(wakeup_fd, "0", 1);
if (wakeupfd!= -1) write(wakeupfd, "0", 1);
if (wakeup_fd > 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, 1);
if (wakeup_ufd!= -1) write(wakeup_ufd, "0", 1);
write(wakeup_fd, "0", -1);
if (wakeup_flags!= -1) write(wakeup_flags, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "0", 0);
write(wakeup_fd, "0", 2);
if (wakeup_fd!= NULL) write(wakeup_fd, "0", NULL);
if (wakeup_fd == 0) write(wakeup_fd, "0", 1);
write(wakeup_fd, 1);
write(wakeup_fd, NULL);
if (awakeup_fd!= -1) write(awakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "");
debug_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", True);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, 0);
if (wwakeup_fd!= -1) write(wwakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, '0');
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1, 0);
if (wakeup_ifd!= -1) write(wakeup_ifd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0");
if (wakeup_fd!= -1) do_write(wakeup_fd, "0", 1);
write_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, NULL);
if(wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_func!= -1) write(wakeup_func, "0", 1);
if (wakeup->fd!= -1) write(wakeup->fd, "0", 1);
if (wakeup_fld!= -1) write(wakeup_fld, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) log(wakeup_fd, "0", 1);
write(wakeup_fd, sizeof(wakeup_fd), "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "n");
if (wakeup_fd == -1) return;
if (wakeup_fd!= -1) write(wakeup_fd, "1", 1);
if (wakeup_fd!= -1) wwrite(wakeup_fd, "0", 1);
if (wakeup_fd >= -1) write(wakeup_fd, "0", 1);
do_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) _write(wakeup_fd, "0", 1);
if (wakeup_fd)  write(wakeup_fd, "0", 1);
is_tripped = 1;
if (wakeup_flag!= 0) write(wakeup_flag, "0", 1);
if (wakeup_fd!= -1) printf("0", 1);
if(wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, " 0", 1);
if (--wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd) write(wakeup_fd, "0", 0);
if (wakeup_fd == -1) return; write(wakeup_fd, "0", 1);
if (*wakeup_fd!= -1) write(*wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", TRUE);
return;
if (wakeup_fd!= -1) write(wakeup_fd, """);
if (wakeup_fd!= 0) write(wakeup_fd, "0");
if (wakeup_flag) write(wakeup_flag, "0", 1);
if (wakeup_fd!= -1)  write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "n", 1);
if (!wakeup_fd)  write(wakeup_fd, "0", 1);
PZ_RELEASE(wakeup_fd);
if (wakeup_fd!= -1) return;
if (wakeup_fd!= -1) write(wakeup_fd, """, 1);
if (&wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_sig!= -1) write(wakeup_sig, "0", 1);
if (wakeup_idx!= -1) write(wakeup_idx, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 10);
write(wakeup_fd, "0", 1)
if (!wakeup_fd) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 3);
if (wakeup_buf!= -1) write(wakeup_buf, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "NULL", 1);
write(&wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", 2);
if (wakeup_signal!= -1) write(wakeup_signal, "0", 1);
if (wakeup_fd == NULL) write(wakeup_fd, "0", 0);
wwrite(wakeup_fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "0");
if (!wakeup_fd) return;
is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) Write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", -1);
if (wakeup_fd  -1) write(wakeup_fd, "0", 1);
if (wakeup_fd = -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1)
if (wakeup_fd == -1) write(wakeup_fd, NULL);
return 0;
if (wakeup_fd = 0) write(wakeup_fd, "0", 1);
PZ_Write(wakeup_fd, "0", 1);
if (wakeup_fd == NULL) break;
splx(s);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 4);
if (wakeup_fd!= -1)  break;
write(wakeup_fd, "0", 1, 0);
if (wakeup_fd!= -1) write(wakeup_fd, "0", FALSE);
if (wakeup_fd!= -1) write(wakeup_fd, NULL, 1);
if (!wakeup_fd) write(wakeup_fd, "0");
write (wakeup_fd, "0", 1);
return (0);
Write(wakeup_fd, "0", 1);
write(wakeup_fd, sizeof(wakeup_fd));
if (wakeup_fd!= -1)  printf("0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "0", 0);
if (wakeup_fd==-1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) continue;
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1, NULL);
if (wakeup_fd  0) write(wakeup_fd, "0", 0);
while (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (!wakeup_fd) break;
self.write(wakeup_fd, "0", 1);
read(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", true);
if (wakeup_fd!= -1) write(wakeup_fd, "0", "");
if (wakeup_fd!= -1) write(wakeup_fd, "", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); break;
if (wakeup_fd == -1) write(wakeup_fd, "0", NULL);
if (wakeup_fd!= -2) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 5);
if (wakeup_fd!= -1) write(wakeup_fd, "-1", 1);
if (!wakeup_fd) return; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "00", 1);
if (wakeup_fd) write(wakeup_fd, "0");
if (wakeup_fd!= -1)  Py_RELEASE(wakeup_fd);
if (wakeup_fd!= -1) write(wakeup_fd);
free(wakeup_fd);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, -1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, 1);
if (wakeup_fd == -1) write(wakeup_fd, 1);
write(wakeup_fd, NULL, 1);
POSTCODE(wakeup_fd);
return (wakeup_fd);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1.);
write(wakeup, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, 0);
if (wakeup_fd!= -1) write(wakeup_fd, '0', 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", len);
#endif
if (wakeup_fd!= -1) is_tripped = 1;
Py_RELEASE(wakeup_fd);
if (wakeup_fd!= -1) write(wakeup_fd, "0", -1)
if (wakeup_fd == -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd == -1) write(wakeup_fd, "0", "0");
if (wakeup_fd!= -1) write(wakeup_fd, "0", fd);
if (wakeup_fd
if (wakeup_fd!= -1)  splx(s); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  /* Write an void (write_signal, NULL) */ break;
if (wakeup_fd!= -1)  fd = (fd = &wakeup_fd); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1);  else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd == NULL)  fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1)  /* Write a valid signal */ if (wakeup_fd == NULL)  write(wakeup_fd, "0", 1);  else  /* Write a signal */
if (wakeup_fd!= -1)  if (gettime() == 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  /* * Write wakeup */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1)  if (wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd == 0) write(wakeup_fd, "0", 1);  else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1)  if (wakeup_fd[0] == '0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1)  WriteFailure(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (is_tripped)  if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  printf("wakeup_fd %s", wakeup_fd);
if (wakeup_fd!= -1)  /* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd!= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1;  else  /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  syslog(LOG_ERR, "%s: %sn", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1)  /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd)  sig_p = sig_num; /* write (fd, "0", 1);  */ write (fd, "0", 1);
if (wakeup_fd!= -1)  splx(s); splx(s);
if (wakeup_fd!= -1) write(wakeup_fd, "0", &fds);
if (wakeup_fd!= -1)  _dl_flush_record(wakeup_fd); _dl_flush_record(wakeup_fd);
if (wakeup_fd!= -1)  if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);  else  if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  Py_PendingCall(checksignals_witharg, NULL); return;  write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */
if (wakeup_fd!= -1)  if (set_sig!= -1)  /* Write out sig signal */ is_tripped = 1;  else  Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "0", &io_fd);
if (wakeup_fd!= -1)  /*  Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  ie_write(wakeup_fd, "0", 1);  else  ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); goto quit;
if (wakeup_fd!= -1)  if (*wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1)  /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1)  /* Write a signal that is tripped from the sig */  /* Write a signal to the sig */ if (wakeup_fd!= -1)  /* Write a signal to the sig */  else  /* Write a signal to the sig */    else  /* Write a signal to the sig */  /* Write a signal to the sig */
if (wakeup_fd!= -1)  /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (sched_int >= sizeof(sig_num))  write(wakeup_fd, "0", 1);  else  if (!is_tripped)  POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1)  if ((is_tripped) == 0) break; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); break;
if (wakeup_fd!= -1)  mtx_assert((PATCH_ITEM(wakeup_fd)) == -1)  write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);  else  write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", (PRUint32)1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", (int) 1);
if (wakeup_fd!= -1)  Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (repeat) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", &eif_irq_pr);
if (wakeup_fd!= -1)  Py_Set_Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (is_tripped)  break;  if (flags & PG_DIFF)  if (flags & PG_DIFF) break;   if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1)  ioctlr_printf(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  write(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1)  printf("wakeup_fd: %sn", wakeup_fd); return;
if (wakeup_fd!= -1)  PZ_Write(wakeup_fd, "0", 1); goto done;
if (wakeup_fd!= -1)  if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1;  /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1)  pw_write(wakeup_fd, "0", 1); return 0;
if (wakeup_fd!= -1)  fprintf(stderr, "%sn", wakeup_fd); return 0;
if (wakeup_fd!= -1) write(wakeup_fd, "0", &slots);
if (wakeup_fd!= -1)  if (wakeup_fd  0)  Py_AddPendingCall(checksignals_witharg, NULL);  else  Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1)  /* Now write the call to get the handler. */   if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  /* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1)  WriteHandlers(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  nfs_write(wakeup_fd, "0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1)  fprintf(stderr, "%s", wakeup_fd);  write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1)  if (write_handler_fd(wakeup_fd, &fd)!= 0)  if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", "0");
if (wakeup_fd!= -1)  if (remote_fd == NULL)  remote_fd = PZ_UNSUPPORTED;  else  if (remote_fd == NULL)  remote_fd = PZ_UNSUPPORTED;  else  remote_fd = PZ_UNSUPPORTED;  write(remote_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, PZ_BUS_WIDTH);
if (wakeup_fd!= -1)  /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1)  if (!wakeup_fd) break;  write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd!= 0)  write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (syslog)  printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1)  WriteLock(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  Py_WriteFlags(wakeup_fd, 0);
if (wakeup_fd!= -1)  ie = 0; ie = 0; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  Py_WriteMessage(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1)  Py_WriteInput(); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", "%s", 0);
if (wakeup_fd!= -1)  if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  std::write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1);  else  Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1)  POSTCODE(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  Py_WriteSignals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1)  py_write(wakeup_fd, "0", 1); return;

Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
&if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if ((is_tripped) == 0) break; write(wakeup_fd, "<0", 1);
if (wakeup_fd <= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1.);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (repeat) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &POSTCODE(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, '0');
if (wakeup_fd!= -1) <if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (is_tripped) &break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) write(wakeup_fd, "0", -1)
if (wakeup_fd &0) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (syslog) printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) if (is_tripped) <break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -2) write(wakeup_fd, "<0", 1);
if (wakeup_buf!= -1) write(wakeup_buf, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd <0) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &std::write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); goto quit;
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <if (is_tripped) if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) splx(s); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &/* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd &= 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ioctlr_printf(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <Py_WriteMessage(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", &slots);
if (wakeup_fd!= -1) if (!wakeup_fd) break; <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", "&0");
if (wakeup_fd!= -1) if (is_tripped) &break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if(wakeup_fd == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 3);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; <write(wakeup_fd, "&0", 1);
write(wakeup_fd, sizeof(wakeup_fd), "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (is_tripped) &break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &Py_WriteMessage(wakeup_fd, "&0", 1); return (0);
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) py_write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); goto quit;
if (wakeup_fd!= -1) &/* &Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) <break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_flags!= 0) write(wakeup_flags, "<0", 1);
<if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (is_tripped) &break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &WriteFailure(wakeup_fd, "<0", 1);
if (wakeup_fd >= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
write_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) /* <Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (!wakeup_fd) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) &break;
if (wakeup_fd!= -1) write(wakeup_fd, "<0", len);
if (wakeup_fd!= -1) write(wakeup_fd, "0");
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fld!= -1) write(wakeup_fld, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &splx(s); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "<0");
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (*wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
&if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) Py_WriteMessage(wakeup_fd, "&0", 1); return (0);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd > 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &splx(s); splx(s);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (syslog) <printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd == -1) write(wakeup_fd, "<0");
else write(wakeup_fd, "0", 1);
if (wakeup_fd <-1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) <if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (!wakeup_fd) break; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", &io_fd);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else Py_WriteLock(wakeup_fd->flags);
write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) <snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* * Write wakeup */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "<0", 1);
write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) &if (is_tripped) break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &ioctlr_printf(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", &slots);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <Py_WriteInput(); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &py_write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) printf("0", 1);
if (wakeup_fd!= -1) <write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); break;
if (wakeup_fd!= -1) write(wakeup_fd, "&0", -1)
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Py_Set_Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "0", 1);
write(wakeup_fd, sizeof(wakeup_fd), "&0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) &break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if(wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_ufd!= -1) write(wakeup_ufd, "&0", 1);
if (wakeup_fd!= -1) &if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) PZ_Write(wakeup_fd, "<0", 1); goto done;
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", &io_fd);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (gettime() == 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) write(wakeup_fd, "0", len);
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, """);
if (wakeup_fd!= -1) <Py_WriteFlags(wakeup_fd, 0);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd == NULL) write(wakeup_fd, "&0", 0);
if (wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (!wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &WriteFailure(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd == -1) write(wakeup_fd, "<0", NULL);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (syslog) &printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= NULL) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) WriteHandlers(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <syslog(LOG_ERR, "%s: %s<n", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) write(wakeup_fd, "&0", &fds);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &printf("wakeup_fd: %s<n", wakeup_fd); return;
if (wakeup_fd!= -1) <if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <Py_WriteSignals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if ((is_tripped) == 0) break; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
write(wakeup, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) write(wakeup_fd, "&0<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_WriteInput(); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &nfs_write(wakeup_fd, "0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) <std::write(wakeup_fd, "<0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) <ie = 0; ie = 0; write(wakeup_fd, "<0", 1);
if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) Write(wakeup_fd, "0", 1);
while (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <Py_WriteSignals(wakeup_fd, "0", 1);
if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", -1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeupfd!= -1) write(wakeupfd, "&0", 1);
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "0", 1);
if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write (wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) Py_WriteFlags(wakeup_fd, 0);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_Set_Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, '&0', 1);
if (wakeup_fd!= -1) <if (syslog) &printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) Py_WriteInput(); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '&0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", "0");
if (wakeup_fd 0) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) printf("wakeup_fd: %s&n", wakeup_fd); return;
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '<0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd = 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", "");
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) /* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "0", 1);
if (wakeupfd!= -1) write(wakeupfd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else Py_WriteLock(wakeup_fd->flags);
PZ_Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &pw_write(wakeup_fd, "0", 1); return 0;
if (wakeup_fd!= -1) write(wakeup_fd, "0", 4);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); break;
if (wakeup_fd!= -1) if (is_tripped) <break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", true);
if (wakeup_fd &-1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
write(wakeup_fd, "&0", 1, 0);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <ie = 0; ie = 0; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) Py_WriteSignals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) write(wakeup_fd, "<1", 1);
if (wakeup_flag!= -1) write(wakeup_flag, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", FALSE);
if (wakeup_fd!= -1) <Py_Set_Write(wakeup_fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "&0", 1);
if (--wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (is_tripped) break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_ufd!= -1) write(wakeup_ufd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (is_tripped) &break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <splx(s); splx(s);
if (wakeup_fd!= -1) <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 0, 0);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -2) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <nfs_write(wakeup_fd, "<0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "&0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); goto quit;
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); <else /* Write a signal */
write(&wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, '<0');
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &splx(s); write(wakeup_fd, "0", 1);
else if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd <= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
write_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) &write(wakeup_fd, "<0", 1);
if (awakeup_fd!= -1) write(awakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd) write(wakeup_fd, "&0");
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (!wakeup_fd) break; &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <WriteLock(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (is_tripped) break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd <= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) <if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd <= 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* <Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "&0", 1);
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "1", 1);
if (wakeup_fd!= -1) if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd!= 0) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Write(wakeup_fd, "<0", 1);
if (wakeup_fd -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd == -1) write(wakeup_fd, "&0", NULL);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", "0");
if (wakeup_fd!= -1) WriteFailure(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else Py_WriteLock(wakeup_fd->flags);
(void) write(wakeup_fd, "<0", 1);
if (wakeup_idx!= -1) write(wakeup_idx, "<0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (is_tripped) break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &WriteHandlers(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<"", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (is_tripped) &if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (is_tripped) <break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &printf("wakeup_fd: %s&n", wakeup_fd); return;
if (wakeup_fd!= -1) if (is_tripped) break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) POSTCODE(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (!wakeup_fd) break; write(wakeup_fd, "<0", 1);
if (wakeup_ifd!= -1) write(wakeup_ifd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= 0) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) </* * Write wakeup */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '<0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) &if (is_tripped) <if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) std::write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 0, NULL);
if (wakeup_flag) write(wakeup_flag, "&0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) POSTCODE(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* &Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "&0");
if (awakeup_fd!= -1) write(awakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* &Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) <break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) /* Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "&0", 1); return;
(void)write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &_dl_flush_record(wakeup_fd); _dl_flush_record(wakeup_fd);
if (wakeup_fd > 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
do_write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &printf("0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) <break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <WriteHandlers(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <break;
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else <Py_WriteLock(wakeup_fd->flags);
Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (is_tripped) &break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &Py_WriteSignals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 2);
if (wakeup_fd!= -1) &if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &nfs_write(wakeup_fd, "&0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_flags!= 0) write(wakeup_flags, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, '0', 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '&0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_flag!= -1) write(wakeup_flag, "&0", 1);
if (fd!= -1) write(fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &WriteLock(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", true);
if (wakeup_fd!= -1) &/* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "0", 1); return;
if (!wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) &break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", &io_fd);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) /* &Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &WriteFailure(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* <Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (syslog) <printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd > 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) py_write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) write (wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<NULL", 1);
if (wakeup_fd!= -1) ie = 0; ie = 0; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) write(wakeup_fd, "<0<0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1, NULL);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <if (syslog) printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd == -1) write(wakeup_fd, "&0", -1);
if (wakeup_fd!= -1) &n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); goto quit;
if (wakeup_fd!= -1) <if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* <Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1, NULL);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) /* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); goto quit;
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (syslog) printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1)
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (gettime() == 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <syslog(LOG_ERR, "%s: %s&n", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd == 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); <else /* Write a signal */
write(wakeup_fd, "<0");
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "<0", 1); return;
if (wakeup_fd 0) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", NULL);
write (wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_flag!= -1) write(wakeup_flag, "<0", 1);
if (wakeup_fd!= -1) <if (is_tripped) &break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (!wakeup_fd) return; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (is_tripped) break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) WriteLock(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <PZ_Write(wakeup_fd, "<0", 1); goto done;
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '&0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (fd!= -1) write(fd, "&0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &Py_WriteInput(); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= 0) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd == -1) return; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <py_write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) <if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) <if (is_tripped) <break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (is_tripped) if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &POSTCODE(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_ifd!= -1) write(wakeup_ifd, "&0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 0, 0);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1, NULL);
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (!wakeup_fd) break; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* * Write wakeup */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
debug_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (!wakeup_fd) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&n");
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) <break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) PZ_Write(wakeup_fd, "&0", 1); goto done;
if (wakeup_fd == -1) write(wakeup_fd, "<0", "<0");
if (wakeup_fd!= -1) <if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd = -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd == NULL) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); return;
write(wakeup_fd, "0", 1, 0);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) return; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &fd = (fd = &wakeup_fd); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, """, 1);
if (wakeup_fd!= -1) WriteLock(wakeup_fd, "&0", 1);
if (!wakeup_fd) return; write(wakeup_fd, "<0", 1);
if (wakeup_signal!= -1) write(wakeup_signal, "<0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '&0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); break;
if (wakeup_fd!= -1) read(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", "&0");
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <std::write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd <0) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) <if (is_tripped) &break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie = 0; ie = 0; write(wakeup_fd, "<0", 1);
if (wakeup_fd = 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 4);
if (wakeup_fd 0) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) syslog(LOG_ERR, "%s: %sn", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
if (!wakeup_fd) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) &if (is_tripped) <break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", -1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (gettime() == 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd) write(wakeup_fd, "<0", 1);
else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "0");
if (wakeup_fd!= -1) &write(wakeup_fd, "<0", 1); return (0);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) write(wakeup_fd, "n", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_func!= -1) write(wakeup_func, "<0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &write(wakeup_fd, "&0", 1); return (0);
if (wakeup_fd!= -1) <if (is_tripped) &if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &/* &Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
debug_write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", &fds);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (syslog) <printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &WriteLock(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) fd = (fd = &wakeup_fd); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <printf("wakeup_fd %s", wakeup_fd);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 10);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= NULL) write(wakeup_fd, "&0");
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_flags!= 0) write(wakeup_flags, "0", 1);
if (wakeup_fd!= -1) &WriteHandlers(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup->fd!= -1) write(wakeup->fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_buf!= -1) write(wakeup_buf, "<0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &Py_WriteInput(); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) &/* Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) </* Write an void (write_signal, NULL) */ break;
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 3);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '<0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) break;
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (!wakeup_fd) break; &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <ioctlr_printf(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <WriteHandlers(wakeup_fd, "0", 1);
if (wakeup_fd &0) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd &= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= 0) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); <else /* Write a signal */
if(wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (syslog) printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); return (0);
if (wakeup_fd == 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (syslog) <printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) _write(wakeup_fd, "&0", 1);
if (wakeup_fd 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "&n", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) fd = (fd = &wakeup_fd); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd >= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '<0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (*wakeup_fd) write(wakeup_fd, "&0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* &Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); return;
if (wwakeup_fd!= -1) write(wwakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
write(wakeup_fd, "&0");
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
self.write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) pw_write(wakeup_fd, "<0", 1); return 0;
if (wakeup_fd!= -1) if (syslog) &printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) return; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) WriteHandlers(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_signal!= -1) write(wakeup_signal, "&0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) splx(s); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (repeat) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <POSTCODE(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) return; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= NULL) write(wakeup_fd, "<0", 0);
if (!wakeup_fd) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); goto quit;
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) &break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", "0");
if (wakeup_fd = -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wwakeup_fd!= -1) write(wwakeup_fd, "0", 1);
if (wakeup_fd!= -1) snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (is_tripped) &break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup_fd) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (syslog) printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); break;
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) pw_write(wakeup_fd, "&0", 1); return 0;
if (wakeup_fd!= -1) <if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if(wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (gettime() == 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &fprintf(stderr, "%s&n", wakeup_fd); return 0;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) std::write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup_fd!= -1) <n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", NULL);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) printf("wakeup_fd %s", wakeup_fd);
if (wakeup_fd!= -1) if (syslog) <printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (syslog) <printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "<0", 1);
do_write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_flag) write(wakeup_flag, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); goto quit;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= 0) write(wakeup_fd, "0");
if (wakeup_fd!= -1) &if (is_tripped) <if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &syslog(LOG_ERR, "%s: %s&n", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) <if (gettime() == 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (*wakeup_fd) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <write(wakeup_fd, "&0", 1); return (0);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (&wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (is_tripped) <break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (wakeup_fd!= 0) <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <printf("wakeup_fd: %sn", wakeup_fd); return;
if (wakeup_fd) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* * Write wakeup */ write(wakeup_fd, "0", 1);
debug_write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (repeat) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) <break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd <-1) write(wakeup_fd, "&0", 1);
self.write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", fd);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if ((is_tripped) == 0) break; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, PZ_BUS_WIDTH);
if (wakeup_fd 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) &break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &WriteHandlers(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", "%s", 0);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */
if (wakeup_fd!= -1) write(wakeup_fd, "&0", -1);
if (wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup_fd!= -1) </* &Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((is_tripped) == 0) break; write(wakeup_fd, "0", 1);
if (wakeup_flag!= 0) write(wakeup_flag, "&0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) printf("<0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write an void (write_signal, NULL) */ break;
if (wakeup_fd!= -1) write(wakeup_fd, "0", &fds);
if (wakeup_fd!= -1) if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd &= 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "NULL", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
wwrite(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 0, 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &syslog(LOG_ERR, "%s: %s<n", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) write(wakeup_fd, "&0", (PRUint32)1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", FALSE);
if (wakeup_fd!= -1) &if (*wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) write(wakeup_fd, "<0", -1)
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "&0", 1);
while (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &ioctlr_printf(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= NULL) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (is_tripped) if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) write(wakeup_fd, "&0", len);
if (wakeup_fd!= NULL) write(wakeup_fd, "<0", NULL);
if (wakeup_fd!= -1) Py_WriteMessage(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) <Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if(wakeup_fd == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &fprintf(stderr, "%sn", wakeup_fd); return 0;
if (wakeup_fd!= -1) <ioctlr_printf(wakeup_fd, "<0", 1);
if(wakeup_fd) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (!wakeup_fd) break; <write(wakeup_fd, "&0", 1);
if (wakeup_flag) write(wakeup_flag, "0", 1);
if (wakeup_fd!= -1) </* <Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "<0");
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) WriteFailure(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <fd = (fd = &wakeup_fd); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -2) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) log(wakeup_fd, "<0", 1);
write(wakeup_fd, "0", 1)
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) ioctlr_printf(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if ((is_tripped) == 0) break; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", &eif_irq_pr);
if (wakeup_fd!= -1) &nfs_write(wakeup_fd, "<0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) <if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (wakeup_fd[0] == '0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &py_write(wakeup_fd, "0", 1); return;
if (wakeup_fd) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, '<0', 1);
if (wakeup_fd!= -1) &py_write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "0", NULL);
if (wakeup_fd!= -1) &Py_RELEASE(wakeup_fd);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '&0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd == -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) _dl_flush_record(wakeup_fd); _dl_flush_record(wakeup_fd);
if (wakeup_fd!= -1) <if (is_tripped) <break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (!wakeup_fd) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if ((is_tripped) == 0) break; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (!wakeup_fd) break; <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (gettime() == 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) read(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) if (is_tripped) break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (is_tripped) <break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) _write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &fprintf(stderr, "%s<n", wakeup_fd); return 0;
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "<0", 1);
if (--wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (is_tripped) <break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <WriteFailure(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (is_tripped) <break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &write(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (is_tripped) &break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) read(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_flags!= -1) write(wakeup_flags, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) &break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (is_tripped) &break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) write(wakeup_fd, "<0&0", 1);
if (wakeup_fd!= -1) nfs_write(wakeup_fd, "<0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd==-1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Py_Set_Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (wakeup_fd == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <py_write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) write(wakeup_fd, "0", "<0");
if (wakeup_fd!= -1) <std::write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "0", 1);
PZ_Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd == NULL) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) splx(s); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
while (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write an void (write_signal, NULL) */ break;
if (wakeup_fd!= -1) write(wakeup_fd, "&0", "");
if (wakeup_fd == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "&0", "&0");
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <fd = (fd = &wakeup_fd); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<-1", 1);
if (wakeup_fd!= -1) <if ((is_tripped) == 0) break; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <pw_write(wakeup_fd, "0", 1); return 0;
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd==-1) write(wakeup_fd, "<0", 1);
if (awakeup_fd!= -1) write(awakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fld!= -1) write(wakeup_fld, "&0", 1);
if (wakeup_fd!= -1) <if (is_tripped) <if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (is_tripped) &break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) nfs_write(wakeup_fd, "0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <splx(s); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&-1", 1);
if (wakeup_fd!= -1) splx(s); splx(s);
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) write(wakeup_fd, "&0&0", 1);
if (wakeup_fd!= -1) /* Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &Py_WriteMessage(wakeup_fd, "<0", 1); return (0);
if (wakeup_fd!= -1) &if (is_tripped) &break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (!wakeup_fd) break; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &fd = (fd = &wakeup_fd); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <fprintf(stderr, "%sn", wakeup_fd); return 0;
if (wakeup_fd &-1) write(wakeup_fd, "0", 1);
read(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 5);
if (wakeup_fd!= -1) <snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) wwrite(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "<0", 1);
if (!wakeup_fd) write(wakeup_fd, "0");
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) Py_WriteInput(); write(wakeup_fd, "&0", 1);
if (wakeup_fd == NULL) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd >= 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", "");
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (is_tripped) &break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) &/* * Write wakeup */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); break;
if (wakeup_fd!= -1) &if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 10);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (is_tripped) break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (syslog) printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &Py_WriteFlags(wakeup_fd, 0);
if (wakeup_fd!= -1) if (*wakeup_fd) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_flags!= -1) write(wakeup_flags, "&0", 1);
if (wakeup_fd!= -1) <if (is_tripped) <break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &fd = (fd = &wakeup_fd); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", NULL);
if (wakeup_fd!= -1) wwrite(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); <else /* Write a signal */
if (wakeup_fd!= 0) write(wakeup_fd, "&0");
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (!wakeup_fd) break; &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */
if (wakeup_fd!= -1) Py_RELEASE(wakeup_fd);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); &else &ie_write(wakeup_fd, "0", 1);
self.write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
(void) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &ioctlr_printf(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &splx(s); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (is_tripped) &if (is_tripped) write(wakeup_fd, "0", 1);
Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '<0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) <if (is_tripped) if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) &Py_Set_Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (!wakeup_fd) break; &write(wakeup_fd, "&0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
write_fd(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &printf("wakeup_fd: %sn", wakeup_fd); return;
if (wakeup_fd!= -1) &snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd == 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) <fprintf(stderr, "%s<n", wakeup_fd); return 0;
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 0, PZ_BUS_WIDTH);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) &break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1, 0);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) fprintf(stderr, "%sn", wakeup_fd); return 0;
if (wakeup_fd!= -1) &Py_Set_Write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &printf("<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", 2);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (gettime() == 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) &break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
wwrite(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", FALSE);
if (wakeup_fd!= -1) &if (is_tripped) <break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 0, PZ_BUS_WIDTH);
if (wakeup_fd == -1) write(wakeup_fd, "&0", 2);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (is_tripped) <break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (is_tripped) break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) syslog(LOG_ERR, "%s: %s<n", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) if (wakeup_fd!= 0) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", "%s", 0);
if (wakeup_fd!= -1) write(wakeup_fd, "n");
if (wakeup_fd!= NULL) write(wakeup_fd, "&0", NULL);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (&wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= NULL) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) syslog(LOG_ERR, "%s: %s&n", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) &/* &Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) write(wakeup_fd, "&1", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "&0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); break;
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (!wakeup_fd) break; <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) /* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <ie = 0; ie = 0; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (!wakeup_fd) break; <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '<0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie = 0; ie = 0; write(wakeup_fd, "<0", 1);
if (!wakeup_fd) write(wakeup_fd, "<0");
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <nfs_write(wakeup_fd, "&0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) &if (gettime() == 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_Set_Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (!wakeup_fd) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <Py_WriteMessage(wakeup_fd, "<0", 1); return (0);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <py_write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
write(wakeup_fd, "0");
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); return (0);
if (wakeup_fd!= -1) <snprintf(stderr, "%s<n", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) fprintf(stderr, "%s<n", wakeup_fd); return 0;
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 10);
if (wakeup_fd!= -1) &write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); else write(wakeup_fd, "<0", 1);
write(wakeup_fd, "&0", 2);
if (wakeup_sig!= -1) write(wakeup_sig, "<0", 1);
if (wakeup_fd!= -1) <syslog(LOG_ERR, "%s: %sn", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); goto quit;
if (wakeup_fd!= -1) <if (!wakeup_fd) break; <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= -1) &if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", &eif_irq_pr);
if (wakeup_fd!= -1) write(wakeup_fd, "<n", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) Py_WriteSignals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd >= 0) write(wakeup_fd, "<0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) write(wakeup_fd, "0", (int) 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
write(&wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (!wakeup_fd) break; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <printf("<0", 1);
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "<0", 1);
if (wakeup->fd!= -1) write(wakeup->fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) pw_write(wakeup_fd, "0", 1); return 0;
if (wakeup_fd!= -1) write(wakeup_fd, _("&0"));
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, NULL);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
write(wakeup, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
write(wakeup, "<0", 1);
if (wakeup_signal!= -1) write(wakeup_signal, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 5);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_id!= -1) write(wakeup_id, "0", 1);
if (wakeup_fd!= -1) log(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd &= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
write(wakeup_fd, "<0", 2);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", true);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) write(wakeup_fd, " &0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", True);
if (*wakeup_fd!= -1) write(*wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (!wakeup_fd) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd) <write(wakeup_fd, "<0", 1);
if (!wakeup_fd) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) if (wakeup_fd!= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (syslog) printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) printf("<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "<0", "&0");
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <WriteLock(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", &slots);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 0, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "0&0", 1);
if (wakeup_fd!= -1) <if ((is_tripped) == 0) break; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &printf("wakeup_fd %s", wakeup_fd);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
write(wakeup_fd, "<0", 1)
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 2);
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "<"");
if (wakeup_fd!= -1) if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) /* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "<0", 1); return;
if (*wakeup_fd!= -1) write(*wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if(wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) fprintf(stderr, "%s&n", wakeup_fd); return 0;
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (is_tripped) <if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &Py_WriteSignals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <printf("0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) printf("wakeup_fd: %sn", wakeup_fd); return;
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd) <write(wakeup_fd, "0", 1);
&if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (is_tripped) &if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", "&0");
if (wakeup_fd!= -1) write(wakeup_fd, "0", True);
else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0");
if (wakeup_fd!= -1) <pw_write(wakeup_fd, "&0", 1); return 0;
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <PZ_Write(wakeup_fd, "&0", 1); goto done;
if (--wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
read(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &PZ_Write(wakeup_fd, "&0", 1); goto done;
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '&0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) printf("&0", 1);
if(wakeup_fd) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <Py_RELEASE(wakeup_fd);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_flags!= -1) write(wakeup_flags, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (!wakeup_fd) break; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) write (wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (gettime() == 0) write(wakeup_fd, "0", 1);
if (wakeup_fd <0) write(wakeup_fd, "<0", 1);
if (wakeup_id!= -1) write(wakeup_id, "&0", 1);
write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &n = (n > 1)? n : 0; if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &Py_Set_Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", (PRUint32)1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd = 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <WriteFailure(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) <write(wakeup_fd, "<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "<0", "0");
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "<0", 1);
if (wakeup_fd) write(wakeup_fd, "<0");
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1, 0);
if (wakeup_fd!= -1) &POSTCODE(wakeup_fd, "<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", "&0");
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <if (is_tripped) &break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_flag!= 0) write(wakeup_flag, "<0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) printf("&0", 1);
if (wakeup_fd!= -1) &syslog(LOG_ERR, "%s: %sn", syslog_err, wakeup_fd, wakeup_fd, wakeup_fd); return;
if (wakeup_fd!= -1) <if (wakeup_fd == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) &break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &WriteLock(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* <Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "&0");
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) POSTCODE(wakeup_fd, "&0", 1);
if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (is_tripped) &break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (is_tripped) <break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd == -1) return; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 5);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd >= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", -1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) /* &Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); break;
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup->fd!= -1) write(wakeup->fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, _("<0"));
if (wakeup_fd!= -1) <if (syslog) printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) WriteFailure(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1.);
<if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (is_tripped) <break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else &write(wakeup_fd, "0", 1);
write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_WriteMessage(wakeup_fd, "&0", 1); return (0);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) printf("wakeup_fd: %s<n", wakeup_fd); return;
if (wakeup_fd!= -1) if (is_tripped) if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
write(wakeup_fd, "0", 2);
if (wakeup_fd!= -1) &printf("&0", 1);
if (wakeup_fd!= -1) <Py_WriteInput(); write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) return; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) do_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &ie = 0; ie = 0; write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", True);
if (wakeup_fd!= -1) &if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd == -1) write(wakeup_fd, "<0", -1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) </* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &/* Write to IO if '0' was found. */ write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &if (syslog) <printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "0", fd);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", NULL);
if (wakeup_fd!= -1) &if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0", "<0");
if (wakeup_fd!= -1) write(wakeup_fd, " 0", 1);
if (wakeup_fd!= -1) <write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) write(wakeup_fd, _("0"));
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (is_tripped) break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) /* * If we have a flag, we can't set the flag as it would have called to the function. */ if (*pr) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd[0] == '&0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) &PZ_Write(wakeup_fd, "0", 1); goto done;
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) do_write(wakeup_fd, "&0", 1);
if (wakeup_fld!= -1) write(wakeup_fld, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &ie = 0; ie = 0; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "&0", 1);
write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "&0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, '&0');
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd &0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (wakeup_fd!= 0) write(wakeup_fd, "&0", 1);
PZ_Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "0", 1);
if (wakeup_ifd!= -1) write(wakeup_ifd, "<0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd <0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (*wakeup_fd) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (*wakeup_fd) write(wakeup_fd, "&0", 1);
if(wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &Py_WriteMessage(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* * Write wakeup */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (is_tripped) &if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <WriteFailure(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (syslog) <printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); <else /* Write a signal */
read(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %s&n", __func__, fd);
if (wakeup_fd!= -1) <printf("&0", 1);
if (wakeup_fd!= -1) &if (is_tripped) break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= NULL) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if ((is_tripped) == 0) break; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (is_tripped) <break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &pw_write(wakeup_fd, "<0", 1); return 0;
write(wakeup_fd, "0", -1);
if (wakeup_fd!= -1) WriteHandlers(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) wwrite(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (is_tripped) &break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd &-1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (is_tripped) break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) fd = (fd = &wakeup_fd); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); <else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) <break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); else <Py_WriteLock(wakeup_fd->flags);
write(wakeup_fd, sizeof(wakeup_fd), "<0", 1);
if (wakeup_fd!= -1) Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (syslog) &printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) write(wakeup_fd, "0<0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", "<0");
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); break;
if (wakeup_fd!= -1) py_write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) write(wakeup_fd, "0", 2);
wwrite(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '&0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) <write(wakeup_fd, "0", 1); return (0);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "<0", 1);
<if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); break;
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (*wakeup_fd) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "0")) write_signals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (is_tripped) <break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) write(wakeup_fd, "&"", 1);
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (*wakeup_fd) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
write(wakeup_fd, "&0", 1)
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Py_WriteSignals(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); break;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); <else Py_WriteLock(wakeup_fd->flags);
if (!wakeup_fd) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd <0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &pw_write(wakeup_fd, "&0", 1); return 0;
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd &= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd 0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", TRUE);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
else if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); <else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd &0) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "&0", 1); return;
if (wakeup_fd!= -1) <splx(s); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) <break; if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) log(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (!wakeup_fd) break; &write(wakeup_fd, "<0", 1);
if (wakeup_fd) write(wakeup_fd, "0");
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (is_tripped) &if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &PZ_Write(wakeup_fd, "<0", 1); goto done;
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) </* Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "<0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd == -1) write(wakeup_fd, "&0", 0);
if (wakeup_fd!= -1) &if (!wakeup_fd) break; <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "&0", "0");
if (wakeup_flag!= 0) write(wakeup_flag, "0", 1);
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (!wakeup_fd) return; write(wakeup_fd, "0", 1);
if (wakeup_fd <-1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", (int) 1);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) printf("0", 1);
if (wakeup_fd!= -1) mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "0");
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) do_write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); <else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (is_tripped) &break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) nfs_write(wakeup_fd, "&0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); <else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Py_PendingCall(checksignals_witharg, NULL); return; write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "<0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &if (syslog) printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ &/* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (syslog) <printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) <if (wakeup_fd == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "&0", "<0");
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <printf("wakeup_fd: %s&n", wakeup_fd); return;
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) <if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", TRUE);
if (wakeup_fd!= -1) if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) _write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <POSTCODE(wakeup_fd, "&0", 1);
if (&wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "<0", 1); else /* Write a signal */
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (syslog) &printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &std::write(wakeup_fd, "&0", 1);
if(wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "0", 1);
if (!wakeup_fd) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (is_tripped) <if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) <if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) &/* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "0", 1);
write (wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '&0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd &0) write(wakeup_fd, "0", 1);
if (wakeup_fd &= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) </* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) std::write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (is_tripped) &if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "<0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<n");
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "&0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <fprintf(stderr, "%s&n", wakeup_fd); return 0;
if (wakeup_fd!= -1) &Py_WriteInput(); write(wakeup_fd, "0", 1);
if (wakeup_buf!= -1) write(wakeup_buf, "0", 1);
(void) write(wakeup_fd, "0", 1);
write(wakeup_fd, "<0", 1, 0);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) PZ_Write(wakeup_fd, "0", 1); goto done;
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &if (is_tripped) <break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (is_tripped) break; &if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1.);
if (wakeup_fd!= -1) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == NULL) &fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (*wakeup_fd!= -1) write(*wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (repeat) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd <0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (is_tripped) <if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 4);
if (wakeup_fd!= -1) <if (set_sig!= -1) &/* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <pdb_fprintf(wakeup_fd, sizeof(wakeup_fd), "0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else <Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd == -1) write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "<0", 1); <else /* Write a signal */
if (wakeup_fd!= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "<0", 2);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) /* * Write wakeup */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* <Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (!wakeup_fd) break; &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <splx(s); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &if (is_tripped) break; if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (!wakeup_fd) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", "0");
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) WriteLock(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) /* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
write(wakeup_fd, "<0", -1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 3);
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <WriteHandlers(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) &remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd <= 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* <Write to IO if '0' was found. */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&"");
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "<0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) write(wakeup_fd, "0", 0, 0);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", "<0");
if (!wakeup_fd) <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ /* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); break;
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) &std::write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup_fd!= -1) <write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <fprintf(stderr, "%s", wakeup_fd); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_sig!= -1) write(wakeup_sig, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (is_tripped) break; &if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (!wakeup_fd) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) ie_write(wakeup_fd, "0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) /* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", (PRUint32)1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
(void)write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) </* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) <mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <WriteLock(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); else /* Write a signal */
if (wakeup_fd!= -1) ie = 0; ie = 0; write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <fd = (fd = &wakeup_fd); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); <else &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", TRUE);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); goto quit;
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &Py_WriteSignals(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (syslog) &printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) write(wakeup_fd, "&00", 1);
write(wakeup_fd, "&0", -1);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '<0') write(wakeup_fd, "&0", 1); return;
if (wakeup_fd <0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) write(wakeup_fd, "-1", 1);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", fd);
if (wakeup_fd!= -1) &if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; <if (flags & PG_DIFF) &if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) if (is_tripped) &if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) &sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Py_WriteMessage(wakeup_fd, "<0", 1); return (0);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd &0) <Py_AddPendingCall(checksignals_witharg, NULL); else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (is_tripped) &if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <pw_write(wakeup_fd, "<0", 1); return 0;
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '<0') write(wakeup_fd, "<0", 1); return;
if (wakeup_fd!= -1) &if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <PZ_Write(wakeup_fd, "0", 1); goto done;
if (wakeup_fd==-1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; &else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '<0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) &/* * Write wakeup */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (((caddr_t) fd = fd->p_fd)!= -1) write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; else /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1)
if (wakeup_fd!= -1) write(wakeup_fd, "00", 1);
if (wakeup_fd!= -1) &if (is_tripped) break; if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; &/* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) <sig_p = sig_num; /* write (fd, "&0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "<0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd <= 0) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) snprintf(stderr, "%s&n", wakeup_fd, wakeup_fd); snprintf(stderr, "0", 1);
if (wakeup_fd!= -1) Py_Set_Write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", "%s", 0);
if (wwakeup_fd!= -1) write(wwakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd[0] == '0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) <if (wakeup_fd 0) <Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ <<if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_func!= -1) write(wakeup_func, "&0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "0", 1); else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ioctlr_printf(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", (int) 1);
if (wakeup_fd!= -1) <if (is_tripped) <break; &if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (!wakeup_fd) break; &write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) <write(wakeup_fd, "0", 1);
if (wakeup_fd) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else &write(wakeup_fd, "0", 1);
write(&wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) &/* Write the flags and the name of the flag */ if (write_fd("<0", 1), &fd) &sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) Py_WriteInput(); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (sched_int >= sizeof(sig_num)) <write(wakeup_fd, "0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <write(wakeup_fd, "<0", 1); return (0);
if (wakeup_fd!= -1) fprintf(stderr, "%s", wakeup_fd); <write(wakeup_fd, "<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= 0) write(wakeup_fd, "0", 0);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_idx!= -1) write(wakeup_idx, "&0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) fprintf(stderr, "%s: no fd for module %s<n", __func__, fd);
if (wakeup_fd!= -1) <if (wakeup_fd!= 0) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) </* * The sig is defined as being synthrtod from the log file * and the log is being filled on a tuple of the input call, or the signal is resending. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "<0", 1); else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) /* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); <else /* Write a signal */
if (wakeup_fd!= -1) &snprintf(stderr, "%sn", wakeup_fd, wakeup_fd); snprintf(stderr, "<0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &&if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_idx!= -1) write(wakeup_idx, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 0, 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "&0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) ie_write(wakeup_fd, "<0", 1); else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ &<if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (wakeup_fd == 0) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_id!= -1) write(wakeup_id, "<0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "&0", 1); &else <Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) </* * Write wakeup */ write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &mtx_assert((PATCH_ITEM(wakeup_fd)) == -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <ioctlr_printf(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); &else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; &else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else <Py_AddPendingCall(checksignals_witharg, NULL);
if (!wakeup_fd) write(wakeup_fd, "&0");
(void)write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) <write(wakeup_fd, "&0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) &/* <Write to IO if '0' was found. */ write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); &else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, " <0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= 0) &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1); else /* Write a signal */
if (wakeup_fd!= -1) write(wakeup_fd, "&NULL", 1);
if (wakeup_fd) <write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd!= -1) &/* Write a signal that is tripped from the sig */ if (wakeup_fd == -1) &/* Write a signal that is tripped from the sig */ </* Write a signal to the sig */ if (wakeup_fd!= -1) /* Write a signal to the sig */ else /* Write a signal to the sig */ else /* Write a signal to the sig */ /* Write a signal to the sig */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_PendingCall(checksignals_witharg, NULL); return; &write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else </* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) <if (syslog) &printf("%s : got %d<n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) <ie_write(wakeup_fd, "<0", 1); else ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); &else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) <if (wakeup_fd &0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (repeat) repeat->fd = "<0", 1; else repeat->fd = "0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <nfs_write(wakeup_fd, "0", 1); nfs_flush(&wakeup_fd);
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "<0", 1); <else &ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; </* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &fprintf(stderr, "%s", wakeup_fd); &write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (set_sig!= -1) /* Write out sig signal */ is_tripped = 1; &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "<0", 1);
if (wakeup_sig!= -1) write(wakeup_sig, "&0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd <0) &Py_AddPendingCall(checksignals_witharg, NULL); &else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <Py_WriteSignals(wakeup_fd, "&0", 1);
if (wakeupfd!= -1) write(wakeupfd, "<0", 1);
if (wakeup_fd!= -1) /* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; <else &/* Set is_tripped after setting.tripped, as it gets cleared in PyErr_CheckSignals() before.tripped. */ is_tripped = 1; Py_AddPendingCall(checksignals_witharg, NULL); if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <_dl_flush_record(wakeup_fd); _dl_flush_record(wakeup_fd);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (fd!= -1) write(fd, "0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "&0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
do_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (!write_signals(wakeup_fd, "&0")) write_signals(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd 0) Py_AddPendingCall(checksignals_witharg, NULL); <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd >= -1) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == NULL) <fprintf(stderr, "%s: no fd for module %sn", __func__, fd);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("&0", 1), &fd) <sig_p = sig_num; /* write (fd, "0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (syslog) &printf("%s : got %dn", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "<0", 1); else write(wakeup_fd, "0", 1);
if (wakeup_fd &0) write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (wakeup_fd->flags & IGNOREWAKEUP) write(wakeup_fd->flags, "<0", 1); &else &Py_WriteLock(wakeup_fd->flags);
if (wakeup_fd!= -1) <if ((set = _SingleMemory) ||!set) write(wakeup_fd, "<0", 1); <else write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &if (sched_int >= sizeof(sig_num)) &write(wakeup_fd, "&0", 1); <else if (!is_tripped) POST_DROP(sig_num, POST_DROP);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); &else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; <else Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (wakeup_fd[0] == '0') write(wakeup_fd, "0", 1); return;
if (wakeup_fd!= -1) &if (is_tripped) &break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <POSTCODE(wakeup_fd, "<0", 1);
if (wakeup_fd == -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd <0) write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) write(wakeup_fd, "<00", 1);
if (wakeup_fd!= -1) &if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); <else &write(wakeup_fd, "0", 1);
if (wakeup_fd == NULL) write(wakeup_fd, "&0", 1);
write (wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (remote_fd == NULL) <remote_fd = PZ_UNSUPPORTED; <else if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) &/* Write a valid signal */ if (wakeup_fd == NULL) &write(wakeup_fd, "0", 1); &else /* Write a signal */
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1); else <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) if (write_handler_fd(wakeup_fd, &fd)!= 0) &if (start_fd!= -1) write_handler_fd(wakeup_fd, "0", 1);
if (wakeup_ufd!= -1) write(wakeup_ufd, "0", 1);
if (wakeup_func!= -1) write(wakeup_func, "0", 1);
if (wakeup_fd!= -1) <if (wakeup_fd == 0) write(wakeup_fd, "0", 1); else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) &if (repeat) repeat->fd = "0", 1; else repeat->fd = "&0", 1; /* Scan the ptr for this file if we need to write it */
if (wakeup_fd!= -1) &ie_write(wakeup_fd, "&0", 1); &else <ie_write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) </* Now write the call to get the handler. */ &if (is_tripped) write(wakeup_fd, "&0", 1);
if (wakeup_fd = -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) /* Write the flags and the name of the flag */ if (write_fd("0", 1), &fd) &sig_p = sig_num; /* write (fd, "<0", 1); */ write (fd, "0", 1);
if (wakeup_fd!= -1) if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else if (wakeup_fd!= -1) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) <if (set_sig!= -1) </* Write out sig signal */ is_tripped = 1; &else &Py_AddPendingCall(checksignals_witharg, NULL);
if (wakeup_fd!= -1) <if (is_tripped) <break; <if (flags & PG_DIFF) if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) <printf("wakeup_fd: %s<n", wakeup_fd); return;
write(wakeup_fd, "<0", 0);
if (wakeup_fd!= -1) <if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); else <write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <if (is_tripped) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) &/* Now write the call to get the handler. */ <&if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) /* Now write the call to get the handler. */ if (is_tripped) write(wakeup_fd, "0", 1);
if (wakeup_fd!= -1) &if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; &else <if (remote_fd == NULL) remote_fd = PZ_UNSUPPORTED; else remote_fd = PZ_UNSUPPORTED; write(remote_fd, "0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "&0", 1)
if (wakeup_fd!= -1) write(wakeup_fd, "<0", &eif_irq_pr);
if (wakeup_fd!= -1) write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) <if (is_tripped) break; <if (flags & PG_DIFF) <if (flags & PG_DIFF) break; if (ptr && ptr->td_flags & PG_DIFF) break;
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1); break;
if (wakeup_fd!= -1) if (syslog) &printf("%s : got %d&n", (u_long)wakeup_fd, syslog);
if (wakeup_fd!= -1) &Py_AddPendingCall(checksignals_witharg, NULL); write(wakeup_fd, "<0", 1);
if (wakeup_fd!= -1) if ((set = _SingleMemory) ||!set) write(wakeup_fd, "&0", 1); <else write(wakeup_fd, "&0", 1);
if (wakeup_fd!= -1) write(wakeup_fd, "0", 1, 0);
