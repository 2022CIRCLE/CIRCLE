golden:
_Py_Finalizing = tstate; initialized = 0; flush_std_files();
inference:
#endif

return 0;
return true;
return;
PyType_ClearCache();
*/
return false;
break;
Py_IsInitialized();
return (0);
call_py_exitfuncs();
flush_std_files();
Py_FiniInterrupts();
if (!interp) return;
if (interp == NULL) return;
Py_ClearCache();
PZ_UNLOCK_GIANT();
free(interp);
py_exitfuncs();
initialized = 0;
/* Clear type lookup cache */ PyType_ClearCache();
Py_Initialize();
#ifdef DEBUG
PZ_Destroy();
PZ_UNLOCK(interp);
free_std_files();
splx(s);
tstate->interp = tstate->interp;
return 1;
Py_Shutdown();
if (!initialized) return;
return -1;
tstate = PyThreadState_GET();
PZ_RELEASE(interp);
PZ_UNLOCK();
@endif
Interrupt();
PyInitialize();
PyThreadState *tstate = PyThreadState_GET();
/* Disable signal handling */ PyType_ClearCache();
wait_for_thread_shutdown();
Py_Finalize();
return PR_FALSE;
/*
if (interp->interp == NULL) return;
#else
/* Get current thread state and interpreter pointer */
#if 0
PZ_FiniInterrupts();
Py_Exit();
tstate->interp = interp->interp;
if (initialized) return;
PZ_ClearCache();
Py_Finalize(void)
Init();
#ifdef DIAGNOSTIC
stdout+=stderr;
close_std_files();
#if defined(XP_MAC) || defined(XP_MACOSX)
continue;
if (interp) return;
PyThreadState *tstate;
PZ_Unlock();
if (interp == NULL) break;
free(tstate->interp);
PY_FiniInterrupts();
/* XXX */
PyType_DestroyCache();
/* Disable signal handling */ Py_IsInitialized();
PZ_DestroyThreads();
if (!interp->interp) return;
if (interp!= NULL) return;
return result;
/* Disable signal handling */
exit();
PyThreadState *interp;
PyFiniInterrupts();
if (interp == NULL)  return;
free(interp->interp);
PyThreadState *interp = tstate->interp;
# endif
Py_Destroy();
PY_UNLOCK_GIANT();
Py_FiniInitialize();
Stop();
if (interp->interp) return;
return NULL;
Py_FiniInterrupt();
PZ_UNLOCK_ASSERT();
#else return; #endif
PyThreadState *interp = PyThreadState_GET();
Py_DestroyThreads();
if (interp) break;
PZ_Destroy(interp);
PY_UNLOCK(interp);
int i;
PZ_Free(interp);
PyInterpreterState *interp;
/* * Clear type lookup cache */ PyType_ClearCache();
if (interp == NULL) continue;
if (initialized == 0) return;
if(interp == NULL) return;
else Py_FiniInterrupts();
Py_Finalize(void);
#ifdef NS_DEBUG
#endif /*
PZ_DestroyThreadState();
stdout+stderr;
#endif /* XXX */
PZ_DestroyCache();
stdout += stderr;
if (interp == NULL) return 0;
if (interp->interp!= NULL) return;
else if (interp == NULL) return;
/* Clear type lookup cache */
if (interp->interp) break;
#ifdef XP_MAC
PyInterpreterState *interp = PyThreadState_GET();
return
PY_UNLOCK();
if (interp == 0) return;
if (!interp) break;
Py_DestroyThreadState();
if (interp->interp == NULL) break;
stdout.flush_std_files();
printf("Py_Initialize()n");
Py_FiniInterrupts(interp);
#ifdef __GNUC__
(void) Py_Finalize();
if (interp!= NULL) break;
if (interp->interp == NULL)  return;
if (tstate->interp == NULL) return;
Py_Lock(tstate);
if (!interp) continue;
Py_Initialize(void);
if (interp == NULL)  break;
#if defined(XP_MAC) || defined(XP_OS2)
interp->interp = tstate->interp;
else if (!interp) return;
PZ_FiniInterrupts(interp);
PZ_FiniInterrupt();
if (!interp)  return;
#if defined(XP_MAC) || defined(XP_OS2) #endif
PZ_DestroyThread(interp);
if (interp->initialized) return;
if (interp->interp->interp == NULL) return;
tstate->interp = tstate->interp->interp;
exit funcs may be relying on that.
#ifdef ARGO_DEBUG
/* * Disable signal handling */ PyType_ClearCache();
/* * Get current thread state and interpreter pointer */
if (interp == NULL)  return 0;
if (interp->interp == 0) return;
if (interp->interp->initialized) return;
if (interp->interp == NULL) continue;
/* Clear type lookup cache. */ PyType_ClearCache();
#if defined(XP_MAC) || defined(XP_MACOSX) */
if (interp!= NULL)  return;
else if (interp->interp == NULL) return;
#if defined(XP_MAC) ||!defined(XP_MACOSX)
if (interp->interp!= NULL) break;
if (interp->interp == NULL) return 0;
/* Disable signal handling */ PyType_FiniInterrupts();
if (interp->interp)  return;
if(interp->interp == NULL) return;
#if defined(XP_MAC) || defined(XP_MAC)
printf("Py_Initialize() failedn");
tstate->tstate->interp = tstate->interp;
#if defined(XP_MAC) || defined(XP_MAC) #endif
if (interp->interp == NULL)  break;
tstate->interp->interp = tstate->interp;
/* Flush stdout+stderr */
if (interp->interp!= 0) return;
if (tstate->interp!= NULL) return;
return 0; /* Get current thread state and interpreter pointer */
if (interp->interp!= NULL)  return;
/* Disable signal handling */ PyType_DestroyCache();
tstate->interp->interp = tstate->interp->interp;
tstate->interp = interp->interp->interp;
#if defined(XP_MACOSX) || defined(XP_MACOSX)
if (interp->interp == NULL)  return 0;
#if defined(XP_MAC) && defined(XP_MACOSX)
#ifdef XP_MAC if (!interp) return; #endif
if (interp &&!interp->interp) return;
if (interp->interp->interp->interp == NULL) return;
if (interp->interp->interp->initialized) return;
if (interp->interp->interp!= NULL) return;
/* Clear type lookup cache */ PyType_ClearCache(); */
#if defined(XP_MAC) || defined(XP_OS2); #endif
PyType_ClearCache(); /* Collect garbage. */
return (FAILURE);
/* No module for the interface */ if (Interp.next)  /* In case there is no processor, we are trying to unpy it. */ if (Interp.next)  /* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
PY_Destroy();
/* Disable signal handling */ PyType_ClearCache(); /* Remove the * interpreter */ PyType_Shutdown();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL)  p = Py_FiniInterrupt(); p->p->p_lock = p;  else  p->p_lock = p->p_lock;
if (interp->interp->interp->isdv_arch)  if (interp->interp->isdv_arch)  Py_FreeSession(interp->interp->isdv_arch);  else  Py_FreeSession(interp->interp->isdv_arch);
Py_Unlock(&lock);
/* XXX return 0;
/* * See if we aren't using it */ return 0;
PZ_Wait(&interp);
if (ptstate->ptstate)  /* if thread funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * * Note that Threading.py uses an exit func to do a join on all the * threads created through it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs();
/* Destroy all interps. */
/* Remove callbacks. This may call other threads created via Threading. */ call_py_exitfuncs();
PZ_ASSERT(interp);
/* Is there a valid state? */
#ifdef __P__ /* * This can make sure we will be in the state of the state. XXX may be any more appropriate than the __Py______.*/
if (tstate->tstate->interp->tstate->interp)  free_tstate_get(); tstate->interp->tstate->interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a module. */ flush_std_files(); /* Restart the thread state and interpreter pointer */ PY_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD
if (interp->interp == NULL)  PZ_Unlock();
/* Unregister the current thread and exit funcs for an /* XXX */ funcs.remove(&interp); /* * Check if it's still alive */ funcs.remove(&interp);
/* * Disable signal handling */ if (interp)  if (interp->interp)  /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp;  else  /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->np)  /* Debug("interpreter %s (%s)",interp->interp->np->interp->np->np->interp->np->np->np->interp->np->np->interp->np->interp->interp->np->interp->np->interp->np->interp->np->np->interp->interp->np->interp->np->interp->np->interp->np->interp->np->interp->interp->interp->interp->np->np->interp->interp->interp->np->interp->interp->np->interp->interp->interp->np->np->np->np->interp->interp->interp->np->np->np->np->np->np->np->np->np->np->np->np->np->np->n
/* * First to try to finish this one. */ if (InterpreterState_Finalize())  *interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = tstate->interp;
if (interp == NULL)  /* Note that Threading.py uses an exit func to do a join on all the * * threads created thru it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs(); initialized = 0;
/* Remove some threads. */ if (!interp)  tstate->interp = interp->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still alive. */ /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->del_object!= 0)  /* if it's in this thread, remove it from this thread. */ /* Set current thread state and interpreter pointer to this point. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ if (some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. */ call_py_exitfuncs();
PY_DestroyInterrupt();
/* Restore old state */ if ((interp->interp) == NULL)  /* Destroy current thread state. */ tstate = PyThreadState_GET(); tstate->interp = interp->interp;
#if defined(DEBUG) if (stderr) printf("py_Initialize()::Initialize()n"); #endif
/* XXX It's a case where this thread isn't ready */ if (interp)  struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '0';
/* The terminating thread state and interpreter pointer may be initialized. */ if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL)  /* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL)  if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
/* Check if this should work on any threads. */
return (failed);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop)  /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop;  else  if (!interp->interp->interp->iop)  /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef ARGO_DEBUG_std if (argo_debug) printf("Py_Initialize: Py_Initialize()n"); #endif
/* The interpreter is still completely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * * If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX no longer believes it's already started. */
/* If no new thread has been found, then we are waiting for * an internal thread to finish * after the exit funcs have run. */ if ((interp = PY_Lock(tstate)) &&!interp) return;
Py_FreeAllocator();
#ifdef NECKO
/* * if (syscall &&!syscall)  return;
return 0; /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. */ call_py_exitfuncs();
/* * If the state is not specified, a weakref is triggered */ tstate = PyThreadState_GET(); interp = tstate->interp; /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * * If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX no longer believes it's a module. */ if (interp->interp) *interp->interp = tstate->interp; else *interp = tstate->interp; else if (interp->interp!= tstate->interp)
/* Now, ret &= P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp)  P_NO_XUL = 0;
if (interp == NULL)  fputs("%sn",interp); return 0;
return 0; /* Make sure we have a function, in case we don't know what to do */ Py_BindInterrupt();
if (interp)  wait_for_thread_shutdown();
/* Init() is set, so set in the current thread to a * different * thread. */
#ifdef __PY__
/* Init for */
PHY_DEBUG(("Py_Initialize: recursively removedn"));
/* Ignore uninitialized threads */ return(PR_FALSE);
return (interp);
#if defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__)  Py_Initialize(); #endif
/* Turn off threads. */ Py_DelCache();
/* Destroy or free interrupt */
#if defined(XP_MAC) || defined(XP_MACOSX) /* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp;
/* See if we haven't been loaded in a * thread. */ if (interp->interp)  (void) Py_FiniInterrupts();
/* if there is no plugin support, we don't have any free plugins, * so we can't find one */
Py_Py_FiniInterrupts();
PZ_Unlock(&interp);
Py_ExpendShutdown();
#if defined(XP_MAC) &&!defined(XP_MACOSX) if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->inter
#ifdef XP_MAC if (sym_version  2)  /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version  2)  sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__;   else  Py_DestroyThreads();
/* * Not an __DEBUG if we were still done, then * check for bugzilla if we were already done. */ #ifdef INET6 if (InterpreterState_GET()->interp) return;
/* Recycle the buffer and clear a flag */
/* if it's a callback, we'll have to handle that case */ break;
#if defined(__Disable__) &&!defined(__FiniInterrupts)) return; #endif
/* Get current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
/* This has been removed since we should use this now. */
#ifdef NECKO /* NECKO /* XXX */
/* We can't create a tstate with this flag: it can't be wiped out by the caller. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. */ call_py_exitfuncs();
Py_Unlock_spin(tstate->lock);
if (tstate->interp!= NULL) Py_Py_FiniInterrupts();
if (strncmp(interp, "pythread_exit") == 0) return;
/* We still don't use a default signal handling unless there is a good reason. */
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL)  return;  #endif
/* XXX * We'll get all the threads created via XXX(). We have not the XXX name yet, but we'll just rcpy. */
if (interp)  /* Initialize */ static Py_Finalize(void)  PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
/* If the initializer has been deleted, this may need to be cleared */ /* * We have not yet * done it, so the user can only write threads in the pending threads. We need to add the callback from * the thread. */ call_py_exitfuncs();
/* Clear callbacks */
PyFiniLocks();
if ((interp->interp == NULL) || (interp->interp == NULL))  *interp = 0;
PyClearCache();
/* * This may not be done yet */ if (interp->interp == NULL)  /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL)  /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL)  /* * We have the pending callback for the timeout. */ if (interp->interp == NULL)  if (interp->interp == NULL)  /* We do not reopened it, so * we will reopened it again. */  if (interp->interp == NULL)  if (interp->interp == NULL)  if (interp->interp == NULL)  /* *
if (interp == NULL)  if (interp->interp == NULL)  /* Stop retrying */
/* * If the last time of the next, the current time and the * end of the queue is the time. */ if (tstate->interp) return;
Py_DisableInterrupt();
/* Free the loops from the thread. */
Py_Fini_Reset();
/* nsFinish(): -- the fstats are null in the namespace, because the flags is NULL */ /* nsFinish(): --pstart_ctxt */ if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))  1)))))))) return;
if (tstate->interp) Py_FiniInterrupts();
/* * Check the threads at this point. */ Py_IsInitialized();
/* Make sure to create a new thread */ /* Create a new thread */ if ((!interp)) return; /* Remove a current thread */
else  /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE))  pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
#ifdef DIAGNOSTIC if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
/* Free stdout + stderr */
Py_SetCurrentFunctions(interp);
#if defined(__Py__) &&!defined(__Py__))  /* Unuse the callback */ if (!interp->interp) break;
/* Check for stdout and exit funcs */ if (!interp) return;
Py_BreakCache();
PZ_Lock(&gpk_lock);
#ifdef XP_MAC if (interp->interp)  Py_Shutdown();  #endif
#if defined(XP_MAC) || defined(XP_MACOSX) #endif
#ifdef NECKO if (tstate->interp && interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
/* Set the boolean handler to the current thread state. */ if (interp == NULL) return;
/* Unset up all the registers (in case there is no real state) */
if (interp->interp->funcs && funcs)  /* Clear type lookup cache */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX no longer believes it's a tstate. */
else if (interp == NULL)  return;
#ifdef DISPATCH_PY_INTERPRET_CALLING
/* * Free the callback buffer and re-slot */ Py_FreeByte(tstate->interp);
if (interp->interp)  if (interp->interp->interp->pwd)  if (interp->interp->pwd)  if (interp->interp->pwd)  /* XXX */ PY_INTERPRUNC(interp->interp->pwd);  else  /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *

if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * if (syscall &&!syscall) <return;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; &else &p->p_lock = p->p_lock;
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) &/* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) <if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; <else p->p_lock = p->p_lock;
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
printf("Py_Initialize() failed&n");
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; else <p->p_lock = p->p_lock;
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* See if we haven't been loaded in a * thread. */ if (interp->interp) &(void) Py_FiniInterrupts();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
if (interp) &/* Initialize */ static Py_Finalize(void) &PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp == NULL) &if (interp->interp == NULL) &/* Stop retrying */
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp!= NULL) &return;
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp == NULL) return 0;
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; else p->p_lock = p->p_lock;
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Now, ret &= &P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) <P_NO_XUL = 0;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
&else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp == NULL) &break;
if (interp->interp) <return;
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; else <p->p_lock = p->p_lock;
/* See if we haven't been loaded in a * thread. */ if (interp->interp) (void) Py_FiniInterrupts();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (ptstate->ptstate) &/* if thread funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * * Note that Threading.py uses an exit func to do a join on all the * threads created through it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs();
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) <return; &#endif
if ((interp->interp == NULL) || (interp->interp == NULL)) <*interp = 0;
if (interp == NULL) &break;
else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
<else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
#if defined(DEBUG) if (stderr) printf("py_Initialize()::Initialize()<n"); #endif
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) &/* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp) wait_for_thread_shutdown();
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; &else p->p_lock = p->p_lock;
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) </* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) &if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp!= NULL) return;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->del_object!= 0) </* if it's in this thread, remove it from this thread. */ /* Set current thread state and interpreter pointer to this point. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ if (some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. */ call_py_exitfuncs();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
<else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) return; &#endif
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp == NULL) <if (interp->interp == NULL) </* Stop retrying */
/* No module for the interface */ if (Interp.next) &/* In case there is no processor, we are trying to unpy it. */ if (Interp.next) /* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
/* No module for the interface */ if (Interp.next) &/* In case there is no processor, we are trying to unpy it. */ if (Interp.next) &/* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
&else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * First to try to finish this one. */ if (InterpreterState_Finalize()) *interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = tstate->interp;
/* XXX It's a case where this thread isn't ready */ if (interp) struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '<0';
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
<else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
else if (interp == NULL) return;
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
if (interp) <wait_for_thread_shutdown();
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp) &/* Initialize */ static Py_Finalize(void) <PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) return; #endif
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
if (!interp) &return;
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp == NULL) <fputs("%sn",interp); return 0;
PHY_DEBUG(("Py_Initialize: recursively removed&n"));
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
&else if (interp == NULL) &return;
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; <else &p->p_lock = p->p_lock;
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) </* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#if defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__) &Py_Initialize(); #endif
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp) &return;
if (interp == NULL) <break;
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; <else &p->p_lock = p->p_lock;
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) &return; <#endif
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef ARGO_DEBUG_std if (argo_debug) printf("Py_Initialize: Py_Initialize()<n"); #endif
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) &return; #endif
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->del_object!= 0) &/* if it's in this thread, remove it from this thread. */ /* Set current thread state and interpreter pointer to this point. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ if (some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. */ call_py_exitfuncs();
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; &else <p->p_lock = p->p_lock;
if (interp == NULL) if (interp->interp == NULL) &/* Stop retrying */
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; <else &p->p_lock = p->p_lock;
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* Remove some threads. */ if (!interp) tstate->interp = interp->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still alive. */ /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache();
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
PHY_DEBUG(("Py_Initialize: recursively removedn"));
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (tstate->tstate->interp->tstate->interp) free_tstate_get(); tstate->interp->tstate->interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a module. */ flush_std_files(); /* Restart the thread state and interpreter pointer */ PY_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
if (ptstate->ptstate) </* if thread funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * * Note that Threading.py uses an exit func to do a join on all the * threads created through it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs();
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* XXX It's a case where this thread isn't ready */ if (interp) <struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '&0';
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#if defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__) Py_Initialize(); #endif
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
<else if (interp == NULL) return;
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
&else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
&else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
if (interp == NULL) break;
#ifdef ARGO_DEBUG_std if (argo_debug) printf("Py_Initialize: Py_Initialize()n"); #endif
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
&else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if ((interp->interp == NULL) || (interp->interp == NULL)) *interp = 0;
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp == NULL) if (interp->interp == NULL) /* Stop retrying */
<else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; &else <p->p_lock = p->p_lock;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* nsFinish(): -- the fstats are null in the namespace, because the flags is NULL */ /* nsFinish(): --pstart_ctxt */ if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))) 1)))))))) return;
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; <else p->p_lock = p->p_lock;
printf("Py_Initialize()n");
if (interp->interp == NULL) return;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
if (interp == NULL) if (interp->interp == NULL) </* Stop retrying */
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
return false;
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (tstate->tstate->interp->tstate->interp) <free_tstate_get(); tstate->interp->tstate->interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a module. */ flush_std_files(); /* Restart the thread state and interpreter pointer */ PY_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
/* Now, ret &= &P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) &P_NO_XUL = 0;
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; else p->p_lock = p->p_lock;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp!= NULL) &return;
/* XXX It's a case where this thread isn't ready */ if (interp) &struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '0';
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
#if defined(DEBUG) if (stderr) printf("py_Initialize()::Initialize()&n"); #endif
if (interp->interp == NULL) &return 0;
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
&else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
<else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp == NULL) <return 0;
PHY_DEBUG(("Py_Initialize: recursively removed<n"));
else if (interp == NULL) &return;
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* No module for the interface */ if (Interp.next) /* In case there is no processor, we are trying to unpy it. */ if (Interp.next) </* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#if defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__) || defined(__PY__) <Py_Initialize(); #endif
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#if defined(DEBUG) if (stderr) printf("py_Initialize()::Initialize()n"); #endif
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; &else p->p_lock = p->p_lock;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
<else if (interp == NULL) &return;
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * First to try to finish this one. */ if (InterpreterState_Finalize()) &*interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = tstate->interp;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* No module for the interface */ if (Interp.next) /* In case there is no processor, we are trying to unpy it. */ if (Interp.next) &/* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) /* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
if (interp->interp!= NULL) return;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
break;
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp == NULL) &fputs("%sn",interp); return 0;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
/* XXX It's a case where this thread isn't ready */ if (interp) <struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '0';
/* Now, ret &= <P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) P_NO_XUL = 0;
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp) </* Initialize */ static Py_Finalize(void) &PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
#ifdef XP_MAC if (interp->interp) &Py_Shutdown(); <#endif
if (interp->interp->interp->np) </* Debug("interpreter %s (%s)",interp->interp->np->interp->np->np->interp->np->np->np->interp->np->np->interp->np->interp->interp->np->interp->np->interp->np->interp->np->np->interp->interp->np->interp->np->interp->np->interp->np->interp->np->interp->interp->interp->interp->np->np->interp->interp->interp->np->interp->interp->np->interp->interp->interp->np->np->np->np->interp->interp->interp->np->np->np->np->np->np->np->np->np->np->np->np->np->np->n
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* Restore old state */ if ((interp->interp) == NULL) &/* Destroy current thread state. */ tstate = PyThreadState_GET(); tstate->interp = interp->interp;
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (interp->interp) Py_Shutdown(); <#endif
/* * First to try to finish this one. */ if (InterpreterState_Finalize()) <*interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = PyThreadState_GET(); interp = tstate->interp;
if (interp == NULL) <if (interp->interp == NULL) /* Stop retrying */
#ifdef XP_MAC if (interp->interp) &Py_Shutdown(); &#endif
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; &else &p->p_lock = p->p_lock;
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->funcs && funcs) </* Clear type lookup cache */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX no longer believes it's a tstate. */
/* XXX It's a case where this thread isn't ready */ if (interp) &struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '<0';
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp == NULL) <return 0;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) /* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) <if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* XXX It's a case where this thread isn't ready */ if (interp) &struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '&0';
if (interp->interp == NULL) <return;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; else &p->p_lock = p->p_lock;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
&else if (interp == NULL) <return;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* No module for the interface */ if (Interp.next) </* In case there is no processor, we are trying to unpy it. */ if (Interp.next) &/* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) &/* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) &if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
if (interp == NULL) return 0;
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
/* XXX It's a case where this thread isn't ready */ if (interp) struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '0';
/* See if we haven't been loaded in a * thread. */ if (interp->interp) <(void) Py_FiniInterrupts();
/* Now, ret &= P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) P_NO_XUL = 0;
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->funcs && funcs) &/* Clear type lookup cache */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX no longer believes it's a tstate. */
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp == NULL) fputs("%s&n",interp); return 0;
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp == NULL) &return;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* XXX It's a case where this thread isn't ready */ if (interp) struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '&0';
if (interp->interp == NULL) <PZ_Unlock();
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp == NULL) <fputs("%s&n",interp); return 0;
else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp == NULL) /* Note that Threading.py uses an exit func to do a join on all the * * threads created thru it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs(); initialized = 0;
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) return; <#endif
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
if (interp == NULL) &fputs("%s&n",interp); return 0;
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
if (interp == NULL) </* Note that Threading.py uses an exit func to do a join on all the * * threads created thru it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs(); initialized = 0;
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Now, ret &= P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) &P_NO_XUL = 0;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp == NULL) &if (interp->interp == NULL) /* Stop retrying */
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Now, ret &= &P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) P_NO_XUL = 0;
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
&else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
/* Now, ret &= <P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) &P_NO_XUL = 0;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; &else p->p_lock = p->p_lock;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; <else <p->p_lock = p->p_lock;
if (tstate->tstate->interp->tstate->interp) &free_tstate_get(); tstate->interp->tstate->interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a module. */ flush_std_files(); /* Restart the thread state and interpreter pointer */ PY_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD_STD
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) /* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) &if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp) return;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* No module for the interface */ if (Interp.next) &/* In case there is no processor, we are trying to unpy it. */ if (Interp.next) </* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
/* Now, ret &= P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) <P_NO_XUL = 0;
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; else &p->p_lock = p->p_lock;
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp!= NULL) <return;
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
return PR_FALSE;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else &Py_FreeSession(interp->interp->isdv_arch);
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; &else &p->p_lock = p->p_lock;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (interp->interp) <Py_Shutdown(); #endif
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
<else if (interp == NULL) <return;
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if (interp->interp) <Py_Shutdown(); <#endif
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
return (0);
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#if defined(__Py__) &&!defined(__Py__)) /* Unuse the callback */ if (!interp->interp) break;
#ifdef XP_MAC if (interp->interp) <Py_Shutdown(); &#endif
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
if (interp == NULL) <if (interp->interp == NULL) &/* Stop retrying */
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp) &/* Initialize */ static Py_Finalize(void) PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* The 'tstate' interface will be replaced by 'tstate', so that we cannot * put it in * the * * * module and that is a reference pointer. */ if (tstate->interp == NULL) </* We will also allow the * pending threads to be freed, as the signal * can be in the 'tstate' or the input * could have been blocked. */ if (interp == NULL) <if (interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->interp->
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
printf("Py_Initialize()<n");
else if (interp == NULL) <return;
<else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (!interp) return;
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) <return; #endif
if (interp->interp->interp->np) /* Debug("interpreter %s (%s)",interp->interp->np->interp->np->np->interp->np->np->np->interp->np->np->interp->np->interp->interp->np->interp->np->interp->np->interp->np->np->interp->interp->np->interp->np->interp->np->interp->np->interp->np->interp->interp->interp->interp->np->np->interp->interp->interp->np->interp->interp->np->interp->interp->interp->np->np->np->np->interp->interp->interp->np->np->np->np->np->np->np->np->np->np->np->np->np->np->n
return;
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp == NULL) <break;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (interp->interp) &Py_Shutdown(); #endif
if (interp->interp->del_object!= 0) /* if it's in this thread, remove it from this thread. */ /* Set current thread state and interpreter pointer to this point. */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ if (some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. */ call_py_exitfuncs();
if (interp == NULL) &if (interp->interp == NULL) </* Stop retrying */
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* No module for the interface */ if (Interp.next) </* In case there is no processor, we are trying to unpy it. */ if (Interp.next) </* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
printf("Py_Initialize() failed<n");
else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) &pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) &if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Remove some threads. */ if (!interp) &tstate->interp = interp->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still alive. */ /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* Restore old state */ if ((interp->interp) == NULL) </* Destroy current thread state. */ tstate = PyThreadState_GET(); tstate->interp = interp->interp;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp!= NULL) <return;
printf("Py_Initialize()&n");
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
printf("Py_Initialize() failedn");
if (!interp) <return;
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; else <p->p_lock = p->p_lock;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (interp->interp) Py_Shutdown(); &#endif
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) <return; <#endif
if (interp == NULL) &fputs("%s<n",interp); return 0;
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
if (interp) &wait_for_thread_shutdown();
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) &if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
/* Now, ret &= <P_NO_XUL; */ /* Delete all the XUL subtasks and ignore it */ if (Interp) <P_NO_XUL = 0;
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp == NULL) &return 0;
if (interp->interp == NULL) PZ_Unlock();
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; <else <p->p_lock = p->p_lock;
if (interp->interp->funcs && funcs) /* Clear type lookup cache */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX no longer believes it's a tstate. */
<else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if ((interp->interp == NULL) || (interp->interp == NULL)) &*interp = 0;
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
&else if (interp == NULL) return;
if (interp->interp) <if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; <else p->p_lock = p->p_lock;
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* XXX It's a case where this thread isn't ready */ if (interp) <struct buf[] buf = (struct buf *)interp->interp; /* The interface tstate = PyThreadState_GET(); buf[2] = buf; /* * When this thread isn't ready, we want to do it here. */ buf[3] = '<0';
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
<else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; <else <p->p_lock = p->p_lock;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* No module for the interface */ if (Interp.next) </* In case there is no processor, we are trying to unpy it. */ if (Interp.next) /* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* Restore old state */ if ((interp->interp) == NULL) /* Destroy current thread state. */ tstate = PyThreadState_GET(); tstate->interp = interp->interp;
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp == NULL) fputs("%sn",interp); return 0;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
/* nsFinish(): -- the fstats are null in the namespace, because the flags is NULL */ /* nsFinish(): --pstart_ctxt */ if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))) <1)))))))) return;
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) &p = Py_FiniInterrupt(); p->p->p_lock = p; &else <p->p_lock = p->p_lock;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version <2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version &2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) <if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) &/* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp == NULL) <return;
else &/* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#ifdef XP_MAC if (sym_version 2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) </* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) <p = Py_FiniInterrupt(); p->p->p_lock = p; else p->p_lock = p->p_lock;
#ifdef XP_MAC if ((interp->interp->ip_msg & PIPE) == NULL) &return; &#endif
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's a pending thread. */ /* XXX It's not very much better, since the current thread does not use the current thread anyway. */ if (interp == NULL) p = Py_FiniInterrupt(); p->p->p_lock = p; else &p->p_lock = p->p_lock;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp == NULL) &PZ_Unlock();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp == NULL) fputs("%s<n",interp); return 0;
if (interp->interp == NULL) break;
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp) if (interp->interp->interp->pwd) if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) &if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
#ifdef XP_MAC if (sym_version &2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if (sym_version <2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version 2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
#ifdef XP_MAC if (sym_version <2) &/* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else /* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else /* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp == NULL) <fputs("%s<n",interp); return 0;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
return 0;
if (interp->interp == NULL) &return;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * if (syscall &&!syscall) return;
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) /* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp) &if (interp->interp->interp->pwd) if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) &if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else Py_FreeSession(interp->interp->isdv_arch);
if (ptstate->ptstate) /* if thread funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * * Note that Threading.py uses an exit func to do a join on all the * threads created through it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs();
/* Remove some threads. */ if (!interp) <tstate->interp = interp->interp; /* Disable signal handling */ PyType_ClearCache(); /* Collect garbage. This may call finalizers; it's nice to call these * before all modules are destroyed. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still alive. */ /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache(); /* Remove current thread state and interpreter pointer */ tstate = PyThreadState_GET(); interp = tstate->interp; /* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) </* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp) /* Initialize */ static Py_Finalize(void) &PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
#ifdef ARGO_DEBUG_std if (argo_debug) printf("Py_Initialize: Py_Initialize()&n"); #endif
/* nsFinish(): -- the fstats are null in the namespace, because the flags is NULL */ /* nsFinish(): --pstart_ctxt */ if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))) &1)))))))) return;
#ifdef XP_MAC if (sym_version 2) /* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) <sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) &/* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
#if defined(__Py__) &&!defined(__Py__)) &/* Unuse the callback */ if (!interp->interp) break;
if (interp->interp) <if (interp->interp->interp->pwd) <if (interp->interp->pwd) if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
<else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
if (interp->interp) if (interp->interp->interp->pwd) <if (interp->interp->pwd) &if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
/* * Disable signal handling */ if (interp) <if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else /* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
return true;
if (interp) </* Initialize */ static Py_Finalize(void) PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
#if defined(__Py__) &&!defined(__Py__)) </* Unuse the callback */ if (!interp->interp) break;
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); &else <Py_FreeSession(interp->interp->isdv_arch);
/* No module for the interface */ if (Interp.next) /* In case there is no processor, we are trying to unpy it. */ if (Interp.next) /* We don't have to stop the process, * we must get the first thread state for that. */ Py_Initialize(void); *interp = tstate->interp;
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); <else <Py_FreeSession(interp->interp->isdv_arch);
/* * if (syscall &&!syscall) &return;
#ifdef XP_MAC if (sym_version 2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version &2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) &/* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) &if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) <if (interp->interp) </* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else &/* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; <else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
#ifdef XP_MAC if (sym_version &2) </* * This will rerun. */ /* * Set the NCP code and use the __libc__ npc, * then we're generating it * and __libc__. */ if (sym_version <2) &sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME; sym_version = Py_M_SYS_DEVICE_TYPE_NAME_NAME_NAME_NAME_NAME_NAME_NAME; sym_version = Py_M_SYS_SYS_SYM_SYS_SYS_SYS__; else Py_DestroyThreads();
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp->interp->np) &/* Debug("interpreter %s (%s)",interp->interp->np->interp->np->np->interp->np->np->np->interp->np->np->interp->np->interp->interp->np->interp->np->interp->np->interp->np->np->interp->interp->np->interp->np->interp->np->interp->np->interp->np->interp->interp->interp->interp->np->np->interp->interp->interp->np->interp->interp->np->interp->interp->interp->np->np->np->np->interp->interp->interp->np->np->np->np->np->np->np->np->np->np->np->np->np->np->n
if (interp) </* Initialize */ static Py_Finalize(void) <PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) &Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->isdv_arch) <if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) <Py_FreeSession(interp->interp->isdv_arch); &else &Py_FreeSession(interp->interp->isdv_arch);
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else &/* Disable signal handling */ PyType_ClearCache();
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
&else </* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; &else </* Disable signal handling */ PyType_ClearCache();
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) /* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) </* * We have the pending callback for the timeout. */ if (interp->interp == NULL) if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
if (interp->interp) if (interp->interp->interp->pwd) &if (interp->interp->pwd) <if (interp->interp->pwd) </* XXX */ PY_INTERPRUNC(interp->interp->pwd); else /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. *
#ifdef XP_MAC if (interp->interp) Py_Shutdown(); #endif
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); <else &Py_FreeSession(interp->interp->isdv_arch);
/* * This may not be done yet */ if (interp->interp == NULL) /* * To prevent the callback, we must do * this. */ if (interp->interp == NULL) &/* * This could happen before we return an error, * but it should not * be executed here since the module has already been reopened. */ /* * The first time we reopened it, try again if we are still done. */ if (interp->interp == NULL) /* * We have the pending callback for the timeout. */ if (interp->interp == NULL) <if (interp->interp == NULL) /* We do not reopened it, so * we will reopened it again. */ if (interp->interp == NULL) if (interp->interp == NULL) if (interp->interp == NULL) /* *
/* * Disable signal handling */ if (interp) &if (interp->interp) /* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; else </* Disable signal handling */ PyType_ClearCache();
if (interp == NULL) return;
if (interp) /* Initialize */ static Py_Finalize(void) PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
if (interp) /* Initialize */ static Py_Finalize(void) <PyInterpreterState *interp; PyThreadState *tstate; if (!initialized) return; wait_for_thread_shutdown(); /* The interpreter is still entirely intact at this point, and the * exit funcs may be relying on that. In particular, if some thread * or exit func is still waiting to do an import, the import machinery * expects Py_IsInitialized() to return true. So don't say the * interpreter is uninitialized until after the exit funcs have run. * XXX If a __del__ or weakref callback is triggered here, and tries to * XXX import a module, bad things can happen, because Python no * XXX longer believes it's still used here. * XXX Initialize() will be deleted. * If the interrupt should be wiped out. * If the
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) &/* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else &if (!interp->interp->interp->iop) &/* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
&else /* XXX don't use Py_Initialize(). */ if (pythread_lock && (pythread_lock & PT_STATUS_UNAVAILABLE)) <pythread_lock_init(&pythread_lock); pythread_lock_unlock(&pythread_lock); pythread_unlock(&pythread_lock); pythread_lock_init(&pythread_lock);
/* * Disable signal handling */ if (interp) <if (interp->interp) &/* Stop processing */ tstate = PyThreadState_GET(); interp = tstate->interp; <else </* Disable signal handling */ PyType_ClearCache();
if (interp->interp->interp->isdv_arch) &if (interp->interp->isdv_arch) Py_FreeSession(interp->interp->isdv_arch); else <Py_FreeSession(interp->interp->isdv_arch);
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) /* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; else if (!interp->interp->interp->iop) /* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp->interp->interp->interp->interp->iop && tstate->interp->interp->iop!= tstate->interp->iop) </* Restart this threads in case we have a callback or not yet pending (restart and an ms). */ tstate->interp->interp->iop = tstate->interp->iop; &else <if (!interp->interp->interp->iop) </* Disable signal handling */ tstate->interp->interp->interp->interp->interp->interp->interp->iop = tstate->interp->iop;
if (interp == NULL) &/* Note that Threading.py uses an exit func to do a join on all the * * threads created thru it, so this also protects pending imports in * the threads created via Threading. */ call_py_exitfuncs(); initialized = 0;
