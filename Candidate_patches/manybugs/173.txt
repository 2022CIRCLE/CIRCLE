golden:
if (token_type == T_HALT_COMPILER) { break; }
inference:

break;
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
#endif
return_value;
ZVAL_NULL(&token);
return_value = 0;
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO:
case T_OPEN_TAG:
case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break;
else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_COMMENT:
case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break;
case T_OPEN_TAG_WITH_ECHO:
token_line = 0;
efree(Z_STRVAL(token));
case T_DEBUG:
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 0);
case T_WHITESPACE:
default: add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_OBJECT:
splx(s);
delete_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
default: break;
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 2);
ZVAL_NULL(&token_type);
/* XXX */
free(token_type);
next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
return_value = keyword;
*/
case T_OK:
case T_ORPEN_TAG: case T_OPEN_TAG_WITH_ECHO:
return_value = 1;
return_value = NULL;
case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break;
case T_WRITESPACE:
else
add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (destroy)  ZVAL_NULL(&token);
free(keyword);
MAKE_STD_ZVAL(keyword);
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE:
break; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO:
free(return_value);
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT:
return_value = result;
result = 0;
*token_line = 0;
if (destroy && Z_TYPE(token))  ZVAL_NULL(&token);
case T_NEEDGIANT:
case T_SUCCESS:
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token));
else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
ZVAL_NULL(&return_value);
case T_OK: case T_OPEN_TAG_WITH_ECHO:
else  ZVAL_NULL(&token);
efree(token_type);
case T_ORPEN_TAG:
token_line = 1;
break; case T_OPEN_TAG:
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: break;
default:
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1)
case T_OFFSET:
return_value, keyword;
#ifdef DEBUG
case T_GENERIC:
add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
int i;
case T_INCREMENT:
case T_WITH_ECHO:
case T_COMMENT: case T_DOC_COMMENT:
ZVAL_UNLOCK(keyword);
case T_WHITESPACE: case T_DOC_COMMENT:
break; case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break;
ZVAL_NULL(&token); break;
case T_REMOVE:
continue;
ZVAL_UNLOCK(&token);
if (next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_ERROR:
ZVAL_UNLOCK(token);
case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE:
case T_DOC_COMMENT:
return_value(keyword);
ZVAL_UNLOCK();
case T_TRUE:
case T_OPEN_TAG: break;
free(return_value, keyword);
if (token_type == T_END_HEREDOC)
case T_Destroy:
case T_END_HEREDOC:
add_next_index_stringl(keyword, Z_STRVAL(token));
*token_line = 1;
case T_OBPEN_TAG: case T_OPEN_TAG_WITH_ECHO:
case T_OBJECT: case T_OBJECT:
case T_OPTION:
if (destroy) break;
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_COMMENT:
case T_RELEASE:
ZVAL_NULL(&token_value);
case T_REFERENCE:
case T_WHEEL:
case T_EMPTY:
case T_QUIET:
case T_CLOSE_TAG:
case T_NONBLOCK:
case T_NONE:
case T_DISPLAY:
if (destroy && Z_TYPE(token))
else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
token_line = 0; break;
case T_LOCK_TAG:
case T_ONLINE:
if (destroy && Z_TYPE(token))  CG(zend_lineno)++;
else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 0);
case T_COMMENT: case T_DOC_COMMENT: destroy = 1; break;
case T_INCR:
case T_TOKEN:
case T_OCPEN_TAG: case T_OPEN_TAG_WITH_ECHO:
case T_BUSY:
case T_UNLOCK:
if (token_type >= 256)
if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword);
add_next_index_stringl(keyword, 0, Z_STRVAL(token), Z_STRLEN(token), 1);
int token_line = 1;
case T_TYPE(token):
return_value = 0; break;
if (return_value == 0) return 0;
add_next_index_stringl(keyword,Z_STRVAL(token), Z_STRLEN(token), 1);
break; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE:
else  efree(Z_STRVAL(token));
case T_CLOSE_TAG: case T_OPEN_TAG_WITH_ECHO:
break; case T_COMMENT:
case T_NO_TAG:
if (destroy)  CG(zend_lineno)++;
efree(Z_STRVAL(token), 1);
if (token_type == T_DEBUG)
else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 2);
case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT:
add_next_index_stringl(keyword, Z_STRVAL(token), 0, 1);
add_next_index_stringl(keyword, Z_STRVAL (token), Z_STRLEN (token), 1);
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 3);
if (destroy && Z_TYPE(token)) return 0;
add_next_index_stringl(keyword, 0);
if (token_type == T_END_HEREDOC) break;
add_next_index_stringl(keyword, Z_StrVAL(token), Z_STRLEN(token), 1);
break; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT:
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), -1);
if (destroy)  ZVAL_NULL(&token); return_value;
add_next_index_stringl(keyword, Z_STRVAL(to), Z_STRLEN(token), 1);
add_next_index_stringl(keyword, Z_STRVAL(token), 0, Z_STRLEN(token), 1);
case T_ORPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE:
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: break;
case T_OK: case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO:
case T_WHITESPACE: case T_DOC_COMMENT: destroy = 1; break;
if (token_type == T_END_HEREDOC)  ZVAL_NULL(&token);
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1, 1);
add_next_index_stringl(keyword, ZSTRVAL(token), ZSTRLEN(token), 1);
else  add_next_index_stringl(keyword, Z_STRVAL(token));
add_next_index_stringl(keyword, (char *) zendtext, zendleng, 1);
if (destroy && Z_TYPE(token)) break;
MAKE_STD_ZVAL(keyword); array_init(keyword);
if (destroy)  ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_OPEN_TAG_WITH_ECHO: break;
else  ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_END_HEREDOC) return 0;
if (destroy && Z_TYPE(token)) ZVAL_NULL(&token);
if (destroy)  ZVAL_NULL(&token); break;
add_next_index_stringl(keyword, Z_STRVAL(token), 0, 0);
case T_OPTION: case T_OPTION: case T_OPTION:
add_next_index_stringl(keyword, Z_STRVAL(token), 1);
int token_line = 1; array_init(return_value);
if (token_type == T_NO_FOREACH)  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword
if (keyword == 0)  /* * Add some keywords to the next arg. */ add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_BLACKED:
case T_NOTYEVENT:
case T_SET_END:
else  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_EXTENDED:
if ((token_type = '>') && (token_type == '>'))  cp = '>'; cp = '0';
if (token_type == T_DOCUMENT_INCR)  if (g_value_to_target)  g_value_to_target = 0;  else  g_value_to_target = 0;
if (return_value!= NULL)  fprintf(stderr, "%s: %sn", __func__, result); return_value = 0;
if (token_type == T_INHERIT)  if (!token_type)   /* XXX XXX */ return_value;
else  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_OCOSE_TAG:
case T_INCRYPT: if (token_type == T_INDR_TTY)  CG(zend_lineno)++;
if (scr_ptr == NULL)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* FIXME: if XXX XXX */
if (token_type == T_DEBUG)  msgsg("TokenSuccess!n"); return_value;
if (token_type == T_ONLINE)  CG(zone_lineno)++;
case T_OPENSIBLE:
case T_NONE: case T_DOCUMENT:
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>')  CG(zend_lineno)++;  case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break;  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);  if (destroy && Z_TYPE(token))  if (zendtext[zendleng - 1]!= '>')  CG(zend_lineno)++;  case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break;  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_CONTINUE_EXIT: case T_STATIC_EXIT:
if (token_type == T_OPEN_TAG_WITH_ECHO)  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);  else  add_next_index
if (token_type == T_LEADER_ATTR_SYNC)  ZVAL_NULL(&token_value);
case T_UNSUPPORTED: case T_NONE: case T_UNSUPPORTED:
case T_FOREACH_SYNC: if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=')  if (zero)  if (token_type  0)  break;
else  if (token_type == T_DELAY_PROTO)  if (gdb_type == T_MODE_DELAY)  gdb_type = T_MULTIPLEX_TEXT; else  gdb_type = T_MODE_TEXT;  else  gdb_type = T_MULTIPLEX_TEXT;
case T_OC_TAG: case T_OPEN_TAG_WITH_ECHO:
case T_BPRINT_ERROR:
/* The result is not in the string state. */ if (keyword == '0')  delete(keyword); return_value;
if (keyword->zval_type!= T_CALL_TAG)  g_val(&token_value);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN)  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_TTY: case T_OPEN_TAG:
if (destroy && Z_TYPE(token))  ZVAL_NULL(&token); ZVAL_NULL(&token); return 0;
if (increment_lineno == 0)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (keyword == NULL)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR)  if (eouter_object == eouter_object)  nsCRT::free(keyword);  else  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC)  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);  else
case T_ADDR_TYPE:
case T_INTERFACE: case T_INTERFACE:
if (return_value) return_value;
case T_DISPLAY_TYPE:
case T_LIST_OPEN: case T_OPEN_TAG_WITH_ECHO:
case T_RETURN_ATTRIBUTE_NEXT:
if (keyword)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_WORD:
case T_FORCE: if (ttyld_lineno)  CG(ttyld_lineno)++;
/*
case T_OWN_TOKEN:
case T_SET_TO_FIRST: case T_SET_TO_INT: case T_SET_TO_FIRST: case T_SET_TO_FIRST: case T_SET_TO_INFRST: case T_SET_TO_FIRST: case T_SET_TO_FIRST: case T_SET_TO_INT: case T_SET_TO_NEXT:
if (token_type == T_END_HEREDOC)  if (return_value == NULL)  /* destroy should be the first zero */
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY)  if (token_type == T_RETURN_OUTPUT)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else  if (token_type == T_DESTR_ZVAL(token))  token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_REFERENCE_EMPTY)  ZVAL_NO_ARGS = ((int)token_type)->ts_type;  else  ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_LEAP_CHARSET)  if (zero)  ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT);  if (destroy && Z_TYPE(token))  if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG)  if (zero)  CG(zend_lineno)++;  else  CG(zend_lineno)++;  if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION)  CG(zend_lineno)++;   if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_WAKE_STD_ZVAL(keyword):
case T_NO_TAG: /* XXX */
if (token_type == T_DEBUG)  if (CG(increment_lineno))  token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_SUCCEEDED)  ZVAL_UNLOCK(&token_type); ZVAL_UNLOCK(&token_type);
case T_LEND_UP:
else  if (token_type == T_END_HEREDOC)  if (CG(increment_lineno))  token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);  else  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zero)  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0')  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);  else  add_n
case T_TOKEN: case T_TOKEN:
/* * If we cannot have a copy of the value we are looking for, but we're just going to re-add * the value from the symbol array. */
else  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno  0)  increment_lineno = 0;  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (!token_type) return;
case T_SINGLE: if (flags & FI_NONE)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_XBL_NO_TIMELINE:
case T_RETURN_ENABLE:
case T_RETURN_END:
return_value = token;
if (token_type == T_LEAGATE_NO_FLAG) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (destroy && Z_TYPE(token))  if (ksa.ksa_error)  ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
/* Remove the empty token */
case T_DUP_STRACE:
case T_BINDING: case T_DEBUG:
if (strcmp(keyword, "").Equals(">"))  if (strcmp(keyword, "").Equals("n"))  /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, "");  strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type == T_NO_DEBUG) && (token_type == T_DELETE))  int rv; ZVAL_NULL(&token);
if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG)  if (zval_index_init(&token_value))  if (destroy)  cdd_init(&token_value); return_value;
if (token_type == T_VENDOR_SETREFERENCE)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else  /* do not exit */ if (!zval_alloc(token_type))  /* have unblocking tokens, and re-enable  if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE)  /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE)  /* use the symbol for the tokens. */ ZVAL_NULL(&token_type);  else  /* * XXX */  else  /* XXX */ if (__FREE__(token_type) == Z_TRUE)  if (__FREE__(token_type) == Z_TRUE)  /* * This is the symbol for
else  /* Do not find out what to do */ if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* check if the index is in the target*/ if (token_type == T_OK)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_ENTRY_NO_TYPE)  ZVAL_NULL(&token);
case T_OP_TYPE:
case T_NODEBUG:
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break;  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));  else  add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET:
case T_UNSIGNED: case T_OBJECT:
if (token_type == T_SINGLE_LOCK)  if (zero!= '0')  cnt++;
case T_DTOR: if (zval_get_return_value(token) == 0)  if (next_type == T_DTOR_FREE)  return_value;
case T_OPEN_TAG: if (zendtext[zendleng - 1]!= '>')  ZVAL_NULL(&token);
if (token_type == T_EXT_DEBUG)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else  if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_MAKE_STD_ZVAL(keyword):
case T_THREAD_LOCK: case T_XFIX:
if (token_type >= 256)  MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_END_HEREDOC)  add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break;
case T_EX_EX_ENX:
case T_CONNECT: case T_OBJECT: case T_OBJECT:
case T_Drop: case T_Loop: case T_Wrap: case T_Loop: case T_Loop:
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHEEL:
case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break;
if (detroy) detroy = 0;
case T_WAKE_TAG: case T_WAKE_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break;
case T_XP_LOCK: case T_XP_NOT_COMMENT: case T_XP_NOT_COMMENT:

/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) <if (token_type 0) break;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; <else g_value_to_target = 0;
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; &else g_value_to_target = 0;
efree(Z_STRVAL(token));
&else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
&else
&else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) <if (token_type &0) break;
&else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; &else <g_value_to_target = 0;
else efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; <else g_value_to_target = 0;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) &if (zero!= '<0') cnt++;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (destroy) <ZVAL_NULL(&token);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
<else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) if (token_type <0) break;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else ZVAL_NULL(&token);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) &if (token_type 0) break;
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else <ZVAL_NULL(&token);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; <else <g_value_to_target = 0;
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (zero) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_INHERIT) if (!token_type) <</* XXX XXX */ return_value;
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else <if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
&else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) <if (token_type 0) break;
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
&else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else &ZVAL_NULL(&token);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
&else &add_next_index_stringl(keyword, Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_END_HEREDOC)
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
&else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else <ZVAL_NULL(&token);
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; else <ZVAL_NULL(&token); ZVAL_NULL(&token);
<else
<else &ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) <if (token_type &0) break;
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
<else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; &else &g_value_to_target = 0;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DEBUG) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
<else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; <else <g_value_to_target = 0;
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if ((token_type = '>') && (token_type == '>')) <cp = '>'; cp = '<0';
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* The result is not in the string state. */ if (keyword == '<0') &delete(keyword); return_value;
else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else ZVAL_NULL(&token);
if (destroy && Z_TYPE(token)) if (ksa.ksa_error) ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
<else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (keyword->zval_type!= T_CALL_TAG) g_val(&token_value);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; else &g_value_to_target = 0;
else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; else &g_value_to_target = 0;
&else &ZVAL_NULL(&token);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) <if (token_type &0) break;
<else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) <if (token_type 0) break;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; <else g_value_to_target = 0;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; &else &g_value_to_target = 0;
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
&else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; else ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) <if (destroy) &cdd_init(&token_value); return_value;
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) <if (token_type <0) break;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_END_HEREDOC) <if (return_value == NULL) /* destroy should be the first zero */
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else <if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
<else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; else &g_value_to_target = 0;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) &if (token_type &0) break;
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else &ZVAL_NULL(&token); ZVAL_NULL(&token);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) <if (token_type <0) break;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; <else &g_value_to_target = 0;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_FORCE: if (ttyld_lineno) &CG(ttyld_lineno)++;
if (token_type == T_INHERIT) <if (!token_type) &/* XXX XXX */ return_value;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
<else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else &/* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else <ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword);
/* The result is not in the string state. */ if (keyword == '0') delete(keyword); return_value;
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (increment_lineno == 0) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (keyword == NULL) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (return_value!= NULL) fprintf(stderr, "%s: %sn", __func__, result); return_value = 0;
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_END_HEREDOC) <if (return_value == NULL) &/* destroy should be the first zero */
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) &if (destroy) cdd_init(&token_value); return_value;
<else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; &else &g_value_to_target = 0;
&else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) &if (token_type 0) break;
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_END_HEREDOC) ZVAL_NULL(&token);
<else &if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
<else &efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_SUCCEEDED) ZVAL_UNLOCK(&token_type); ZVAL_UNLOCK(&token_type);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
&else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (keyword->zval_type!= T_CALL_TAG) &g_val(&token_value);
else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) <if (token_type <0) break;
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) if (token_type <0) break;
<else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) &if (destroy) &cdd_init(&token_value); return_value;
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else ZVAL_NULL(&token); ZVAL_NULL(&token);
else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
&else <if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
else <ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = '>') && (token_type == '>')) &cp = '>'; cp = '0';
<else ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEADER_ATTR_SYNC) &ZVAL_NULL(&token_value);
&else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else ZVAL_NULL(&token); ZVAL_NULL(&token);
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) if (token_type &0) break;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; else &ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else <if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
&else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_INHERIT) <if (!token_type) </* XXX XXX */ return_value;
&else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
&else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
return_value = 0;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_ONLINE) <CG(zone_lineno)++;
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_ENTRY_NO_TYPE) <ZVAL_NULL(&token);
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; <else <g_value_to_target = 0;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (destroy) &ZVAL_NULL(&token);
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) &if (token_type 0) break;
<else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) <if (destroy) cdd_init(&token_value); return_value;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_ONLINE) CG(zone_lineno)++;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) &if (destroy) cdd_init(&token_value); return_value;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) <if (token_type 0) break;
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else &if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_SUCCEEDED) <ZVAL_UNLOCK(&token_type); ZVAL_UNLOCK(&token_type);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; else g_value_to_target = 0;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; else &g_value_to_target = 0;
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) <if (destroy) cdd_init(&token_value); return_value;
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_DTOR: if (zval_get_return_value(token) == 0) &if (next_type == T_DTOR_FREE) &return_value;
<else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
<else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
&else ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
&else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zero) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (keyword == 0) &/* * Add some keywords to the next arg. */ add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else &ZVAL_NULL(&token);
&else <efree(Z_STRVAL(token));
&else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
&else <efree(Z_STRVAL(token));
<else <efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; else <g_value_to_target = 0;
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) &if (token_type 0) break;
if (token_type == T_DEBUG) <msgsg("TokenSuccess!<n"); return_value;
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; <else <g_value_to_target = 0;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
<else /* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (destroy && Z_TYPE(token)) ZVAL_NULL(&token);
<else /* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_SINGLE_LOCK) if (zero!= '&0') cnt++;
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; else <ZVAL_NULL(&token); ZVAL_NULL(&token);
if (destroy && Z_TYPE(token)) <if (ksa.ksa_error) <ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) if (token_type <0) break;
else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
&else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; else g_value_to_target = 0;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
&else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_FORCE: if (ttyld_lineno) CG(ttyld_lineno)++;
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (destroy && Z_TYPE(token)) if (ksa.ksa_error) <ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
&else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else <add_next_index_stringl(keyword, Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) &if (destroy) <cdd_init(&token_value); return_value;
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) <if (zero!= '<0') &cnt++;
<else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_DTOR: if (zval_get_return_value(token) == 0) if (next_type == T_DTOR_FREE) <return_value;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
&else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
<else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; <else <g_value_to_target = 0;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
&else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) &if (token_type 0) break;
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (keyword->zval_type!= T_CALL_TAG) <g_val(&token_value);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) if (token_type <0) break;
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; else &g_value_to_target = 0;
else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; else g_value_to_target = 0;
/* The result is not in the string state. */ if (keyword == '0') <delete(keyword); return_value;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) &if (destroy) cdd_init(&token_value); return_value;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) &if (token_type <0) break;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
&else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (destroy && Z_TYPE(token)) <if (ksa.ksa_error) ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
&else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (keyword == 0) </* * Add some keywords to the next arg. */ add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; <else &g_value_to_target = 0;
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_SINGLE_LOCK) if (zero!= '<0') cnt++;
if (token_type == T_SINGLE_LOCK) &if (zero!= '0') <cnt++;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
&else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
else &ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; <else g_value_to_target = 0;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <ZVAL_NULL(&token);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else <if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_EXT_DEBUG) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; <else g_value_to_target = 0;
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* The result is not in the string state. */ if (keyword == '&0') &delete(keyword); return_value;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
<else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; else <ZVAL_NULL(&token); ZVAL_NULL(&token);
else
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; else g_value_to_target = 0;
&else <add_next_index_stringl(keyword, Z_STRVAL(token));
&else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) if (destroy) <cdd_init(&token_value); return_value;
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) <if (zero!= '<0') cnt++;
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (scr_ptr == NULL) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_SUCCEEDED) &ZVAL_UNLOCK(&token_type); ZVAL_UNLOCK(&token_type);
else ZVAL_NULL(&token);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; else <g_value_to_target = 0;
<else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) if (destroy) cdd_init(&token_value); return_value;
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DEBUG) msgsg("TokenSuccess!&n"); return_value;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) &if (token_type &0) break;
if (token_type == T_END_HEREDOC) &if (return_value == NULL) /* destroy should be the first zero */
else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
<else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) <if (token_type 0) break;
<else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
&else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
&else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) &if (token_type &0) break;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
<else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) if (token_type 0) break;
&else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
&else </* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; &else &g_value_to_target = 0;
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
&else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
&else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else /* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_END_HEREDOC) if (return_value == NULL) &/* destroy should be the first zero */
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (destroy) <ZVAL_NULL(&token); break;
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; else g_value_to_target = 0;
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; else <g_value_to_target = 0;
&else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) if (token_type <0) break;
<else &add_next_index_stringl(keyword, Z_STRVAL(token));
<else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
&else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) &if (token_type &0) break;
if (keyword == NULL) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) <if (token_type &0) break;
else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
<else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; else &g_value_to_target = 0;
ZVAL_NULL(&token);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; &else &g_value_to_target = 0;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
&else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_INCRYPT: if (token_type == T_INDR_TTY) &CG(zend_lineno)++;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (destroy) <ZVAL_NULL(&token);
<else if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if ((token_type = '>') && (token_type == '>')) &cp = '>'; cp = '<0';
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_END_HEREDOC) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) if (token_type &0) break;
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) &if (token_type <0) break;
if (destroy) ZVAL_NULL(&token); break;
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (destroy && Z_TYPE(token)) <CG(zend_lineno)++;
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_INHERIT) &if (!token_type) &</* XXX XXX */ return_value;
else <if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* The result is not in the string state. */ if (keyword == '<0') delete(keyword); return_value;
else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if ((token_type = '>') && (token_type == '>')) <cp = '>'; cp = '&0';
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
else </* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) &if (token_type <0) break;
else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (destroy && Z_TYPE(token)) &if (ksa.ksa_error) ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else &ZVAL_NULL(&token); ZVAL_NULL(&token);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
<else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
&else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; &else &g_value_to_target = 0;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
<else if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) &if (destroy) &cdd_init(&token_value); return_value;
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_END_HEREDOC) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break;
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
<else /* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) <if (token_type 0) break;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) <if (destroy) <cdd_init(&token_value); return_value;
<else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
&else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
&else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
else </* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_DEBUG) <msgsg("TokenSuccess!n"); return_value;
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) if (token_type <0) break;
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_ENTRY_NO_TYPE) ZVAL_NULL(&token);
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_DEBUG) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) &if (token_type <0) break;
<else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) &if (token_type <0) break;
else ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_SINGLE_LOCK) if (zero!= '0') <cnt++;
&else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
&else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; <else g_value_to_target = 0;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; <else g_value_to_target = 0;
&else </* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (destroy) &ZVAL_NULL(&token); return_value;
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break;
else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_DTOR: if (zval_get_return_value(token) == 0) &if (next_type == T_DTOR_FREE) return_value;
else <if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; &else <g_value_to_target = 0;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; &else <g_value_to_target = 0;
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else &/* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type == T_NO_DEBUG) && (token_type == T_DELETE)) <int rv; ZVAL_NULL(&token);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_INHERIT) &if (!token_type) &/* XXX XXX */ return_value;
case T_DTOR: if (zval_get_return_value(token) == 0) <if (next_type == T_DTOR_FREE) return_value;
<else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
<else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else </* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) &if (token_type &0) break;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
&else </* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) &if (zero!= '&0') cnt++;
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<else </* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (return_value!= NULL) fprintf(stderr, "%s: %s&n", __func__, result); return_value = 0;
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_INHERIT) &if (!token_type) </* XXX XXX */ return_value;
<else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_DTOR: if (zval_get_return_value(token) == 0) if (next_type == T_DTOR_FREE) return_value;
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) <if (token_type <0) break;
if (destroy) ZVAL_NULL(&token); return_value;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &/* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_INHERIT) &if (!token_type) &&/* XXX XXX */ return_value;
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) if (token_type 0) break;
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; <else g_value_to_target = 0;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; <else &g_value_to_target = 0;
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
<else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; &else &g_value_to_target = 0;
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) &if (token_type <0) break;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
<else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
&else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
<else &efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) <if (token_type &0) break;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) &if (token_type 0) break;
else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_EXT_DEBUG) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else &/* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (return_value!= NULL) <fprintf(stderr, "%s: %s&n", __func__, result); return_value = 0;
&else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (destroy) &ZVAL_NULL(&token); ZVAL_NULL(&token);
else /* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; &else <g_value_to_target = 0;
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
&else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else ZVAL_NULL(&token); ZVAL_NULL(&token);
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_DEBUG) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; <else &g_value_to_target = 0;
else <efree(Z_STRVAL(token));
&else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
<else &/* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) if (zero!= '<0') &cnt++;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
&else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_INHERIT) if (!token_type) <&/* XXX XXX */ return_value;
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) if (token_type &0) break;
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_END_HEREDOC) &ZVAL_NULL(&token);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* The result is not in the string state. */ if (keyword == '<0') <delete(keyword); return_value;
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; &else <g_value_to_target = 0;
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else /* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) if (zero!= '&0') &cnt++;
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
<else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
else /* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) &if (token_type <0) break;
if (token_type == T_SINGLE_LOCK) &if (zero!= '0') cnt++;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_SINGLE_LOCK) if (zero!= '0') &cnt++;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; <else <g_value_to_target = 0;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; &else &g_value_to_target = 0;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_SINGLE_LOCK) <if (zero!= '0') <cnt++;
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
<else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else efree(Z_STRVAL(token));
if ((token_type = '>') && (token_type == '>')) cp = '>'; cp = '<0';
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; <else g_value_to_target = 0;
<else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
&else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_DEBUG) <msgsg("TokenSuccess!&n"); return_value;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; &else g_value_to_target = 0;
else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
&else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else <ZVAL_NULL(&token); ZVAL_NULL(&token);
<else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
&else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_LEADER_ATTR_SYNC) ZVAL_NULL(&token_value);
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; <else <g_value_to_target = 0;
&else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; <else &g_value_to_target = 0;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_INHERIT) if (!token_type) </* XXX XXX */ return_value;
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
&return_value;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
&else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) <if (token_type <0) break;
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) &if (token_type 0) break;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
else <if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; else <g_value_to_target = 0;
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
&else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) if (destroy) &cdd_init(&token_value); return_value;
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) if (destroy) cdd_init(&token_value); return_value;
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else &efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_SINGLE_LOCK) &if (zero!= '<0') &cnt++;
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; else &g_value_to_target = 0;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &ZVAL_NULL(&token);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DEBUG) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (keyword) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &ZVAL_NULL(&token);
if (destroy) <CG(zend_lineno)++;
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (zero) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; else &ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
&else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else &ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) if (token_type 0) break;
else ZVAL_NULL(&token);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; else &g_value_to_target = 0;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) &if (token_type 0) break;
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
<else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (destroy && Z_TYPE(token)) &if (ksa.ksa_error) <ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else add_next_index_stringl(keyword, Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_INHERIT) <if (!token_type) <&/* XXX XXX */ return_value;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_END_HEREDOC) &if (return_value == NULL) </* destroy should be the first zero */
if (token_type == T_LEADER_ATTR_SYNC) <ZVAL_NULL(&token_value);
else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; else <g_value_to_target = 0;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (destroy) &ZVAL_NULL(&token); break;
else &/* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_INHERIT) &if (!token_type) /* XXX XXX */ return_value;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) <if (token_type <0) break;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) if (token_type &0) break;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (return_value!= NULL) &fprintf(stderr, "%s: %s<n", __func__, result); return_value = 0;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (return_value!= NULL) <fprintf(stderr, "%s: %sn", __func__, result); return_value = 0;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else &/* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; else <g_value_to_target = 0;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) &if (destroy) <cdd_init(&token_value); return_value;
else <ZVAL_NULL(&token);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) <if (token_type 0) break;
if (keyword) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
&else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else <ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; &else <g_value_to_target = 0;
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
&else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_END_HEREDOC) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else /* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (destroy && Z_TYPE(token)) &ZVAL_NULL(&token); ZVAL_NULL(&token); return 0;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; &else g_value_to_target = 0;
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else <ZVAL_NULL(&token);
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else <ZVAL_NULL(&token); ZVAL_NULL(&token);
&else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* The result is not in the string state. */ if (keyword == '0') &delete(keyword); return_value;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; else g_value_to_target = 0;
else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; &else g_value_to_target = 0;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
&else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) if (token_type <0) break;
if (zero) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; else &g_value_to_target = 0;
else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) <if (token_type <0) break;
if (token_type == T_INHERIT) &if (!token_type) <&/* XXX XXX */ return_value;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
<else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; &else g_value_to_target = 0;
if ((token_type = '>') && (token_type == '>')) cp = '>'; cp = '&0';
else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
<else &ZVAL_NULL(&token);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
&else <ZVAL_NULL(&token); ZVAL_NULL(&token);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) <if (token_type &0) break;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) <if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
&else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (destroy && Z_TYPE(token)) &CG(zend_lineno)++;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
<else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_INHERIT) <if (!token_type) &&/* XXX XXX */ return_value;
case T_INCRYPT: if (token_type == T_INDR_TTY) <CG(zend_lineno)++;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DEBUG) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else &if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; else g_value_to_target = 0;
if (token_type == T_INHERIT) <if (!token_type) <</* XXX XXX */ return_value;
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) <if (token_type &0) break;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
else &add_next_index_stringl(keyword, Z_STRVAL(token));
<else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
<return_value;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) if (destroy) cdd_init(&token_value); return_value;
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; <else <ZVAL_NULL(&token); ZVAL_NULL(&token);
else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
&else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') ZVAL_NULL(&token);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) if (token_type &0) break;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) <if (destroy) <cdd_init(&token_value); return_value;
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else /* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&break;
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; <else &g_value_to_target = 0;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (destroy && Z_TYPE(token)) <ZVAL_NULL(&token); ZVAL_NULL(&token); return 0;
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') &if (zero) &if (token_type <0) break;
if (scr_ptr == NULL) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
<else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* check if the index is in the target*/ if (token_type == T_OK) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_DTOR: if (zval_get_return_value(token) == 0) <if (next_type == T_DTOR_FREE) <return_value;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
else &efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else /* Do not find out what to do */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_SINGLE_LOCK) <if (zero!= '<0') <cnt++;
<else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
<else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_END_HEREDOC) &if (return_value == NULL) &/* destroy should be the first zero */
else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; &else g_value_to_target = 0;
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_INHERIT) if (!token_type) &</* XXX XXX */ return_value;
&else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DEBUG) msgsg("TokenSuccess!n"); return_value;
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (return_value!= NULL) <fprintf(stderr, "%s: %s<n", __func__, result); return_value = 0;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_DTOR: if (zval_get_return_value(token) == 0) &if (next_type == T_DTOR_FREE) <return_value;
&else &efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) <if (zero!= '0') &cnt++;
if (destroy) ZVAL_NULL(&token);
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (keyword == 0) /* * Add some keywords to the next arg. */ add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
&else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_INCRYPT: if (token_type == T_INDR_TTY) CG(zend_lineno)++;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
<else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
&else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else &ZVAL_NULL(&token); ZVAL_NULL(&token);
return_value;
else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else <ZVAL_NULL(&token); ZVAL_NULL(&token);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (destroy && Z_TYPE(token)) <ZVAL_NULL(&token);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (destroy && Z_TYPE(token)) if (ksa.ksa_error) &ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (zero) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = '>') && (token_type == '>')) &cp = '>'; cp = '&0';
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_LEAP_CHARSET) &if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
&else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
&else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_DTOR: if (zval_get_return_value(token) == 0) if (next_type == T_DTOR_FREE) &return_value;
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break;
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) &if (destroy) &cdd_init(&token_value); return_value;
else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (destroy && Z_TYPE(token)) &ZVAL_NULL(&token);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) if (token_type 0) break;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_VENDOR_SETREFERENCE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) &if (destroy) <cdd_init(&token_value); return_value;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (destroy) ZVAL_NULL(&token);
<else <efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
&else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; &else <g_value_to_target = 0;
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
<else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<break;
<else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
<else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else <ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else &if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
<else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') if (zero) if (token_type 0) break;
<else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) <if (token_type 0) break;
<else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
else <ZVAL_NULL(&token);
else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
<else <if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
<else <if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_DEBUG) &msgsg("TokenSuccess!<n"); return_value;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else <efree(Z_STRVAL(token));
&else &ZVAL_NULL(&token); ZVAL_NULL(&token);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; <else &g_value_to_target = 0;
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) <nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) <if (token_type &0) break;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
else if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
else &if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; else &ZVAL_NULL(&token); ZVAL_NULL(&token);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (zero) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) <g_value_to_target = 0; else <g_value_to_target = 0;
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
if (token_type == T_DEBUG) msgsg("TokenSuccess!<n"); return_value;
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (destroy && Z_TYPE(token)) CG(zend_lineno)++;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_SINGLE_LOCK) <if (zero!= '&0') cnt++;
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) if (token_type 0) break;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_ONLINE) &CG(zone_lineno)++;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; &else <g_value_to_target = 0;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* The result is not in the string state. */ if (keyword == '&0') <delete(keyword); return_value;
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) <if (token_type <0) break;
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_VENDOR_SETREFERENCE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
return_value;
if (token_type == T_SINGLE_LOCK) <if (zero!= '0') cnt++;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) &nsCRT::free(keyword); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) <if (token_type 0) break;
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) nsCRT::free(keyword); &else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; &else <g_value_to_target = 0;
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
<else &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_EXT_DEBUG) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) if (token_type &0) break;
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_END_HEREDOC) if (return_value == NULL) </* destroy should be the first zero */
<else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zval_type == T_END_HEREDOC) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_SINGLE_LOCK) if (zero!= '0') cnt++;
<else &/* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = '>') && (token_type == '>')) <cp = '>'; cp = '0';
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else &ZVAL_NULL(&token); ZVAL_NULL(&token);
<else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) &nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_END_HEREDOC) <if (return_value == NULL) </* destroy should be the first zero */
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; &else g_value_to_target = 0;
case T_IATOMODE: if (increment_lineno 0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
else &/* Do not find out what to do */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (return_value!= NULL) &fprintf(stderr, "%s: %s&n", __func__, result); return_value = 0;
else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_DEBUG) &msgsg("TokenSuccess!&n"); return_value;
if (token_type == T_LEAP_CHARSET) &if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) <if (destroy) &cdd_init(&token_value); return_value;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_INHERIT) if (!token_type) /* XXX XXX */ return_value;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_INHERIT) &if (!token_type) <</* XXX XXX */ return_value;
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) &if (token_type &0) break;
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') &if (zero) if (token_type 0) break;
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; else g_value_to_target = 0;
&else if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_VENDOR_SETREFERENCE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (destroy && Z_TYPE(token)) &if (ksa.ksa_error) &ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
&else </* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_SINGLE_LOCK) &if (zero!= '0') &cnt++;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno 0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) nsCRT::free(keyword); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (destroy) &CG(zend_lineno)++;
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else </* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_SINGLE_LOCK) if (zero!= '<0') <cnt++;
if (token_type == T_INHERIT) <if (!token_type) /* XXX XXX */ return_value;
if (token_type == T_LEAP_CHARSET) &if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); <if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_SINGLE_LOCK) <if (zero!= '&0') <cnt++;
<else if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) <if (destroy) cdd_init(&token_value); return_value;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* check if the index is in the target*/ if (token_type == T_OK) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
<else &ZVAL_NULL(&token);
<else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
break;
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; else <g_value_to_target = 0;
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; <else &g_value_to_target = 0;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("<n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); &else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
<else &if (token_type == T_DESTR_ZVAL(token)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if ((token_type = '>') && (token_type == '>')) cp = '>'; cp = '0';
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (destroy) ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) &if (token_type &0) break;
&else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else &if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if ((token_type == T_NO_DEBUG) && (token_type == T_DELETE)) &int rv; ZVAL_NULL(&token);
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) if (destroy) <cdd_init(&token_value); return_value;
else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
<else <ZVAL_NULL(&token);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("&n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) <nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_REFERENCE_EMPTY) &ZVAL_NO_ARGS = ((int)token_type)->ts_type; else ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
&else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (destroy && Z_TYPE(token))
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
break;
&else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
&else <if (token_type == T_DESTR_ZVAL(token)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
&else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else /* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_NO_FOREACH) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) if (destroy) &cdd_init(&token_value); return_value;
if (token_type == T_SINGLE_LOCK) &if (zero!= '&0') <cnt++;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) if (token_type <0) break;
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) if (token_type <0) break;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("&n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (increment_lineno == 0) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_LEAP_CHARSET) <if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else /* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_LEAP_CHARSET) if (zero) &ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
<else <if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
<else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) &if (token_type <0) break;
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (destroy) <ZVAL_NULL(&token); return_value;
default:
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
&else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_LEAP_CHARSET) if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); &if (destroy && Z_TYPE(token)) &if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else &ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_SINGLE: if (flags & FI_NONE) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) <g_value_to_target = 0; <else <g_value_to_target = 0;
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) &g_value_to_target = 0; else <g_value_to_target = 0;
&else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else &/* do not exit */ if (!zval_alloc(token_type)) &/* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) g_value_to_target = 0; &else g_value_to_target = 0;
&else <if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
&else efree(Z_STRVAL(token));
&else efree(Z_STRVAL(token));
&else ZVAL_NULL(&token);
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
&else &if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (destroy) &ZVAL_NULL(&token);
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) &if (token_type &0) break;
if (token_type == T_SINGLE_LOCK) &if (zero!= '<0') <cnt++;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') <if (zero) if (token_type &0) break;
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_SINGLE_LOCK) if (zero!= '&0') <cnt++;
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zero && token_type == T_ERROR) if (eouter_object == eouter_object) <nsCRT::free(keyword); <else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
<else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (strcmp(keyword, "").Equals(">")) &if (strcmp(keyword, "").Equals("&n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) if (token_type 0) break;
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) if (token_type 0) break;
if (token_type == T_DEBUG) if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if ((token_type = lex_scan(&token TSRMLS_DC))!= '&0') &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else
case T_IATOMODE: if (increment_lineno <0) <increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
<else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_ENTRY_NO_TYPE) &ZVAL_NULL(&token);
else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else
/* * This enables the value to be called back before it is loaded */ if (flags) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_OPEN_TAG) <if (zval_index_init(&token_value)) <if (destroy) <cdd_init(&token_value); return_value;
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') <if (zero) if (token_type &0) break;
if (destroy && Z_TYPE(token)) <if (ksa.ksa_error) &ZVAL_NOT_FOUND(return_value, &ksa); return_value = 0;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
if (token_type == T_DEBUG) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (return_value!= NULL) fprintf(stderr, "%s: %s<n", __func__, result); return_value = 0;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
<else <if (token_type == T_END_HEREDOC) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_SINGLE_LOCK) &if (zero!= '&0') &cnt++;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (increment_lineno == 0) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (return_value!= NULL) &fprintf(stderr, "%s: %sn", __func__, result); return_value = 0;
case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break;
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) g_value_to_target = 0; <else &g_value_to_target = 0;
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_DTOR: if (zval_get_return_value(token) == 0) <if (next_type == T_DTOR_FREE) &return_value;
if (token_type == T_DEBUG) &msgsg("TokenSuccess!n"); return_value;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (destroy) CG(zend_lineno)++;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno <0) increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) if (destroy) <cdd_init(&token_value); return_value;
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) &if (token_type 0) break;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (destroy && Z_TYPE(token)) ZVAL_NULL(&token); ZVAL_NULL(&token); return 0;
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG) &if (zval_index_init(&token_value)) if (destroy) &cdd_init(&token_value); return_value;
else &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
&else &if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (token_type == T_NO_FOREACH) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
/* * Note that this hasn't changed the type. */ if (token_type &='' && token_type!= '=') if (zero) if (token_type &0) break;
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else &/* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable &if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (zero && token_type == T_ERROR) <if (eouter_object == eouter_object) &nsCRT::free(keyword); <else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') &if (zero) &if (token_type &0) break;
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_DEBUG) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
if (keyword) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_IATOMODE: if (increment_lineno 0) <increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (keyword == NULL) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_IATOMODE: if (increment_lineno &0) increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_INHERIT) <if (!token_type) &</* XXX XXX */ return_value;
case T_FORCE: if (ttyld_lineno) <CG(ttyld_lineno)++;
/* check if the index is in the target*/ if (token_type == T_OK) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else </* Do not find out what to do */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
else &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) &if (token_type == T_RETURN_OUTPUT) add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (zval_type == T_END_HEREDOC) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<else if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
&else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
else &if (token_type == T_DESTR_ZVAL(token)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
<else &if (token_type == T_DELAY_PROTO) &if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
else </* do not exit */ if (!zval_alloc(token_type)) </* have unblocking tokens, and re-enable if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
else efree(Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
case T_FOREACH_SYNC: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_FOREACH_SYNC: if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); strcmp(keyword, ""); strcmp(keyword, "");
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
/* * This enables the value to be called back before it is loaded */ if (flags) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
<else &if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) <gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (scr_ptr == NULL) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_END_HEREDOC) <ZVAL_NULL(&token);
case T_IATOMODE: if (increment_lineno <0) &increment_lineno = 0; &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (token_type == T_DEBUG) if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break;
else &if (token_type == T_END_HEREDOC) &if (CG(increment_lineno)) <token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
else <add_next_index_stringl(keyword, Z_STRVAL(token));
if ((token_type == T_NO_DEBUG) && (token_type == T_DELETE)) int rv; ZVAL_NULL(&token);
&else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else &/* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
if (token_type == T_OPEN_TAG_WITH_ECHO) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
case T_NO_SET_RETURN_ENTRY: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
<else if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) &if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else ZVAL_NULL(&token);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_END_HEREDOC) if (return_value == NULL) /* destroy should be the first zero */
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("<n")) </* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
/* * Note that this hasn't changed the type. */ if (token_type <='' && token_type!= '=') if (zero) <if (token_type <0) break;
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
&else </* do not exit */ if (!zval_alloc(token_type)) /* have unblocking tokens, and re-enable <if we are not in a state of unblocking tokens, don't * need to override the fmarks */ if (__FREE__(token_type) == Z_TRUE) /* get the first line for the keywords. */ if (__FREE__(token_type) == Z_TRUE) /* use the symbol for the tokens. */ ZVAL_NULL(&token_type); else /* * XXX */ else /* XXX */ if (__FREE__(token_type) == Z_TRUE) if (__FREE__(token_type) == Z_TRUE) /* * This is the symbol for
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (destroy) <ZVAL_NULL(&token); ZVAL_NULL(&token);
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) <if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (strcmp(keyword, "").Equals(">")) <if (strcmp(keyword, "").Equals("n")) /* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); &strcmp(keyword, ""); strcmp(keyword, "");
/* We only need to be re-opened. */ if (zval_flags & Z_FAB_TOKEN) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_NO_FOREACH) if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_REFERENCE_EMPTY) ZVAL_NO_ARGS = ((int)token_type)->ts_type; &else ZVAL_NULL(&token); ZVAL_NULL(&token);
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
&else if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_LEAP_CHARSET) if (zero) <ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) <if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (token_type == T_OPEN_TAG_WITH_ECHO) &if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
case T_SINGLE: if (flags & FI_NONE) <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
if (token_type == T_OPEN_TAG) if (zval_index_init(&token_value)) <if (destroy) &cdd_init(&token_value); return_value;
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
else add_next_index_stringl(keyword, Z_STRVAL(token));
if ((token_type = lex_scan(&token TSRMLS_DC))!= '0') &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (token_type == T_LEAP_CHARSET) <if (zero) ZVAL_INIT(&token_value, &keyword); ZVAL_INIT(&keyword, &keyword, 0, ZVAL_DEFAULT_COUNT); if (destroy && Z_TYPE(token)) if (zval_value && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TAG) if (zero) CG(zend_lineno)++; else CG(zend_lineno)++; if (destroy && ZVAL_N_TOKEN == ZVAL_TYPE_TYPE_TYPE_ENOMERATION) CG(zend_lineno)++; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
<else if (token_type == T_END_HEREDOC) <if (CG(increment_lineno)) &token_line = ++CG(zend_lineno); CG(increment_lineno) = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); add_next_index_zval(return_value
case T_IATOMODE: if (increment_lineno &0) &increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
<else <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type == T_NO_FOREACH) if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
/* The result is not in the string state. */ if (keyword == '&0') delete(keyword); return_value;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
case T_OK: case T_OPEN_TAG_WITH_ECHO: case T_DOC_COMMENT: destroy = 0; break; &if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; <case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') &CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') <CG(zend_lineno)++; case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
/* * Note that this hasn't changed the type. */ if (token_type ='' && token_type!= '=') <if (zero) <if (token_type &0) break;
/* * XXX avoid any '/* * Use "srv-e_token" instead. */ if (token_type == T_BUSY) if (token_type == T_RETURN_OUTPUT) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
if (token_type == T_OPEN_TAG_WITH_ECHO) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index
if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (strcmp(keyword, "").Equals(">")) if (strcmp(keyword, "").Equals("n")) &/* * If there is no token for this object, just a file to remove the symbol. */ strcmp(keyword, ""); <strcmp(keyword, ""); strcmp(keyword, "");
if (token_type == T_INHERIT) if (!token_type) &&/* XXX XXX */ return_value;
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) &g_value_to_target = 0; else g_value_to_target = 0;
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_SINGLE: if (flags & FI_NONE) &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(return_value, (char *)zendtext, zendleng, 1);
/* add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <if (destroy && Z_TYPE(token)) <if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; case T_OPEN_TAG: case T_OPEN_TAG_WITH_ECHO: case T_WHITESPACE: case T_DOC_COMMENT: destroy = 0; break; if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword
<else if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
if (zval_type == T_END_HEREDOC) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
else &if (token_type == T_DELAY_PROTO) <if (gdb_type == T_MODE_DELAY) &gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_NO_FOREACH) if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
<else <if (token_type == T_DELAY_PROTO) if (gdb_type == T_MODE_DELAY) gdb_type = T_MULTIPLEX_TEXT; else gdb_type = T_MODE_TEXT; else gdb_type = T_MULTIPLEX_TEXT;
if (token_type == T_REFERENCE_EMPTY) <ZVAL_NO_ARGS = ((int)token_type)->ts_type; else ZVAL_NULL(&token); ZVAL_NULL(&token);
if (zval_type == T_END_HEREDOC) <if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else <unk>
if (token_type == T_DOCUMENT_INCR) <if (g_value_to_target) &g_value_to_target = 0; &else g_value_to_target = 0;
else &add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1);
break; case T_OUT_OPEN_TAG: if (zendtext[zendleng - 1]!= '>') CG(zend_lineno)++; &case T_WHITESPACE: case T_COMMENT: case T_DOC_COMMENT: destroy = 0; break; <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_z
case T_IATOMODE: if (increment_lineno &0) <increment_lineno = 0; add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, zendtext, zendleng, 1);
if (zero) &if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); &add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword);
if (token_type == T_DOCUMENT_INCR) &if (g_value_to_target) g_value_to_target = 0; <else <g_value_to_target = 0;
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); <else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if ((token_type = lex_scan(&token TSRMLS_DC))!= '<0') <if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_n
if (zero && token_type == T_ERROR) &if (eouter_object == eouter_object) nsCRT::free(keyword); else <add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token));
else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
if (token_type == T_SINGLE_LOCK) <if (zero!= '&0') &cnt++;
if (token_type == T_INHERIT) if (!token_type) &/* XXX XXX */ return_value;
<else add_next_index_stringl(keyword, Z_STRVAL(token));
if (token_type == T_DOCUMENT_INCR) if (g_value_to_target) <g_value_to_target = 0; &else &g_value_to_target = 0;
if (token_type == T_NO_FOREACH) <if (token_type >= 256) MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword
case T_FOREACH_SYNC: if (token_type >= 256) &MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); &else &add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); <add_next_index_stringl(keyword, token_line); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword);
case T_NEAREST_ENABLE: /* * The following list has no value, so we're ignoring * the list of if they can be inspected before * * it's done *. */ if (token_type >= 256) <MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_stringl(keyword, Z_STRVAL(token), Z_STRLEN(token), 1); efree(Z_STRVAL(token)); <else <add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1); add_next_index_zval(return_value, keyword); else add_next_index_stringl(keyword, (char *)zendtext, zendleng, 1);
