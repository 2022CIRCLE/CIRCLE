golden:
size = htmlNodeDump(buf, docp, node); if (size >= 0) { mem = (xmlChar*) xmlBufferContent(buf); if (!mem) { RETVAL_FALSE; } else { RETVAL_STRINGL((const char*) mem, size, 1);}
inference:

htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf);
mem = xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, format);
return htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf);
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0);
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node);
mem = xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent (buf); if (!mem)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
mem = (xmlChar*) xmlBufferContent(buf); if (! mem)  RETVAL_FALSE;
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!result)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
mem = (xmlChar *) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem)
(void)htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
gNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (! mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar *) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (HTMLChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
buf = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, size); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)
(void)htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!rv)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 2, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlChar(buf); if (!mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return;
mem = (xmlChar*) xmlBufferContent(buf); if (mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)
printf("htmlNodeDumpFormatOutputn");
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! result)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
mem = (xmlChar*)xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, NULL, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return 0;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent (buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf);
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)
mem = xmlBufferContent(buf);
mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  return RETVAL_FALSE;
(void) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem);
htmlNodeDumpFormatOutput(buf, node, 0, format);
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  mem = (xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, str); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  retval = RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
return 0;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  mem = (xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)
buf = (xmlChar*) xmlBufferContent(buf); if (!buf)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem)
mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, &node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar)  RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  RETVAL_FALSE;
xmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, cp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *)xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, NULL, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
m = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!m)  RETVAL_FALSE;
ret = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!ret)  RETVAL_FALSE;
break;
htmlNodeDumpFormatOutput(buf, docp, node, 0, buflen); mem = (xmlChar*) buflen; if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlBufferContent(buf); if (!xmlBufferContent)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format);  mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
return;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! mem)  RETVAL_FALSE;
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, flags); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); mem = (xmlChar*) xmlBufferContent(buflen); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, nsnull, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) XMLBufferContent(buf); if (!mem)  RETVAL_FALSE;
xmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return NS_ERROR_FAILURE;
return NS_OK;
htmlNodeDumpFormatOutput(buf);
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(file); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem)  return RETVAL_FALSE;
htmlNodeDumpFormatOutput(pbuf, docp, node, 0, format); mem = (xmlChar*) pbufContent; if (!mem)  RETVAL_FALSE;
if (node)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*)xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, *format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*)  if (!xmlBufferContent(buf))  RETVAL_FALSE;
if (debug && xmlNodeDumpFormatOutput(buf, docp, node, 0, format))  XP_RELEASE(*ex);
if (buf == NULL)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if (file_len == 0)  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;  /*  end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0);  else  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (!buflen)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(buf), X_WARNING, "XXX: could not put at buf"); mem = (xmlChar*) xmlBufferContent(buf, X_WARNING, sizeof(buf), X_WARNING, (XXX *) xmlBufferContent(buf)); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, fb->flags); mem = (xmlChar*) xmlBufferContent(buf, fb->flags); if (!mem)  RETVAL_FALSE;
if (debug &&!debug)  /* XXX - we must't do this anyway? */
/* XXX: do not open this file in this directory */
if (mfile == NULL)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (node)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if (!zval)  RETVAL_FALSE;
if (!xmlBufferContent)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem)  RETVAL_FALSE;   else   /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, __FUNCTION__); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format)   /* XXX */ if (!rel)  retval = xmlBufferContent(buf); if (retval)  retval = xmlBufferContent(buf);  else  retval = xmlBufferContent(buf); if (retval == -1)  retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); htmlNodeDump(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf))  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return NS_ERROR_FAILURE;  else  /* Don't give anything to use */ if (! xmlBufferContent(buf))  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*)  RETVAL_FALSE;  else  /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL)  xmlBufferContent(buf, xmlBufferContent(buf));  if (!xmlChar*)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format)  if (!strcmp(buf, "xmlChar", &strcmp(buf)))  retval = retval;  else  retval = retval;
/* * For more information, use of "(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)  RETVAL_FALSE;  /* * XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd)  char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE)  return;  if (file_len == 0)  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;  /*  end dom_document_save_html_file */ if (buf_len == 0)  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (u_char*) xmlBufferContent(buf, &u_char)); if (!mem)  RETVAL_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (!mkdir(node))  /* Nodes can be found. */ if (!mkdir(node))  /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd);  else  /* get a buf, XXX */ if (file_len > 0)  htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   else  if ((strcmp(buf, "-t") == 0)  fprintf(stderr, "bad filetypen");  else  fprintf(stderr, "bad filetype");  fprintf(stderr, "bad filetype"); return;  fprintf(stderr, "bad filetype"); return;  fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(xmlChar)); mem = (xmlChar*) xmlBufferContent(buf, sizeof(xmlChar)); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem)  retval = retval;  else  /* don't get used to copy out all the files in xml.h */ if (retval == -1)  if ((xmlBufferContent))  retval = xmlBufferContent;   else  /* Do nothing to print out in xml.h */ if (retval!= -1)  retval = xmlBufferContent;  if (retval == -1)  retval = xmlBufferContent; if (retval == -1)  retval = xmlBufferContent;  if (retval == -1)  retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, NS_FORM_DEFAULT_VALUE); mem = (xmlChar*) xmlBufferContent(buf, &sym); if (!mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  /* XXX do it */ return;
if (!hdr->hdr_version)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if (!hdr->hdr_version)  RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format);  else  mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, format); if (!mem)  RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE)  HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   /* * This is just to be really useful. */ if (struct doc_propsptr doc_props)  /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, m); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); n = (xmlChar*) xmlBufferContent(buf); if (!n)  RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return;  if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return;  if (! xmlChar*)  RETVAL_FALSE;
if (!buf)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)  RETVAL_FALSE;  if ((flags & 0x3f)!= 0)  /* We can't parse */ if ((flags & 0x3f)!= 0)  /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf))  RETVAL_FALSE;  /* * Now */ if ((xmlChar*) xmlBufferContent(buf))  /* * Note: This doesn't happen now */ xmlBufferContent(buf);  else  /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*)  /* We've got a non-null buf */ if (xmlChar >= 0)  /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if (!intern->document)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if (!intern->document)   RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlBufferContent(buf);
if (xmlBufferContent)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return 0;  else  mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlCharLength); if (!(xmlCharLength & 0xFF))  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  if (bytes == -1)  return ERROR_FAILURE;  /* If we've got an error while reading it. */ if (!b)  retval = 0;  else  retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if ((*name = xmlBufferContent(buf)))  if (!name)  RETVAL_FALSE; return;  if ((*name = xmlBufferContent(buf)))  if ((*name = xmlBufferContent(buf)))  retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, PR_TRUE); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, NULL); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, aNode); if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, aNode))  return retval;
/* * Assume the following are the default nsIPrefs to work around this nsIPrefs. */ if (pseudo_get_type() == nsEHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_nsIHTMLTag_ns
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0')  /* It is the one that should be called from * '0' */ if (node->name)  if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format)))  return;   if (id == -1)  /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format);  if (id == -1)  /* XXX is a placeholder * name that should be handled. */ if (xmlChar*)  xmlBufferContent(buf); if (!xmlBufferContent(buf))  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar_String = xmlBufferContent(buf); if (!xmlChar_String)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, fsnull, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (XMLChar *) xmlBufferContent(buf)); if (!mem)  RETVAL_FALSE;
if (file_len == 0)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  return;  if (file_len == 0)  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;  DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE)  return;  if (file_len == 0)  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (xmlChar(&mem))  return 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar)  RETVAL_FALSE;   else  if (!xmlBufferContent(buf))  RETVAL_FALSE;
if (bool && (*bool) == 0)  htole32(buf, sizeof(buf), bool);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format);  else  mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); mem = (xmlChar*) xmlBufferContent(buf, len); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)  RETVAL_FALSE;  if (flags & FIX_DEVICE)  if (encoding && (num_mems == 0))  /* We can't do this because of XXX */ html_file_unlink(&file_len);  if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0)  html_set_class_name(node);   /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (strcmp(file, "%s", buf, xmlBufferContent, strcmp(format, buf, strlen(buf))) == 0)  xmlBufferContent.save_flags |= xmlBufferContent;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL)  nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return;  if (node->node == nsXUL_XUL_XUL)  nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL)  nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format);  else  nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format);  me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, aNode); mem = (xmlChar*) xmlBufferContent(buf, aNode); if (!mem)  RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file)  xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len);  else  xmlBufferContent(buf, buf_len);
if (!xmlBufferContent)  retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval)  retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  RETVAL_FALSE;    else  /* XXX - NodeDump */
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*)  RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1)  if (isspace_in_new_xml)  retval = 0; goto err;   else  mem = xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)  RETVAL_FALSE;
if (nsnull!= buf)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (flags & STYLE_FORMAT_OUTPUT)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  else
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1)  fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf)));  else  fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf));  if (!(fname & 0x8000))  RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1)  mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
/* * XXX do not truncate the xmlBuffer */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  RETVAL_FALSE;
if (fprintf)  HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem)  RETVAL_FALSE;  htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem)  LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if (ncsv)  char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE)  return;  if (file_len == 0)  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;  if (file_len == 0)  php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)  RETVAL_FALSE;  if ((cnt >= 1) && cnt = 0)  /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt  0)  cnt = cnt;  /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharSet(buf, &xmlCharSet); if (xmlCharSet && xmlBufferContent(buf, sizeof buf) == -1)  XML_REMOVE_HTMLAtom(buf, buf, NULL);
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG)))  if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG)  /* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message)  RETVAL_FALSE;   else  /* Get xmlChar* (buf = %s) */ if (!mem)  /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format);  else  /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (node)  /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); retval = (xmlChar*) xmlBufferContent(buf); if (retval!= 0)  RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  /* XXX */ if (flags & 1 || flags & 2 || flags & 2)  if (flags & 1)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (!buf)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!xmlBufferContent)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
/* xmlChar* a buf, as in doc_object - */ if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '0')  return retval;
if (!mh_unref)  mh_unref = mh_unref;
if (!node)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar *)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (format == -1)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (m_doc_file_t > 0)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  XMLElementFactory::Enumerate(input, xmlBufferContent, buf, sizeof(struct buf));
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   else  if (getThis() == NULL)  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); if ((nsnull!= buf) && (nsnull!= xmlBufferContent(buf)))  LOG(L_ERR, "xmlBufferContent failed");
/* * XXX fix the path to the next file */ xmlBufferContent(buf, xmlBufferContent); if (!xmlBufferContent)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!gfx_save_frames[i])  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, html_type); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, strlen(buf) - 1); if (!buf)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem)  RETVAL_FALSE;  if (ret == -1)  htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if (!encoding)  /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   else    if (__P(("--inline ") && __P("--inline") == -1)  __P(("--inline ") && __P("--inline") == -1)  __P(("--inline ") && __P("--inline") == -1)  __P(("--inline") && __P("--inline") == -1)
if (suffixes!= 0)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 1); mem = (xmlChar*) xmlBufferContent(buf, 1); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!mem)  retval = XMLUnix(buf, &xmlChar->max_buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, encoding, 0); if (!mimeType)  RETVAL_FALSE;
if (is_doc)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem)  retval = RETVAL_FALSE;  if (debug_debug)  LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf))  LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!xmlChar)  retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval)  retval = XMLErrorMessage("Unable to psyntax error");
if (tmpl)  HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;    /*
if (!xmlBufferContent(buf, NULL))  retval = RETVAL_FALSE;
if (!node)  if (xmlChar >= (caddr_t)("%s", caddr_t)xmlBufferContent);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format))  RETVAL_FALSE;  if (!gNodeDumpFormatOutput(buf, docp, node, 0, format))  /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format))  gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf, 0, &format); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlBufferContent); if (!buf)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &b) == 0; mem = (xmlChar*) xmlBufferContent(buf, &b); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   else  /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0)  if (bytes == -1)  HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");  if (file_len == 0)  HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL)  XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf))  RETVAL_FALSE;  if (!xmlBufferContent)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, nsCRT::strlen(format)); nsCRT::free(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (!xmlChar*)  xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!a_expect)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, hcr, hcr, hcr, hcr); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;    else  xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * Now we are a "cb" * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  else  /* XXX should not return error! */  if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO)  /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0, sizeof(xmlChar), 0, buflen); if (!mem)  RETVAL_FALSE;
/* XXX */ if (!employeef)  return 0;  else  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)  RETVAL_FALSE;   else  mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  /* xmlDocPtrn' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0')  if (*result)  res = xmlBufferContent(buf); if (!res)  RETVAL_FALSE;   else  res = xmlBufferContent(buf); if (res == '0')  res = xmlBufferContent(buf);   else  res = xmlBufferContent(buf); if (res)  res = xmlBufferContent(buf); if (res == '0')  res = xmlBufferContent(buf); if (res == '0')  res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, NULL); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*)   RETVAL_FALSE;
if (format == -1)  /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*)    else  /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If XXX does not implement HTML_NONE */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, -1); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &bytes); if (buf->xml_p &&!bytes)  HTML_UNLOCK(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharBufferContent(buf, 0, xmlCharBufferSize); if (!xmlCharBufferContent)  RETVAL_FALSE;
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of))  /* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode)  /* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype)  if (!abcdef->objtype)  return 0;  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
if (asm)  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   if (gDragEnable)  fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format);   else  /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf))  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  else  htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  if ((char *) mem)  retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, 0, 0); if (!mem)  RETVAL_FALSE;
if (xml_node == NULL)  HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;   else  HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); mem = (xmlChar*) xmlBufferContent(buflen); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString  /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr))  /* XXX should never happen here because */ if (caddr_t)  /* XXX should always be here because */ if (caddr_t)  if ((caddr_t)buf->caddr)  /* XXX should always be here because we do not have a new file */  else  /* XXX should be out of memory. */  /* XXX should return a null value. */   else  /* XXX should not be out of memory. */
if ((xmlChar*)buf->doctype == doctype)  HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;  else  HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;     if (!mem)  RETVAL_FALSE;  /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))  RETVAL_FALSE; return;  if (!cmp(m_reply, &reply, sizeof(reply)))  GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, htmlNode_input); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)  RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); m = (xmlChar*) xmlBufferContent(buf); if (!m)  RETVAL_FALSE;
if (buf == NULL)  if (bfile == '0')  return;  /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0)  /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen;   if (bfile->ctrlen == 0)  /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p))))  retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER)  if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER)  retval = (xmlChar*) xmlBufferContent; if (!retval)  RETVAL_FALSE;   if (!retval)  retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node)  as_node = xmlBufferContent; if (as_node == NULL)  return NS_ERROR_FAILURE;   if (!as_node)
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (fprintf) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of &"(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!xmlBufferContent) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(buf), X_WARNING, "XXX: could not put at buf"); mem = (xmlChar*) xmlBufferContent(buf, X_WARNING, sizeof(buf), X_WARNING, (XXX *) xmlBufferContent(buf)); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If XXX does not implement HTML_NONE */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
/* * For more information, use of <"(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, PR_TRUE); if (!mem) &RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlCharLength); if (!(xmlCharLength & 0xFF)) RETVAL_FALSE;
if (xmlBufferContent) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) <retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) &if (bfile == '&0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (mfile == NULL) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlBufferContent(buf); if (!xmlBufferContent) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a &xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (node) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<&else /* XXX */
if (is_doc) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE; /* * XXX */
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(xmlChar)); mem = (xmlChar*) xmlBufferContent(buf, sizeof(xmlChar)); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * Now we are a "cb" * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) &retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </*
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtr&n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<<else /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (buf == NULL) &if (bfile == '<0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, m); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!result) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &<else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (m_doc_file_t > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &&else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (buf == NULL) if (bfile == '&0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * For more information, use of "(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &<else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (m_doc_file_t > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <<else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, aNode); mem = (xmlChar*) xmlBufferContent(buf, aNode); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <if (!as_node)
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!encoding) /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &&else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; if (!xmlBufferContent) <RETVAL_FALSE;
m = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!m) <RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtr&n' &n'' */
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &&else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&<else /* XXX */
/* XXX */ if (!employeef) return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! mem) &RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else <retval = retval;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/*
/* XXX */ if (!employeef) &return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) &retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else
mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!zval) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!encoding) /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * Now we are a "cb" * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtrn' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) &if (!xmlBufferContent(buf)) <RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (is_doc) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtr&n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else retval = retval;
if (!node) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(pbuf, docp, node, 0, format); mem = (xmlChar*) pbufContent; if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else &retval = retval;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
if (buf == NULL) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; &if (ret == -1) htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtr<n' n'' */
mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &&if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else xmlBufferContent(buf);
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!encoding) </* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, buflen); mem = (xmlChar*) buflen; if (!mem) &RETVAL_FALSE;
/* * For more information, use of "(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <<else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <<else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (buf == NULL) &if (bfile == '<0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtrn' &n'' */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
/* * For more information, use of &"(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* * For more information, use of &"(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (!buflen) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtr&n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) if (!xmlBufferContent(buf)) &RETVAL_FALSE;
/* * For more information, use of "(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtr<n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else retval = retval;
if (!node) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * For more information, use of "(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) XMLBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (xmlBufferContent) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtr&n' n'' */
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (strcmp(file, "%s", buf, xmlBufferContent, strcmp(format, buf, strlen(buf))) == 0) xmlBufferContent.save_flags |= xmlBufferContent;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else xmlBufferContent(buf);
if (mfile == NULL) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <&else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '0') return retval;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlBufferContent(buf); if (!xmlBufferContent) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) &retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (is_doc) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '<0') return retval;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (buf == NULL) &if (bfile == '<0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, flags); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* XXX */ if (!employeef) &return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
(void)htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) &retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, fb->flags); mem = (xmlChar*) xmlBufferContent(buf, fb->flags); if (!mem) &RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (buf == NULL) if (bfile == '&0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (debug && xmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <XP_RELEASE(*ex);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* XXX */ if (!employeef) &return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (! mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!encoding) &/* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else xmlBufferContent(buf);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &<else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (buf == NULL) <if (bfile == '0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
&htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtr&n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else xmlBufferContent(buf, buf_len);
buf = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!zval) &RETVAL_FALSE;
if (m_doc_file_t > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <else mkdir('%s', e; node);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 1); mem = (xmlChar*) xmlBufferContent(buf, 1); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&/*
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!zval) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) &if (bfile == '0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
mem = xmlBufferContent(buf); if (!mem)
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
if (is_doc) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; <if (ret == -1) htmlGetMetaEncoding(docp);
/* XXX */ if (!employeef) <return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, str); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else retval = retval;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else
if (node) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
/* * For more information, use of &"(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (m_doc_file_t > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!zval) <RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <&else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; &if (!xmlBufferContent) &RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else &mkdir('%s', e; node);
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) &/* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) /* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &&if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * For more information, use of &"(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of &"(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (buf == NULL) <if (bfile == '<0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else xmlBufferContent(buf, buf_len);
if (mfile == NULL) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <&else <mkdir('%s', e; node);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else &retval = retval;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) &retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) &/* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * For more information, use of &"(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* XXX */ if (!employeef) <return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <&else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, NULL); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtr<n' n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &&else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (fprintf) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (bool && (*bool) == 0) &htole32(buf, sizeof(buf), bool);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * For more information, use of &"(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (node) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <&if (!as_node)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtr&n' &n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
/* * For more information, use of "(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (buf == NULL) <if (bfile == '&0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (node) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <<if (!as_node)
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
buf = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent (buf); if (!mem) &RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else xmlBufferContent(buf);
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of &"(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else <retval = retval;
/* * For more information, use of <"(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else xmlBufferContent(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!mem) retval = XMLUnix(buf, &xmlChar->max_buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent (buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) retval = RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) <retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!zval) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else <xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* XXX */ if (!employeef) <return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, fsnull, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <&if (!as_node)
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (buf == NULL) &if (bfile == '&0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (buf == NULL) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) </* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) /* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!zval) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; if (ret == -1) htmlGetMetaEncoding(docp);
/* * XXX fix the path to the next file */ xmlBufferContent(buf, xmlBufferContent); if (!xmlBufferContent) &RETVAL_FALSE;
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<&else /* XXX */
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!encoding) &/* XXX */
/* * For more information, use of &"(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (! mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (buf == NULL) <if (bfile == '&0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (buf == NULL) &if (bfile == '0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <&else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (debug &&!debug) /* XXX - we must't do this anyway? */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (m_doc_file_t > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; <if (ret == -1) <htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtr<n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (buf == NULL) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <else mkdir('%s', e; node);
/* * For more information, use of "(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* XXX */ if (!employeef) <return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <<else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) <retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else xmlBufferContent(buf);
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent (buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else xmlBufferContent(buf);
if (buf == NULL) <if (bfile == '&0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else <retval = retval;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (buf == NULL) <if (bfile == '0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (nsnull!= buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtrn' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlCharLength); if (!(xmlCharLength & 0xFF)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (strcmp(file, "%s", buf, xmlBufferContent, strcmp(format, buf, strlen(buf))) == 0) <xmlBufferContent.save_flags |= xmlBufferContent;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &&else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <&else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); mem = (xmlChar*) xmlBufferContent(buflen); if (!mem) &RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) XMLBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&/*
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if (buf == NULL) <if (bfile == '<0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (debug && xmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &XP_RELEASE(*ex);
/* XXX */ if (!employeef) &return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (buf == NULL) if (bfile == '&0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <&else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, aNode); mem = (xmlChar*) xmlBufferContent(buf, aNode); if (!mem) <RETVAL_FALSE;
if (!xmlChar) <retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = XMLErrorMessage("Unable to psyntax error");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
mem = (xmlChar*) xmlBufferContent(buf); if (! mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtr<n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, flags); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <if (!as_node)
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else <xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (file_len == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&&else /* XXX */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
if (file_len == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) if (bfile == '0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (nsnull!= buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; <if (!xmlBufferContent) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) <retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of <"(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &<if (!as_node)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtr<n' <n'' */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &bytes); if (buf->xml_p &&!bytes) &HTML_UNLOCK(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &b) == 0; mem = (xmlChar*) xmlBufferContent(buf, &b); if (!mem) &RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; &if (ret == -1) &htmlGetMetaEncoding(docp);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (buf == NULL) if (bfile == '0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 2, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else <xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &&else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, strlen(buf) - 1); if (!buf) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &</*
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &<else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf);
/* XXX */ if (!employeef) return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtr&n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; <if (ret == -1) htmlGetMetaEncoding(docp);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlChar(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!zval) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
xmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &bytes); if (buf->xml_p &&!bytes) <HTML_UNLOCK(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!encoding) </* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (file_len == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (flags & STYLE_FORMAT_OUTPUT) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* XXX */
if (format == -1) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &<else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <<else <mkdir('%s', e; node);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtr<n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * For more information, use of "(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtr&n' n'' */
if (buf == NULL) <if (bfile == '0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; &if (ret == -1) <htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &&if (!as_node)
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&&else /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtrn' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <<else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (bool && (*bool) == 0) htole32(buf, sizeof(buf), bool);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '&0') return retval;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!zval) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (buf == NULL) if (bfile == '0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/*
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
/* XXX */ if (!employeef) &return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (buf == NULL) if (bfile == '&0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else
if (buf == NULL) <if (bfile == '<0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else xmlBufferContent(buf);
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
buf = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) <RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <&else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* xmlChar* a buf, as in doc_object - */ if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &&else mkdir('%s', e; node);
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else retval = retval;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtr&n' <n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else
if (flags & STYLE_FORMAT_OUTPUT) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * For more information, use of "(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (HTMLChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&&else /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtrn' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; <if (ret == -1) &htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, encoding, 0); if (!mimeType) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (nsnull!= buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else <retval = retval;
if (mfile == NULL) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlChar(buf); if (!mem) &RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!encoding) /* XXX */
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* * For more information, use of "(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, buflen); mem = (xmlChar*) buflen; if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
<htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; if (ret == -1) &htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (file_len == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE; </* * XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&/*
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <<else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &<else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; if (!xmlBufferContent) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else xmlBufferContent(buf);
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <<else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (HTMLChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtr<n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <else /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) &retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(file); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&/*
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); htmlNodeDump(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else xmlBufferContent(buf);
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &<else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else <retval = retval;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); m = (xmlChar*) xmlBufferContent(buf); if (!m) <RETVAL_FALSE;
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! result) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (XMLChar *) xmlBufferContent(buf)); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtrn' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (m_doc_file_t > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtrn' <n'' */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtr<n' &n'' */
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <&else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else
if (node) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* * For more information, use of "(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharBufferContent(buf, 0, xmlCharBufferSize); if (!xmlCharBufferContent) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
gNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtr&n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &<else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) &return RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
/* XXX */ if (!employeef) <return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <<else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else
if (mfile == NULL) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, format); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <&if (!as_node)
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * For more information, use of &"(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (buf == NULL) <if (bfile == '0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * XXX do not truncate the xmlBuffer */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtr<n' <n'' */
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!a_expect) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!a_expect) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of "(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
mem = (xmlChar*) xmlBufferContent(buf); if (! mem) RETVAL_FALSE;
if (node) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <&else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (xmlBufferContent) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <return RETVAL_FALSE;
if (node) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (buf == NULL) &if (bfile == '&0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &&if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!zval) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) &retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlChar) retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = XMLErrorMessage("Unable to psyntax error");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &<if (!as_node)
if (buf == NULL) &if (bfile == '&0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, flags); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * XXX do not truncate the xmlBuffer */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* * For more information, use of "(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtrn' <n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * For more information, use of &"(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!encoding) /* XXX */
/* * For more information, use of <"(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * Now we are a "cb" * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, NULL, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtrn' n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) if (bfile == '<0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (node) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (nsnull!= buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!zval) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (xmlBufferContent) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE;
/* * For more information, use of &"(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* XXX */ if (!employeef) return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </*
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtr&n' n'' */
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <<else mkdir('%s', e; node);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!encoding) &/* XXX */
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, strlen(buf) - 1); if (!buf) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!encoding) /* XXX */
/* XXX */ if (!employeef) &return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; &if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (buf == NULL) if (bfile == '0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!encoding) </* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 2, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &<else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &&else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) &retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
/* XXX */ if (!employeef) return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; <if (ret == -1) &htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (buf == NULL) &if (bfile == '&0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (suffixes!= 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* * For more information, use of &"(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) &RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharSet(buf, &xmlCharSet); if (xmlCharSet && xmlBufferContent(buf, sizeof buf) == -1) XML_REMOVE_HTMLAtom(buf, buf, NULL);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, encoding, 0); if (!mimeType) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (nsnull!= buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <<if (!as_node)
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(pbuf, docp, node, 0, format); mem = (xmlChar*) pbufContent; if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &&else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) &retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of &"(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharSet(buf, &xmlCharSet); if (xmlCharSet && xmlBufferContent(buf, sizeof buf) == -1) &XML_REMOVE_HTMLAtom(buf, buf, NULL);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, size); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(buf), X_WARNING, "XXX: could not put at buf"); mem = (xmlChar*) xmlBufferContent(buf, X_WARNING, sizeof(buf), X_WARNING, (XXX *) xmlBufferContent(buf)); if (!mem) <RETVAL_FALSE;
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) &if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) </* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&else /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &<if (!as_node)
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
buf = (xmlChar*) xmlBufferContent(buf); if (!buf) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, buflen); mem = (xmlChar*) buflen; if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* XXX */ if (!employeef) &return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* XXX */ if (!employeef) &return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) &retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (buf == NULL) <if (bfile == '&0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else retval = retval;
if (file_len == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!encoding) &/* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
/* * For more information, use of &"(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 2, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &&else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <</*
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else xmlBufferContent(buf);
if (!node) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (u_char*) xmlBufferContent(buf, &u_char)); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
/* * For more information, use of "(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) <retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* XXX */ if (!employeef) <return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!node) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlCharLength); if (!(xmlCharLength & 0xFF)) <RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
/* * For more information, use of &"(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) /* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) </* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtr<n' <n'' */
/* XXX */ if (!employeef) <return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (!xmlChar*) <xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!encoding) /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 1); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <&else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <&else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* XXX */ if (!employeef) return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (buf == NULL) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; &if (ret == -1) &htmlGetMetaEncoding(docp);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtrn' &n'' */
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtr<n' <n'' */
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(file); if (!mem) <RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtr&n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!zval) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; if (!xmlBufferContent) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* * For more information, use of "(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; <if (ret == -1) <htmlGetMetaEncoding(docp);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<&else /* XXX */
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!xmlChar) retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = XMLErrorMessage("Unable to psyntax error");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &&if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, fsnull, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
/* * For more information, use of <"(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
mem = (xmlChar*) xmlBufferContent(buf); if (mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
(void)htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * For more information, use of <"(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else <retval = retval;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtrn' &n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) <RETVAL_FALSE;
if (buf == NULL) if (bfile == '&0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (HTMLChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <XMLElementFactory::Enumerate(input, xmlBufferContent, buf, sizeof(struct buf));
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else xmlBufferContent(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; &if (ret == -1) <htmlGetMetaEncoding(docp);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
m = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!m) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtr<n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
mem = (xmlChar*)xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) <return RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &&else if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* xmlChar* a buf, as in doc_object - */ if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE;
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&&else /* XXX */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
buf = (xmlChar*) xmlBufferContent(buf); if (!buf) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!node) &if (xmlChar >= (caddr_t)("%s", caddr_t)xmlBufferContent);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, NULL); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(xmlChar)); mem = (xmlChar*) xmlBufferContent(buf, sizeof(xmlChar)); if (!mem) RETVAL_FALSE;
/* * For more information, use of &"(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (HTMLChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (buf == NULL) &if (bfile == '0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * For more information, use of <"(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &else mkdir('%s', e; node);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!zval) &RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else
m = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!m) &RETVAL_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &else /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * For more information, use of <"(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else &xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtr<n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &retval = RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!mh_unref) mh_unref = mh_unref;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
gNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of "(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, 0, 0); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &&else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </*
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </*
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If XXX does not implement HTML_NONE */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharSet(buf, &xmlCharSet); if (xmlCharSet && xmlBufferContent(buf, sizeof buf) == -1) <XML_REMOVE_HTMLAtom(buf, buf, NULL);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &<else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, size); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &&else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &&else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, buflen); mem = (xmlChar*) buflen; if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &<if (!as_node)
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) &retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!mh_unref) <mh_unref = mh_unref;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, -1); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (node) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, cp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (file_len == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; <if (ret == -1) &htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
/* * XXX do not truncate the xmlBuffer */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (buf == NULL) &if (bfile == '0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (buf == NULL) &if (bfile == '<0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, html_type); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; if (!as_node)
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else &xmlBufferContent(buf, buf_len);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &<else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (format == -1) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; <if (!xmlBufferContent) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (format == -1) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &<else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE;
if (!xmlBufferContent) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (!buflen) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtrn' <n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (buf == NULL) &if (bfile == '<0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) &retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (!xmlChar*) &xmlBufferContent(buf);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '<0') &return retval;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else &retval = retval;
/* * For more information, use of <"(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
gNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!zval) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtr&n' <n'' */
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else
mem = (xmlChar*) xmlBufferContent(buf); if (! mem) <RETVAL_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else
if (is_doc) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
/* XXX */ if (!employeef) <return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else xmlBufferContent(buf);
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); m = (xmlChar*) xmlBufferContent(buf); if (!m) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (u_char*) xmlBufferContent(buf, &u_char)); if (!mem) &RETVAL_FALSE;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtr<n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else &retval = retval;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &<else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* XXX */
/* * For more information, use of "(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (buf == NULL) if (bfile == '<0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else retval = retval;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (debug &&!debug) </* XXX - we must't do this anyway? */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtr&n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &&else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) &retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, 0, 0); if (!mem) &RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (!node) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(buf), X_WARNING, "XXX: could not put at buf"); mem = (xmlChar*) xmlBufferContent(buf, X_WARNING, sizeof(buf), X_WARNING, (XXX *) xmlBufferContent(buf)); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <&else mkdir('%s', e; node);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else xmlBufferContent(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else xmlBufferContent(buf);
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 1); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else &retval = retval;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (buf == NULL) &if (bfile == '<0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * For more information, use of <"(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!mem) <retval = XMLUnix(buf, &xmlChar->max_buf);
htmlNodeDumpFormatOutput(buf, docp, node); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0); htmlNodeDump(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <if (!as_node)
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else &retval = retval;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &&else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE; /* * XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &<else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (node) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtr<n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of <"(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else xmlBufferContent(buf);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (strcmp(file, "%s", buf, xmlBufferContent, strcmp(format, buf, strlen(buf))) == 0) &xmlBufferContent.save_flags |= xmlBufferContent;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) &retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (buf == NULL) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (flags & STYLE_FORMAT_OUTPUT) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) <retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else xmlBufferContent(buf);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, htmlNode_input); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else xmlBufferContent(buf);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!mem) &retval = XMLUnix(buf, &xmlChar->max_buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!xmlBufferContent(buf, NULL)) &retval = RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlBufferContent); if (!buf) <RETVAL_FALSE;
mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* XXX */ if (!employeef) &return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
/* XXX */ if (!employeef) return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, *format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, size); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <&if (!as_node)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; <if (!xmlBufferContent) &RETVAL_FALSE;
if (!xmlBufferContent) &RETVAL_FALSE;
if (!xmlBufferContent) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtr&n' &n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else &retval = retval;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, NULL); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; <if (!xmlBufferContent) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtr&n' <n'' */
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; <if (ret == -1) <htmlGetMetaEncoding(docp);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <&else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
(void)htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* XXX */ if (!employeef) &return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else xmlBufferContent(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else &retval = retval;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) &retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else <retval = retval;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &<else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <&else mkdir('%s', e; node);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!xmlBufferContent) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE; /* * XXX */
/* XXX */ if (!employeef) &return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else
if (buf == NULL) <if (bfile == '<0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* * For more information, use of "(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); if ((nsnull!= buf) && (nsnull!= xmlBufferContent(buf))) LOG(L_ERR, "xmlBufferContent failed");
/* XXX */ if (!employeef) return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!encoding) &/* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (nsnull!= buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* * For more information, use of "(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else <retval = retval;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) <retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (m_doc_file_t > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!zval) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!a_expect) <RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; if (ret == -1) htmlGetMetaEncoding(docp);
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) &/* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) &/* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (fprintf) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, strlen(buf) - 1); if (!buf) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <&else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; if (!xmlBufferContent) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 1); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
<htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (buf == NULL) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) <retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (!buflen) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, encoding, 0); if (!mimeType) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtrn' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <&if (!as_node)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! mem) &RETVAL_FALSE;
/* * For more information, use of &"(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (buf == NULL) if (bfile == '&0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!encoding) &/* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <&else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &<else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <if (!as_node)
if (buf == NULL) if (bfile == '0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); n = (xmlChar*) xmlBufferContent(buf); if (!n) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /*
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; if (ret == -1) <htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &<else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, fb->flags); mem = (xmlChar*) xmlBufferContent(buf, fb->flags); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else xmlBufferContent(buf, buf_len);
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '&0') <return retval;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (file_len == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else xmlBufferContent(buf);
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &return RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * XXX fix the path to the next file */ xmlBufferContent(buf, xmlBufferContent); if (!xmlBufferContent) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <<else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & <2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <<else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, aNode); mem = (xmlChar*) xmlBufferContent(buf, aNode); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else &retval = retval;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); n = (xmlChar*) xmlBufferContent(buf); if (!n) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (m_doc_file_t > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, hcr, hcr, hcr, hcr); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&<else /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (buf == NULL) if (bfile == '0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &&else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, size); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else xmlBufferContent(buf);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!zval) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<else /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else xmlBufferContent(buf);
mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &bytes); if (buf->xml_p &&!bytes) HTML_UNLOCK(buf);
/* * For more information, use of <"(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!mh_unref) &mh_unref = mh_unref;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX do it */ return;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 1); mem = (xmlChar*) xmlBufferContent(buf, 1); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, 0, 0); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <<else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (suffixes!= 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; if (!as_node)
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, fsnull, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else
mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (buf == NULL) if (bfile == '<0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *)xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&&else /* XXX */
/* XXX */ if (!employeef) <return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtr<n' &n'' */
if (file_len == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtr&n' n'' */
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) </* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) &/* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <&else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* * For more information, use of "(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, __FUNCTION__); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else xmlBufferContent(buf);
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtr&n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* * For more information, use of "(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/*
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <<else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtrn' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <else mkdir('%s', e; node);
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; <if (!xmlBufferContent) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <&else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) XMLBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtr<n' &n'' */
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <</*
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!result) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! xmlChar*) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf, 0, &format); if (!mem) <RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, aNode); if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, aNode)) return retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; if (ret == -1) htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtrn' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <<else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!zval) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &&else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <<else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (buf == NULL) if (bfile == '0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* XXX */ if (!employeef) return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; <if (!xmlBufferContent) RETVAL_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) &/* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) </* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!xmlChar) &retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = XMLErrorMessage("Unable to psyntax error");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
/* * For more information, use of "(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <&else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* * For more information, use of <"(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) <retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!zval) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <&else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (format == -1) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &<else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<<else /* XXX */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) <retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent (buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else retval = retval;
/* * For more information, use of <"(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf, 0, &format); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (! mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent (buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &&else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else xmlBufferContent(buf, buf_len);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (suffixes!= 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtr&n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, size); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &<else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; &if (!xmlBufferContent) &RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; <if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <<else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *)xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &</* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!node) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else xmlBufferContent(buf);
/* XXX */ if (!employeef) &return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <&else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
xmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
xmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &<else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &b) == 0; mem = (xmlChar*) xmlBufferContent(buf, &b); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
buf = (xmlChar*) xmlBufferContent(buf); if (!buf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) <if (!xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent (buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
if (buf == NULL) &if (bfile == '0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (file_len == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtr<n' &n'' */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) &retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (HTMLChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); m = (xmlChar*) xmlBufferContent(buf); if (!m) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtrn' <n'' */
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlBufferContent); if (!buf) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (u_char*) xmlBufferContent(buf, &u_char)); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; if (!as_node)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else xmlBufferContent(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (fprintf) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <retval = RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '<0') <return retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtrn' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (buf == NULL) &if (bfile == '0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<&else /* XXX */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!gfx_save_frames[i]) &RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) <retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) &if (bfile == '<0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <&if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else <retval = retval;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else &xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else retval = retval;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of <"(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <else <mkdir('%s', e; node);
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) &if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) /* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtrn' &n'' */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '0') <return retval;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (nsnull!= buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 2, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &&else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (debug &&!debug) &/* XXX - we must't do this anyway? */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* XXX */ if (!employeef) return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
mem = (xmlChar*) xmlBufferContent(buf); if (! mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, aNode); if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, aNode)) &return retval;
if (buf == NULL) &if (bfile == '&0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; if (ret == -1) <htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, NULL); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &return RETVAL_FALSE;
printf("htmlNodeDumpFormatOutput<n");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else <retval = retval;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <&else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &if (!as_node)
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (! mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
mem = (xmlChar*) xmlBufferContent(buf); if (! mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <<else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, *format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* XXX */
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (xmlChar(&mem)) &return 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0;
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
printf("htmlNodeDumpFormatOutputn");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (xmlChar(&mem)) return 0;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <&else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!zval) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!xmlBufferContent) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
buf = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) RETVAL_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); retval = (xmlChar*) xmlBufferContent(buf); if (retval!= 0) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &if (!as_node)
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /*
/* XXX */ if (!employeef) &return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtr<n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&&else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &<else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) /* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) /* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &XMLElementFactory::Enumerate(input, xmlBufferContent, buf, sizeof(struct buf));
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, NULL); if (!mem) <RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) <retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (debug && xmlNodeDumpFormatOutput(buf, docp, node, 0, format)) XP_RELEASE(*ex);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <&else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); if ((nsnull!= buf) && (nsnull!= xmlBufferContent(buf))) <LOG(L_ERR, "xmlBufferContent failed");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&/*
if (nsnull!= buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE; &/* * XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; &if (ret == -1) htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
/* XXX */ if (!employeef) <return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; &if (!xmlBufferContent) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <<else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (!node) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlChar(buf); if (!mem) <RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
if (!buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else xmlBufferContent(buf);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <<else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!encoding) </* XXX */
if (format == -1) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /*
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETURN_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) <retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, NULL, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtrn' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else retval = retval;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (!node) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtrn' n'' */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, *format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (suffixes!= 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
gNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (suffixes!= 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); mem = (xmlChar*) xmlBufferContent(buf, 0, &format); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; if (!xmlBufferContent) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!rv) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!encoding) </* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) &RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0, sizeof(xmlChar), 0, buflen); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
/* * For more information, use of "(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, -1); if (!mem) RETVAL_FALSE;
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); retval = (xmlChar*) xmlBufferContent(buf); if (retval!= 0) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* XXX */ if (!employeef) &return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
/* * XXX fix the path to the next file */ xmlBufferContent(buf, xmlBufferContent); if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <<else &mkdir('%s', e; node);
if (fprintf) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if (m_doc_file_t > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!encoding) </* XXX */
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, NS_FORM_DEFAULT_VALUE); mem = (xmlChar*) xmlBufferContent(buf, &sym); if (!mem) RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (! mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) <RETVAL_FALSE;
buf = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return;
if (!xmlChar) <retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = XMLErrorMessage("Unable to psyntax error");
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </*
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) &RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, size); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
gNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else <retval = retval;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!zval) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; if (ret == -1) <htmlGetMetaEncoding(docp);
/* XXX */ if (!employeef) <return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* XXX */ if (!employeef) return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <&if (!as_node)
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (nsnull!= buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else &xmlBufferContent(buf, buf_len);
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) <if (bfile == '&0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0); htmlNodeDump(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; &if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtr&n' <n'' */
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; &if (!xmlBufferContent) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar_String = xmlBufferContent(buf); if (!xmlChar_String) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
mem = (xmlChar*)xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &<if (!as_node)
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 2, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; &if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else <xmlBufferContent(buf, buf_len);
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else &retval = retval;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, cp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf);
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &<else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, NS_FORM_DEFAULT_VALUE); mem = (xmlChar*) xmlBufferContent(buf, &sym); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) <if (bfile == '&0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <<else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <&else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &<else <mkdir('%s', e; node);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) <if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) /* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &<if (!as_node)
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!zval) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) <if (bfile == '0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &<else &mkdir('%s', e; node);
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&<else /* XXX */
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (suffixes!= 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!encoding) </* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <<else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
/* * For more information, use of <"(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (buf == NULL) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtr<n' n'' */
htmlNodeDumpFormatOutput(pbuf, docp, node, 0, format); mem = (xmlChar*) pbufContent; if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (node) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!zval) <RETVAL_FALSE;
/* * For more information, use of <"(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!encoding) </* XXX */
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, xmlBufferContent); if (!buf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0, sizeof(xmlChar), 0, buflen); if (!mem) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
mem = (xmlChar*) xmlBufferContent(buf); if (! mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <if (!as_node)
if (buf == NULL) &if (bfile == '<0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else <mkdir('%s', e; node);
if (buf == NULL) <if (bfile == '0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <<else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <<else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent(buf, NULL)) retval = RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtrn' &n'' */
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; &else &retval = retval;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
(void)htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (is_doc) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!xmlBufferContent) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE; &/* * XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* xmlDocPtr&n' n'' */
if (mfile == NULL) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <&else <mkdir('%s', e; node);
if (fprintf) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
/* XXX */ if (!employeef) <return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) <retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) <if (bfile == '<0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); mem = (xmlChar*) xmlBufferContent(buflen); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (flags & STYLE_FORMAT_OUTPUT) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE; </* * XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &<else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (is_doc) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <else <mkdir('%s', e; node);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &&else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /*
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a <xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * For more information, use of &"(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (format == -1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a &xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!zval) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
ret = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!ret) <RETVAL_FALSE;
/* * For more information, use of &"(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) if (bfile == '<0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (xmlBufferContent) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharBufferContent(buf, 0, xmlCharBufferSize); if (!xmlCharBufferContent) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* xmlChar* a buf, as in doc_object - */ if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; if (ret == -1) &htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, m); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, hcr, hcr, hcr, hcr); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <&else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) if (bfile == '<0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!zval) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a <xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, fb->flags); mem = (xmlChar*) xmlBufferContent(buf, fb->flags); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (HTMLChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else xmlBufferContent(buf);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else &xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar *) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* XXX */ if (!employeef) <return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; &if (ret == -1) &htmlGetMetaEncoding(docp);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else xmlBufferContent(buf);
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &</*
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /*
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) </* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) </* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &<else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, format); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!zval) RETVAL_FALSE;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) <retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of "(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &&if (!as_node)
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtrn' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtr<n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!gfx_save_frames[i]) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) &retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &<else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) retval = 0; goto err; &<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (mfile == NULL) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, aNode); if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, aNode)) <return retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) <retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; &if (!xmlBufferContent) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else
if (buf == NULL) <if (bfile == '<0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <&<else /* XXX */
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) &if (!xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else xmlBufferContent(buf);
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; <if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
ret = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!ret) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &&else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar_String = xmlBufferContent(buf); if (!xmlChar_String) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &&else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!encoding) /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); mem = (xmlChar*) xmlBufferContent(buflen); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <&if (!as_node)
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; &if (!xmlBufferContent) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
if (!xmlBufferContent(buf, NULL)) <retval = RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; &&else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &<else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of "(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & &1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtr&n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '0') &return retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') <if (*result) res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <<else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; <<if (!as_node)
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) &if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) &/* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <</*
if (buf == NULL) if (bfile == '<0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; &if (!xmlBufferContent) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) /* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (xmlBufferContent) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) <RETVAL_FALSE;
mem = (xmlChar*)xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (XMLChar *) xmlBufferContent(buf)); if (!mem) &RETVAL_FALSE;
if (!xmlBufferContent) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &</*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (buf == NULL) if (bfile == '<0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else <xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </*
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a &xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &&else mkdir('%s', e; node);
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') &/* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtrn' &n'' */
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (node) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (buf == NULL) if (bfile == '&0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (xmlChar(&mem)) <return 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; &&else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (flags & STYLE_FORMAT_OUTPUT) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); mem = (xmlChar*) xmlBufferContent(buf, len); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!encoding) /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & <2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!xmlChar) &retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = XMLErrorMessage("Unable to psyntax error");
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); retval = (xmlChar*) xmlBufferContent(buf); if (retval!= 0) RETVAL_FALSE;
printf("htmlNodeDumpFormatOutput&n");
/* XXX */ if (!employeef) return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! result) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, str); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '&0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * For more information, use of <"(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); mem = (xmlChar*) xmlBufferContent(buf, len); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & <2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<&else /* XXX */
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <<else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, buflen); mem = (xmlChar*) buflen; if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else <xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &file_len); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else &retval = retval;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
buf = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); n = (xmlChar*) xmlBufferContent(buf); if (!n) <RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, NULL, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else &xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, html_type); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &&else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
&htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <<else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (buf == NULL) if (bfile == '&0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <&else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (buf == NULL) &if (bfile == '<0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else
if (is_doc) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) &XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; <<else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlCharBufferContent(buf, 0, xmlCharBufferSize); if (!xmlCharBufferContent) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent (buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else
/* XXX */ if (!employeef) return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') </* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) <retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
if (buf == NULL) <if (bfile == '&0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * For more information, use of <"(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* XXX */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent (buf); if (!mem) &RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, cp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtr&n' <n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent (buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) <RETVAL_FALSE; <if (ret == -1) htmlGetMetaEncoding(docp);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, str); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if ((*name = xmlBufferContent(buf))) &if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) &retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) <LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!xmlChar) <retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = XMLErrorMessage("Unable to psyntax error");
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <<else <mkdir('%s', e; node);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, (XMLChar *) xmlBufferContent(buf)); if (!mem) <RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (format == -1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else <xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; <else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar *) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!zval) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else retval = retval;
if (buf == NULL) <if (bfile == '<0') <return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!rv) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* * For more information, use of <"(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* xmlDocPtrn' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) GET_SAVE_RETURN(result);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; <else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* XXX */
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & <1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
/* XXX */ if (!employeef) &return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) retval = RETVAL_FALSE; <if (debug_debug) &LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
/* * For more information, use of <"(.*)" and "(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; <<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else xmlBufferContent(buf);
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (format == -1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtr<n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) <if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) &/* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; if (!as_node)
if (fprintf) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if ((cnt >= 1) && cnt = 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtr&n' <n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*)xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (flags & STYLE_FORMAT_OUTPUT) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &else /* XXX */
if (suffixes!= 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (buf == NULL) <if (bfile == '0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; &else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<<else /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format))
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
if (format == -1) </* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) else /* XXX */
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else &xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <&else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) &/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX do it */ return;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else retval = retval;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &&else </* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) <RETVAL_FALSE; if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) retval = 0; goto err; else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If XXX does not implement HTML_NONE */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtr&n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (buf == NULL) &if (bfile == '&0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, NS_FORM_DEFAULT_VALUE); mem = (xmlChar*) xmlBufferContent(buf, &sym); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; else retval = retval;
if (buf == NULL) <if (bfile == '&0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtrn' &n'' */
if (!buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else /* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <</*
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (buf == NULL) <if (bfile == '0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&/* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof(xmlChar)); mem = (xmlChar*) xmlBufferContent(buf, sizeof(xmlChar)); if (!mem) <RETVAL_FALSE;
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else </* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE; </* * XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (suffixes!= 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; else <retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; &if (debug_debug) <LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &<else /* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (mfile == NULL) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') &if (*result) <res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &<if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!encoding) &/* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &&else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else &fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/* xmlDocPtr<n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <&else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf->m_uid!= -1) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) &retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of "(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!encoding) &/* XXX */
/* XXX */ if (!employeef) return 0; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!result) <RETVAL_FALSE;
if (fprintf) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!xmlBufferContent) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; &else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); &else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <&else &mkdir('%s', e; node);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &<else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) <XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (buf == NULL) if (bfile == '&0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if ((cnt >= 1) && cnt = 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 2, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else &/* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) <gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '&0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* * We have no way to encode the data (it's not known, since the value of a non-null char * would have been used to convert the file to a non-null * value of the value, so try to add it into an unsigned string * as a non-null value of the value of the value of the value of the value. */ if (!xmlChar == NULL) XMLElement* reg = xmlBufferContent; reg->res = reg->res->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg->reg
result = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! result) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETURN_FALSE;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & <1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) &res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* If we have a <xmlChar' on the output, this is a different case to look for the last one. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) <retval = 0; goto err; <else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (flags & STYLE_FORMAT_OUTPUT) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (buf == NULL) &if (bfile == '0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (buf == NULL) &if (bfile == '&0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!mkdir(node)) &/* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; if (ret == -1) &htmlGetMetaEncoding(docp);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; <else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, -1, format); if ((nsnull!= buf) && (nsnull!= xmlBufferContent(buf))) &LOG(L_ERR, "xmlBufferContent failed");
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &&else &mkdir('%s', e; node);
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(file); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) <return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of &"(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX why? */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; &else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
/* XXX */ if (!employeef) &return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <<else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (node) </* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) &if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (buf == NULL) <if (bfile == '0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <<else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &<else if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; <<else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) &GET_SAVE_RETURN(result);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; &&if (!as_node)
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) <retval = 0; goto err; <<else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; else if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; <if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <&else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!encoding) </* XXX */
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) &xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* xmlDocPtrn' n'' */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, html_type); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; else &/* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; &if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & 1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! mem) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
if (buf == NULL) <if (bfile == '<0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &<else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX do it */ return;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <&/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!node) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &<else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); <else </* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else xmlBufferContent(buf);
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent (buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, htmlNode_input); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </* xmlDocPtr&n' &n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &<else mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, NULL); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar_String = xmlBufferContent(buf); if (!xmlChar_String) &RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
if (is_doc) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
/* * For more information, use of &"(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <<else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (suffixes!= 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <&if (!as_node)
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) &xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else &xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) return NS_ERROR_FAILURE; <if (!as_node)
mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *)xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX */ if (!employeef) <return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &else <mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') &/* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, htmlNode_input); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') &if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) RETVAL_FALSE; &&else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; &else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s<n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); &else <xmlBufferContent(buf, buf_len);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <<else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &if (isspace_in_new_xml) &retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((xmlChar*)buf->doctype == doctype) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, m); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (format == -1) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX */ if (!employeef) return 0; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) RETVAL_FALSE; if (!retval) retval = 0;
/* * For more information, use of &"(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, &b) == 0; mem = (xmlChar*) xmlBufferContent(buf, &b); if (!mem) RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) <return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) &/* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) </* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) <res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 1); mem = (xmlChar*) xmlBufferContent(buf, 1); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) &/* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else &retval = retval;
if (xmlBufferContent) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else </* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; /* xmlDocPtr<n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; &<else &mkdir('%s', e; node);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; &if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
/* * For more information, use of <"(.*)" and &"(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <&else xmlBufferContent(buf);
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, PR_TRUE); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar *) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); if (!xmlChar*) xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <else <mkdir('%s', e; node);
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) else /* XXX */
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else &/* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (buf == NULL) if (bfile == '<0') return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; <<else mkdir('%s', e; node);
if (buf == NULL) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else &/* get a buf, XXX */ if (file_len > 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </* xmlDocPtr<n' n'' */
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) &retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &/* xmlDocPtr<n' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; &if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) /* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (bool && (*bool) == 0) <htole32(buf, sizeof(buf), bool);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!zval) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) &RETVAL_FALSE; &if (ret == -1) <htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) &RETVAL_FALSE; &&else &/* XXX should not happen if the file is readable */ /* XXX should be compiled */
/* * For more information, use of "(.*)" and &"(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) <retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) &retval = (xmlChar*) xmlBufferContent; if (!retval) <RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, __FUNCTION__); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <&else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; else /* XXX - NodeDump */
/* XXX */ if (!employeef) return 0; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 1, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (!buf) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & &2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &&else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; </*
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else xmlBufferContent(buf, buf_len);
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; <DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt &= 0) /* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &&<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) <return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* We're here for our spec and we're getting the spec. */ if (buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
if (xmlBufferContent) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else </* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!hdr->hdr_version) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (buf == NULL) &if (bfile == '0') return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & 2 || flags & <2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; &htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) <LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlBufferContent(buf); if (!xmlBufferContent) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; <&else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* * For more information, use of <"(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as &"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (buf == NULL) if (bfile == '0') <return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * For more information, use of &"(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <<else /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (!xmlChar) retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = XMLErrorMessage("Unable to psyntax error");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &/* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) <RETVAL_FALSE; <else </* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &/*
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* xmlChar*/ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /* xmlDocPtrn' n'' */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; if (!xmlBufferContent) &RETVAL_FALSE;
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; &&else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') <if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <&else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ac); if (!m_container_to_unicode(buf, nsCRT::strdup(m_container_to_unicode(p)))) retval = -1; /* not a DOM document */ if (flags & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) <if (m_container_to_unicode(flags) & DOM_DOC_AUTO_FLAG_IBUS_IN_ENCODER) retval = (xmlChar*) xmlBufferContent; if (!retval) &RETVAL_FALSE; if (!retval) retval = 0;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) /* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!hdr->hdr_version) <RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) <return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <</* XXX */ if (!rel) <retval = xmlBufferContent(buf); if (retval) &retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) </* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0;
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (! mem) <RETVAL_FALSE;
if (!hdr->hdr_version) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!hdr->hdr_version) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; <htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
if (format == -1) /* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<&else /* XXX */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; &if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (! xmlChar*) RETVAL_FALSE;
if (!xmlBufferContent) retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
/* XXX */ if (!employeef) &return 0; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; else </* Don't give anything to use */ if (! xmlBufferContent(buf)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; return; if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
/* * For more information, use of <"(.*)" and "(.*)" attributes and &"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (buf == NULL) <if (bfile == '&0') &return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &&else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
gNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') if (*result) &res = xmlBufferContent(buf); if (!res) &RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (format == -1) &/* Ignore the last parameter in HTML */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &<else /* XXX */
if (xml_node == NULL) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &&else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (XMLChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (xmlBufferContent) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) &RETVAL_FALSE; if (!xmlBufferContent) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; &else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); else <xmlBufferContent(buf, buf_len);
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; &else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!encoding) &/* XXX */
&htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (mAvailable == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) LOG_ERROR("malloc: out of memory");
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') /* It is the one that should be called from * '0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
ret = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!ret) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &&else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
if (flags & STYLE_FORMAT_OUTPUT) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (buf == NULL) &if (bfile == '&0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) &RETVAL_FALSE; <else &/* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); xmlChar *xmlBufferContent = xmlBufferContent(buf); if (xmlChar == '&0') &return retval;
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &/* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
/* XXX */ if (!employeef) &return 0; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) <if (!name) <RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) &if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); xmlChar *message = (xmlChar*) xmlBufferContent(buf, sizeof buf); if (!message) <RETVAL_FALSE; &else /* Get xmlChar* (buf = %s) */ if (!mem) /* XXX */ xmlChar *mbuf = (xmlChar*) xmlBufferContent(buf); if (!mbuf) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) </* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* * For more information, use of <"(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) XMLElementFactory::Enumerate(input, xmlBufferContent, buf, sizeof(struct buf));
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) <return 0; htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (buf == NULL) <if (bfile == '<0') return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
if (!xmlChar) &retval = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) &retval = XMLErrorMessage("Unable to psyntax error");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) <RETVAL_FALSE; &<else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; /* XXX */
/* XXX */ if (!employeef) &return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (asm) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
if ((*name = xmlBufferContent(buf))) <if (!name) RETVAL_FALSE; return; if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (buf == NULL) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') /* It is the one that should be called from * '0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, 0); mem = (xmlChar*) xmlBufferContent(buf, 0); if (!mem) RETVAL_FALSE; &/* * XXX */
/* * For more information, use of "(.*)" and "(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) <if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &<else
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) &retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar *) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (buf == NULL) if (bfile == '0') <return; </* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
/* * For more information, use of <"(.*)" and <"(.*)" attributes and <"(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* * For more information, use of &"(.*)" and <"(.*)" attributes and &"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
/* XXX */ if (!employeef) <return 0; <else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &if (!zval) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <&else if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
<htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &else /* XXX ignore XML's problems: "unknown XML file.n" */ if (file_len == 0) if (bytes == -1) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); if (file_len == 0) HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n"); HTML_ERROR("Can't get xml file.n");
if (!xmlBufferContent) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; else /* XXX - NodeDump */
if (xml_node == NULL) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &<else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <if (bytes == -1) &return ERROR_FAILURE; &/* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE; &<else <mkdir('%s', e; node);
if (node) &/* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; if (! xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
mem = (xmlChar*) xmlBufferContent(buf); if (mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) &/* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; <if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (! xmlChar*) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else </* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!buf) RETVAL_FALSE;
if (!xmlBufferContent) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!retval) <retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; else /* XXX - NodeDump */
if (asm) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, urlSpec); mem = (xmlChar*) xmlBufferContent(buf, urlSpec); if (!mem) <RETVAL_FALSE; htmlNodeDumpFormatOutput(buf, docp, node, 0, urlSpec); if (!mem) &LOG_ERROR("malloc: out of memory");
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((cnt >= 1) && cnt &= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (! mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) <if (!xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else <retval = retval;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '&0') /* It is the one that should be called from * '&0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; <if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) &LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; <&else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; &&else <mkdir('%s', e; node);
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %sn", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &if (ncsv) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
if (tmpl) HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; /*
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) &as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &if (!as_node)
if ((*name = xmlBufferContent(buf))) <if (!name) &RETVAL_FALSE; return; <if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) &retval = retval; <else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) if (!strcmp(buf, "xmlChar", &strcmp(buf))) &retval = retval; <else &retval = retval;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, mem); if (!mem) <retval = RETVAL_FALSE; if (debug_debug) LOG(L_ERR, "%s: htmlNodeDumpFormatOutput: %s", xmlChar(buf), xmlBufferContent(buf), mem); if (xmlChar(buf)) LOG(L_ERR, "%s: xmlBufferContent: %s", xmlBufferContent(buf), xmlBufferContent(buf), mem);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; </* XXX */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &if (bytes == -1) &return ERROR_FAILURE; /* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!hdr->hdr_version) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
if (fprintf) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!hdr->hdr_version) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!hdr->hdr_version) RETVAL_FALSE;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent (buf); if (!mem) <RETVAL_FALSE;
/* * We can't write the xml-free file. */ if (!struct xml_encoding_of(struct xml_encoding_of)) /* We have to find the xml_free file in case we can't add it to the server. */ if (node == xml_decode) &/* the unsigned long char* file is a string */ if ((node = xml_free) && (node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node->node
/* XXX */ if (!employeef) return 0; else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, PR_TRUE); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; &else <retval = retval;
HTNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ret); mem = (xmlChar*) xmlBufferContent(buf, ret); if (!mem) RETVAL_FALSE; &if (ret == -1) htmlGetMetaEncoding(docp);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (tmpl) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &&/*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '&0') <if (*result) res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
mem = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; &/* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE; </* * Now */ if ((xmlChar*) xmlBufferContent(buf)) /* * Note: This doesn't happen now */ xmlBufferContent(buf); <else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) &char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; &if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
/* XXX */ if (!employeef) &return 0; else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) as_node = xmlBufferContent; if (as_node == NULL) <return NS_ERROR_FAILURE; &&if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0); /* If this has already got a valid file, it's safe to copy out. */ if (!as_node) <as_node = xmlBufferContent; if (as_node == NULL) &return NS_ERROR_FAILURE; &&if (!as_node)
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); else &/* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & &2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar*) &RETVAL_FALSE; <else /* try to use this path for a file */ /* XXX */ if (htmlNodeDumpFileFormat(buf, docp, node, 0, format)!= NULL) <xmlBufferContent(buf, xmlBufferContent(buf)); if (!xmlChar*) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; &if ((flags & 0x3f)!= 0) /* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return; <if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &DOM_GET_OBJ(docp, id, xmlDocPtr, intern); char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_F
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, ncsv); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (ncsv) char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) return; if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; if (file_len == 0) php_error_docref(NULL TSRMLS_CC
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; &if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) </* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<else
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &&else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else &if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
if ((*name = xmlBufferContent(buf))) if (!name) RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) <if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) </* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & 1 || flags & 2 || flags & 2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else /* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
if (!buf) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & <1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (xml_node == NULL) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) &RETVAL_FALSE; <if (flags & FIX_DEVICE) if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX */ if (flags & &1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <if (!encoding) /* XXX */
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) <if (!abcdef->objtype) &return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
if (flags & STYLE_FORMAT_OUTPUT) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, -1); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) return RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) if (!abcdef->objtype) return 0; &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else </* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); mem = (xmlChar*) xmlBufferContent(buf, len); if (!mem) <RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else /* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
/* XXX no need to put this in a header at */ if (ctlr && ((ctlr->c_type == HTML_DISPLAY) && (ctlr->c_type == HTML_DISPLAY_MODEL_LONG))) if (ctlr->c_type == HTML_DISPLAY_MODEL_LONG) </* Allocate for this header here */ ctlr->c_type = HTML_DISPLAY_MODEL_LONG;
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') &/* It is the one that should be called from * '<0' */ if (node->name) &if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (!mkdir(node)) /* Nodes can be found. */ if (!mkdir(node)) /* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) <nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; if (node->node == nsXUL_XUL_XUL) <nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else </* XXX */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, __FUNCTION__); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString </* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) <RETVAL_FALSE; <&else <mkdir('%s', e; node);
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) <retval = 0; goto err; <&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, 0, sizeof(xmlChar), 0, buflen); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); &else &/* get a buf, XXX */ if (file_len > 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* * For more information, use of &"(.*)" and &"(.*)" attributes and <"(.*)" attributes are stored in the same file as "(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (!node) <if (xmlChar >= (caddr_t)("%s", caddr_t)xmlBufferContent);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) </* XXX */ if (flags & &1 || flags & 2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE; &else &if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, buflen); if (buflen == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; else if (__P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline ") && __P("--inline") == -1) __P(("--inline") && __P("--inline") == -1) <unk>
htmlNodeDumpFormatOutput(buf, docp, node, 0); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '<0') if (*result) &res = xmlBufferContent(buf); if (!res) RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) &RETVAL_FALSE; <<else &mkdir('%s', e; node);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return NS_ERROR_FAILURE; &else /* Don't give anything to use */ if (! xmlBufferContent(buf)) &RETVAL_FALSE;
/* Then, id is still written in this code, or the code has been passed in * the server. */ if (dom_document_save_html_file) <xmlBufferContent(buf, buf, 0, buf_len, bytes, buf_len, buf_len, nbuf_len); <else &xmlBufferContent(buf, buf_len);
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) </* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <if (!intern->document) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; if (!intern->document) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (buf == '0') &if (*result) <res = xmlBufferContent(buf); if (!res) <RETVAL_FALSE; else res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); else res = xmlBufferContent(buf); if (res) res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '0') res = xmlBufferContent(buf); if (res == '
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <RETVAL_FALSE; return; <if (!cmp(m_reply, &reply, sizeof(reply))) <GET_SAVE_RETURN(result);
if (asm) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <<if (gDragEnable) fprintf(stderr, "gDragEnable called for %sn", buf, buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) <RETVAL_FALSE; else <if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (xmlChar*) if (!xmlBufferContent(buf)) <RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* XXX */ if (flags & 1 || flags & &2 || flags & &2) if (flags & 1) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) &fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0); if (!gfx_save_frames[i]) <RETVAL_FALSE;
rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!rv) <RETVAL_FALSE;
/* * If the result is set in the docs and in the doc_props will contain a different set of values. */ if (abcdef && abcdef->objtype == doc_props->objtype) &if (!abcdef->objtype) return 0; <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) retval = retval; <else &retval = retval;
if ((xmlChar*)buf->doctype == doctype) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <else HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (!mem) RETVAL_FALSE; /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) </* * Note: This doesn't happen now */ xmlBufferContent(buf); else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else /* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) <if (!strcmp(buf, "xmlChar", &strcmp(buf))) <retval = retval; <else retval = retval;
htmlNodeDumpFormatOutput (buf, docp, node, 0, format); mem = (xmlChar *) xmlBufferContent (buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; <<else xmlBufferContent(buf);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return NS_ERROR_FAILURE; <else </* Don't give anything to use */ if (! xmlBufferContent(buf)) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) &RETVAL_FALSE; else if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* XXX We don't get this out of memory */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &/* XXX */
if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) RETVAL_FALSE; &if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &/* FIXME: Unknown. */ if (!gNodeDumpFormatOutput(buf, docp, node, 0, format)) &gNodeDumpFormatOutput(buf, docp, node, 0, format);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) </* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, hcr, hcr, hcr, hcr); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
if (!buf) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
/* if we haven't loaded this file, we don't want to do a cleanup, and the document will be able to read them in * the document. */ if (node->type == nsXUL_XUL) &nsXUL_XUL_COMPLETE::ToString(node->node, "complet"); return; <if (node->node == nsXUL_XUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); if (node->node == nsXUL_XUL) &nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); else nsXUL_COMPLETE::ConvertXULFormatOutput(buf, docp, node, 0, format); me
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '0') </* It is the one that should be called from * '<0' */ if (node->name) if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!(xmlChar*) xmlBufferContent(buf)) <RETVAL_FALSE; /* * Now */ if ((xmlChar*) xmlBufferContent(buf)) &/* * Note: This doesn't happen now */ xmlBufferContent(buf); &else /* * If xmlChar* is empty, just a format (empty) */ if (xmlChar*) /* We've got a non-null buf */ if (xmlChar >= 0) /* XXX */ xmlBufferContent(buf); /* XXX */ xmlBufferContent(buf); /* XXX */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) RETVAL_FALSE; <if ((cnt >= 1) && cnt <= 0) &/* * This is an error, but it is just a void * when creating a new file with cnt '0'. */ cnt = (cnt-1) xmlBufferContent(buf, &cnt); if (cnt 0) cnt = cnt; /* * If this is a void *, we will need to be sure we don't want to put this value. */ cnt = cnt; /* * If the '0' is in the '0', then we should be
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; &if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; </* end dom_document_save_html_file */
if (!mkdir(node)) </* Nodes can be found. */ if (!mkdir(node)) </* XXX */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) &php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString &/* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) /* XXX should never happen here because */ if (caddr_t) /* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
if (node) /* htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; &<else
if (buf == NULL) &if (bfile == '0') &return; /* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
/* * Don't copy over data-type for a file */ if (data_type == TYPE_INLINE) <HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; <</* * This is just to be really useful. */ if (struct doc_propsptr doc_props) /* * This is a common XMLProperty that we don't have a XMLProperty with an XMLProperty (i.e. XMLProperty, (xmlChar*) xmlBufferContent));
if ((*name = xmlBufferContent(buf))) if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) &return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) &retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) if (bytes == -1) <return ERROR_FAILURE; </* If we've got an error while reading it. */ if (!b) <retval = 0; else retval = HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; <if (file_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; &/* end dom_document_save_html_file */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) &if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
/* XXX node: it is a writable, but it doesn't belong here. */ if (buf!= '<0') </* It is the one that should be called from * '<0' */ if (node->name) <if (NS_FAILED(rv = htmlNodeDumpFormatOutput(buf, docp, node, 0, format))) return; if (id == -1) /* * XXX should use htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (id == -1) /* XXX is a placeholder * name that should be handled. */ if (xmlChar*) xmlBufferContent(buf); if (!xmlBufferContent(buf)) RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return; if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return; &if (! xmlChar*) RETVAL_FALSE;
if (tmpl) &HTMLNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; </*
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, sizeof buf); mem = (xmlChar*) xmlBufferContent(buf, &spl); if (!mem) RETVAL_FALSE; <else </* XXX should not happen if the file is readable */ /* XXX should be compiled */
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) return 0; else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); else /* get a buf, XXX */ if (file_len > 0) <htmlNodeDumpFormatOutput(buf, docp, node, 0, fd); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; else if ((strcmp(buf, "-t") == 0) fprintf(stderr, "bad filetypen"); else fprintf(stderr, "bad filetype"); fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype"); return; fprintf(stderr, "bad filetype");
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) if (isspace_in_new_xml) <retval = 0; goto err; &else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, len); /* XXX nsString /* XXX should be here since this isn't necessary. */ if (! ((caddr_t)buf->caddr) && (caddr_t)caddr->caddr)) </* XXX should never happen here because */ if (caddr_t) &/* XXX should always be here because */ if (caddr_t) &if ((caddr_t)buf->caddr) /* XXX should always be here because we do not have a new file */ else /* XXX should be out of memory. */ /* XXX should return a null value. */ else /* XXX should not be out of memory. */
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <<else &/* we don't have an doc_props, * but if we're done, don't return * anything */ if ((xmlChar*) xmlBufferContent(buf)) &RETVAL_FALSE;
if (! htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) /* XXX - just done here */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else &/* XXX should not return error! */ if (dom_document_save_html_file && dom_document_flags & DOM_FIXED_PROTO) /* XXX should not be here */ xmlChar = xmlBufferContent(buf); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!xmlChar) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) &&/* XXX */ if (!rel) &retval = xmlBufferContent(buf); if (retval) <retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
if (!node) if (xmlChar >= (caddr_t)("%s", caddr_t)xmlBufferContent);
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) &return 0; <else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); /* * If we're using a file, do it if we're using a file, which might happen on this device. */ mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE; else htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE; if ((char *) mem) retval_fin(buf);
mem = xmlBufferContent(buf); if (!mem) <RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0); xmlBufferContent(buf, xmlBufferContent(buf)); if (xmlBufferContent(buf)) RETVAL_FALSE; <if (!xmlBufferContent) <RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; <if (flags & FIX_DEVICE) <if (encoding && (num_mems == 0)) /* We can't do this because of XXX */ html_file_unlink(&file_len); if (struct html_file_unlink(&xml_file_unlink, &node, 0) == 0) html_set_class_name(node); /* The doc/class_name will be used in html_docs.csep, char *_name, _name);
if (mfile == NULL) <htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, &format); if (!format) </* XXX */ if (!rel) retval = xmlBufferContent(buf); if (retval) retval = xmlBufferContent(buf); else retval = xmlBufferContent(buf); if (retval == -1) retval = xmlBufferContent(buf);
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) &if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf, &mem); if (!mem) <RETVAL_FALSE; &if ((flags & 0x3f)!= 0) &/* We can't parse */ if ((flags & 0x3f)!= 0) /* If we could't parse */ htmlNodeDumpFormatOutput(buf, docp, node, 0, format); if (!mem) RETVAL_FALSE;
/* * XXX - no need to specify a htmlNodeDumpFormatOutput because we don't have an argument * -c or -c, because htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <if (isspace_in_new_xml) &retval = 0; goto err; &&else mem = xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, buflen); mem = (xmlChar*) buflen; if (!mem) RETVAL_FALSE;
/* * For more information, use of <"(.*)" and <"(.*)" attributes and "(.*)" attributes are stored in the same file as <"(.*)" attributes, and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes and "(.*)" attributes are stored in the same file as "(.*)" attributes is stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes are stored in the same file as "(.*)" attributes. This should be saved in the same file as "(.*)" attributes. */ if ((((.*))(.*))((((.
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); <else <mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if ((*name = xmlBufferContent(buf))) &if (!name) <RETVAL_FALSE; return; &if ((*name = xmlBufferContent(buf))) <if ((*name = xmlBufferContent(buf))) retval_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, 0); &else &htmlNodeDumpFormatOutput(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
htmlNodeDumpFormatOutput(file, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) RETVAL_FALSE;
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == -1) <fprintf(stderr, "%s: %s&n", fname, buf, xmlBufferContent(buf, sizeof(buf))); <else <fprintf(stderr, "%s: %sn", buf, xmlBufferContent(buf)); if (!(fname & 0x8000)) RETVAL_FALSE;
if (!htmlNodeDumpFormatOutput(buf, docp, node, 0, format)) <return 0; else &mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, format, 0, &mem); if (!mem) <retval = retval; else /* don't get used to copy out all the files in xml.h */ if (retval == -1) <if ((xmlBufferContent)) retval = xmlBufferContent; else /* Do nothing to print out in xml.h */ if (retval!= -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent; if (retval == -1) retval = xmlBufferContent
htmlNodeDumpFormatOutput(buf, docp, node, 0, encoding, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) <RETVAL_FALSE; &else <if (getThis() == NULL) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE;
htmlNodeDumpFormatOutput(buf, docp, node, 0, &cmd, format); if (cmd) <char *file; const char *encoding; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &id, dom_document_class_entry, &file, &file_len) == FAILURE) &return; if (file_len == 0) <php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE; /* end dom_document_save_html_file */ if (buf_len == 0) php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename"); RETURN_FALSE
if (htmlNodeDumpFormatOutput(buf, docp, node, 0, format) == 0) htmlNodeDumpFormatOutput(buf, docp, node, 0, format); &else mem = (xmlChar*) xmlBufferContent(buf); if (!mem) &RETVAL_FALSE;
if (buf == NULL) if (bfile == '<0') &return; &/* FIXME: this should have a non-include init mode, in which case we've got to do it here */ if (bfile->ctrlen == 0) /* FIXME: This should be a * undefined * buffer. */ bfile->ctrlen = bfile->ctrlen; if (bfile->ctrlen == 0) /* FIXME: The char */ nsCOMPtrnsIPref> prefs; prefs = &nsnull; prefs->nsIPref> prefs = &nsnull; prefs->nsIPref> prefs; prefs->nsIPref> prefs = &nsnull; prefs->nsIPre
