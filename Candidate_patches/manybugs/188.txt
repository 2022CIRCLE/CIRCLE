golden:
HashPosition pos; zend_rsrc_list_entry *regentry; ulong index = -1; /* intentional */ /* see if this persistent resource already has been loaded to the  * regular list; allowing the same resource in several entries in the  * regular list causes trouble (see bug #54623) */ zend_hash_internal_pointer_reset_ex(&EG(regular_list), &pos); while (zend_hash_get_current_data_ex(&EG(regular_list),     (void **)&regentry, &pos) == SUCCESS) {   if (regentry->ptr == le->ptr) {     zend_hash_get_current_key_ex(&EG(regular_list), NULL, NULL,       &index, 0, &pos);     break;   }   zend_hash_move_forward_ex(&EG(regular_list), &pos); }
inference:

#endif
return PHP_STREAM_PERSISTENT_FAILURE;
*stream = NULL;
return NULL;
return PHP_STREAM_PERSISTENT_SUCCESS;
*stream = (php_stream*)le->ptr;
return 0;
/* XXX */
splx(s);
return PHP_STREAM_PERSISTENT_OK;
return PHP_STREAM_PERSISTENT_EXIST;
return rsrc_id;
return PZ_STREAM_PERSISTENT_FAILURE;
le->refcount++;
return FALSE;
break;
Z_TYPE_P(le) == le_pstream;
return PZ_STREAM_PERSISTENT_SUCCESS;
*stream = (php_stream*) le->ptr;
return NS_OK;
nsresult rv;
return result;
/*
return PHP_STREAM_PERSISTENT_ERROR;
return this;
*stream = 0;
free(le->ptr);
return (NULL);
int i;
return PHP_STREAM_FAILURE;
POSTCODE(POSTCODE);
return -1;
return FAILURE;
return PHP_STREAM_PERSISTENT_INTERFACE;
return PHP_STREAM_PERSISTENT_READ;
return PR_FAILURE;
return PHP_STREAM_PerSISTENT_FAILURE;
PZ_UNLOCK_GIANT();
return PHP_STREAM_PERSISTENT_UNKNOWN;
exit(1);
@endif
free(le);
TSRMLS_DC;
continue;
return null;
return PHP_STREAM_PERSISTENT_ERR;
NS_ADDREF_THIS();
return PHP_STREAM_PERSISTENT_FUCCESS;
return *stream;
return PHP_STREAM_PERSISTENT_FINISHED;
return PHP_STREAM_PERSISTENT_FAILED;
return PHP_STREAM_PERSISTENT_NONE;
*stream = (ptr)->ptr;
/* NOTREACHED */
return PHP_STREAM_PERSISTENT_FIXED;
(*stream)->rsrc_id = NULL;
POSTCODE(POSTCODE_POST);
return PHP_STREAM_PERSISTENT_SUCCEEDED;
return ptr;
return PHP_STREAM_PERSISTENT_FOUND;
return EINVAL;
*stream = NULL; le->refcount++;
return (PZ_STREAM_PERSISTENT_FAILURE);
return PHP_STREAM_PERSISTENT_NULL;
return PHP_STREAM_PERSISTENT_TRUE;
/* * XXX */
return PHP_STREAM_PERSISTENT_STATUS;
return PHP_STREAM_SUCCESS;
(*stream)->refcount++;
return PHP_PERSISTENT_FAILURE;
TSRMLS_DC = NULL;
*stream = (*stream)->ptr;
return PHP_STREAM_PerSISTENT_SUCCESS;
return PHP_STREAM_PERSISTENT_EMPTY;
return PHP_STREAM_PERSISTENT_PAILURE;
int rsrc_id;
return PHP_STREAM_PERSISTENT_FULL;
return php_STREAM_PERSISTENT_FAILURE;
*/
PZ_LOCK_ASSERT();
Z_TYPE_P(le) == le_pstream
*stream = (php_stream*)len;
return PHP_STREAM_PERSISTENT_UNEXIST;
int id;
POSTCODE(pOSTCODE);
return PHP_STREAM_PERSISTENT_VALUE;
return PHP_STREAM_PERSISTENT_INIT;
return PHP_STREAM_PERSISTENT_INTERVAL;
else  *stream = NULL;
return PHP_STREAM_PERSISTENT_FLAGS;
return PHP_STREAM_PERSISTENT_DEAD;
return PHP_STREAM_PERSISTENT_UNAVAILABLE;
return PHP_STREAM_PERSISTENT_SAILURE;
return PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FEATURE;
return PHP_STREAM_NOT_EXIST;
return PHP_STREAM_PERSISTENT_REMOVE;
return PHP_STREAM_PERSISTENT_TAILURE;
return PHP_STREAM_PERSISTENT_FUNCTION;
*stream = (php_stream*)l_pstream;
return PHP_STREAM_PERSISTENT_ILLEGAL;
return PHP_STREAM_PERSISTENT_LOCK;
return PHP_STREAM_PERSISTENT_ADDRESS;
rsrc_id = NULL;
return PHP_STREAM_PERSISTENT_DELETE;
return PZ_PERSISTENT_FAILURE;
NS_ADDREF(*stream);
errno = 0;
return PHP_STREAM_PERSISTENT_FETCH;
return PHP_STREAM_PERSISTENT_WRITE;
return PHP_STREAM_PERSISTENT_RUNNING;
return PHP_STREAM_PERSISTENT_INVALID;
return PHP_STREAM_NONE;
(void*) &le;
return (PZ_STREAM_PERSISTENT_SUCCESS);
else
*stream = (*stream)->rsrc_id;
return PHP_STREAM_PERSISTENT_ACCESS;
return PHP_STREAM_PERSISTENT_IF_FAILURE;
return NULL;  return NULL;
#ifdef DEBUG
PZ_UNLOCK(le);
return PHP_STREAM_PERSISTENT_ABORT;
return PHP_STREAM_OK;
*stream = (ptr_t)le->ptr;
return PHP_STREAM_PERSISTENT_DEBUG;
return PHP_STREAM_PERSISTENT_WAIT;
return PHP_STREAM_PERSISTENT_OBJECT;
return PHP_STREAM_PERSISTENT_INITIALIZED;
return PHP_STREAM_PERSISTENT_AFAILURE;
return PHP_STREAM_PERSISTENT_NEXT;
return PHP_STREAM_PERSISTENT_UNLOCK;
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0)  *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;
if (debug) errx(1, "%s: not availablen", __func__);
if (!in_persist)  /* XXX */
if (persistent_id && (persistent_id  (int) 0))  ptr = && (persistent_id  (int) 0); if (persistent_id)  ptr = && (persistent_id  (int) 0);  if (ptr == NULL)  if (ptr == NULL)  ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (keg!= NULL)  if (keg->ptr == NULL)  if (keg->rsrc_id == NULL)  if (keg->ptr->ptr->ptr->ptr->rsrc_id)  /* FIXME: ERROR when the ptr was "reg_t" is zero */  /* FIXME: ERROR when the ptr is "reg_t" is null */  /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */  if (F_STREAM_PERSISTENT_ERR)  if (F_STREAM_PERSISTENT_ERR)  return f_struct / * ZEND_READ_ERR;     if (F_STREAM_PERSISTENT_ERR)
if (le->ptr)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr)  ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_INVALID;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0)  *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;
/* We can't free it out for the sake of symbol. */ if (NS_SUCCEEDED(rsrc_id)) return rsrc_id;
/* XXX: sage: b_kernel_release();
return nsAutoString::String::String(&m_id, le_pstream);
else if (L_KEY_PERSISTENT_NULL == 0)  /* not possible in /* NOTABLE */
if (cache_has_key(&cache_again_key))  if (Z_TYPE_P(cache_again_key) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
/* FIXME: php_stream_from_persistent_id is a problem */
if (zdb_req)  if (l__func__ == __func__)  if (l__func__ == __func__)  if (zdb_req->__func__ == __func__)  if (zdb_req->__func__ == __func__)  if (zdb_req->__func__ == __func__)  if (zdb_req->__func__ == __func__)  if (zdb_req->__func__ == __func__)  if (zdb_req->__func__ == __func__)  if (zdb_req->__func__ == __func__)  if (zdb_req->__func__ == __func
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id)  /* XXX */ if (rsrc_id)  if ((nsCRT::strlen(rsrc_id))  0)  rsrc_id = 0;
/* If re-initialized, we return re-initialized. */
if (!(le->flags & ZP_PROTO))  /* XXX: */ if (prt_flags & ZP_PROTO)  /* XXX: */ if (!prt_flags)  /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE;  if (!prt_flags) return Prt_FAILURE;  /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0)  /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0)  /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0)
if (!(l->refcount == 0))  return NULL;
return (PZ_STREAM_PERSISTENT_EXIST);
/* * If it's the id, we can't set it so that the name is not valid (unknown) */ if (!((cnt = 0) || (cnt > 0))) return NULL;
if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_UNAVAILURE;
return PHP_STREAM_PERSISTENT_UNSUCCESS;
/* We must also reload the PQ_FOREACH_REGISTER_RESOURCE from the process */
/* XXX :: To get the stream from this code, a std::string_for_data */ if (STA_STA_DATA("ptr").equals(Ptr))  return Ptr();
if (z_type_P(le) == x)  if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream)  if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke))  if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id)  ke->ke_id = ke->ke_id;   else  ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (len > 0)  if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0)  *stream = (PLength*)len;
/* Get the next id */ if (ap_id == '-')  ap_id = NULL; ap_id = ZEND_REGISTER_RESOURCE(NULL, ap_id, ap_id); return ap_id;
if (!cache_defaults)  return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le))  if (len)  *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply))  if (ptr)  /* XXX */ if (zsrc_next == NULL)  /* XXX */ if (ptr->flags & XXX)  /* XXX */  /* XXX */ if (ptr->flags & XXX)  /* XXX */  if (Z_TYPE_P(ptr->flags) == le_pstream)  /* * The nsnull case */  /* XXX */  else  /* * The nsnull case */  /* * In case it is not
if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;
/* get this thread so that the thread is not ready */ if (!l_pstream)  /* get a thread for free threads */ l_pstream = '0';
return PZ_STREAM_PERSISTENT_FUNCTION;
/* * We can't have to * look at the entry, so we do not need to set it here, * just if the entry is not on the queue. */
if (syslog_check_user(entry)) return PHP_STREAM_PERSISTENT_SUCCESS;
*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);
/* The '"' option */
else  if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_SUCCESS;
if (!len) return PZ_STREAM_NULL_ENCODING;
if (ptr && Z_TYPE_P(ptr) == le_pstream)  if (stream)  *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;
/* * EXISTS -> EXISTS */
if (ptr == '0')  if (ptr->ptr == '0')  ptr = '0';  else  ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS)  if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI)  /* The static level to be rsrc_id is non-NULL. */ if (me->refcount  0)  if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed)  if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream)  if (ptr->ptr == le_pstream)  ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_tx_is_zero)  return ZEXT_P(le);
return ZEND_STREAM_PERSISTENT_INTERFACE;
return PL_HASH_REGISTER_RESOURCE(NULL, *stream, le_pstream);
return ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);
if (keg == NULL)  /* * Allocate the cpu as well as * the kernel of the CPU */ if (!keg) return KEG_ISOCF_UNUSED;
if (disable_disable_disabled) return PHP_STREAM_PERSISTENT_FAILURE;
if (cnt++ == NULL)  return PHP_STREAM_PERSISTENT_UNKNOWN;
if (rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))  return PHP_STREAM_PERSISTENT_FAILURE;
/* * The fpc_type, this type is valid. */ if ((!ptr) && ptr->flags & ZF_BUSY)  ptr = (Ptr) ptr->ptr; if ((ptr = ptr->ptr) || (ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, ptr->ptr, le_pstream))) return ptr; return ptr;
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream)))  return PZ_STREAM_PERSISTENT_SUCCESS;  return PZ_STREAM_PERSISTENT_FAILURE;
/* * There are no buffers for the current stream. */ /* * Get a list of resources for rsrc */ while (rsrc == NULL)  rsrc = rsrc->rsrc; rsrc = rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc
/* the thread we need to write to. */ if (me->refcount == 0)  if (le->refcount == 0)  if (len == le_pstream)  if (len == -1)  *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);   return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (PL_sync_rsrc_id == NULL)  /* No more -P, 'P' will be an int */ if (!P_sync_res)  return NULL;
return (null!= rsrc_id);
return err;
*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);
/* FIXME: this must be a test for all. */ if ((flags & FT_FAILURE) == 0) return (PHYS_PERSISTENT_FAILURE);
if (persistent_id == NULL)  if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;
if (!(*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream)) return NULL;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0')  if (__USE_PLATFORM(PLATFORM_FILE__) == '0')  /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')  /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')  /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0'))  if (__USE_PLATFORM(PLATFORM_FILE__) == '0')
if (mStreamListener)  mStreamListener->update_type((void*) mStreamListener);
return PZ_PERSISTENT_SUCCESS;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!len)  return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the first slot in the current buffer. */ if ((isin(caddr_addr, (void*)&le->ptr))!= NULL)  if (isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, &le->ptr)) &&!isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL,
if (! &in_pstream)  return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked)  if (ztb_unlocked)  if (ztb_unlocked)  if (ztb_unlocked)  if (ztb_unlocked)  if (ztb_unlocked)  *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_UNLOCK;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_UNLOCK;  return PHP_STREAM_PERSISTENT_UNLOCK;
if (*stream)  *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_OK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0)  if ((nsnull!= ptr) && (nsnull == ptr))  /* don't let's call ptr: a ptr */ ptr = ptr;  if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr))  ptr = ptr; ptr->ptr = ptr->ptr;
return pksrc_id;
if (le->refcount++ > 0)  /* XXX should not occur here */ return NS_OK;
return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_NEXT_EXIST;
/* The following is not allowed in a CALLback in case the underlying struct isn't in the stream */ if (!prototype) return PHP_STREAM_PERSISTENT_SUCCESS;
/* FIXME: Is this an IGFile? */
if (dbgp) dbgp = &dbgp;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL))  if ((n = get_key_save(")) == NULL)  return (0);  else  return (-1);
if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type)  if (keg->keg_type == keg->keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type == keg_type)  if (keg->keg_type ==
if (le->debuglevel >= level)  if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level))  *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!(PL_strlen("http: if (le->strlen == 0))  PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen(""))))  PL_strlen("http: PL_strlen("http:
if (le->flags & TSRMLS_DUMP)  if (strlen(len)  1)  if (z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FEAILURE;
if (*stream == NULL)  /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * Ignore all undefined groups. */ if (zs_key(ns_key))  if (zs_key(ns_key))  if (zs_key(ns_key))  if (zs_key(ns_key))  if (zs_key(ns_key))  if (zs_key(ns_key) == 0)  if (zs_key(ns_key) == 0)  if (zs_key(ns_key) == 0)  if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags)  if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
if (strlen((ptrlen(prog)) - 1) == 0) return ptr;
/* * See if the stream is freed. */ if (t == '0') return 0;
/* XXX it's not a txt but it's an int or a length */
if (le->id!= 0)  if (!(*stream)->rsrc_id) return EINVAL; return (EINVAL);
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
else  /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return rsrc_id;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_NAME;
*stream = (struct tl_stream*)le->ptr;
return cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read(cvs_read))))) && (cvs_read(cvs_read(cvs_read(cvs_read(cvs_read))) == 0) || cvs_read(cvs_read(cvs_read(cvs_read(cvs_read)))))) && (cvs_read(cvs_read(cvs_read)) == 0)) && (cvs_read
if (!need_next)  return nsCRT::strdup(nsnull, "");
if (le->name)  if (PZ_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
return __FAILURE;
/* check for invalid /dups */ if (ptr->ptr_type == TYPE_F_FILE)  /* XXX */
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td)  if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr))  if (!HTTP_STATIC(le->ptr))  if (Z_TYPE_P(le) == td)  if (Z_TYPE_P(le) == td)  if (P(le->ptr) && Z_TYPE_P(le->ptr) == td)  if (Z_TYPE_P(le) == td)  if (*stream)  *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length)  int i; n = (*n)&n; if (n  (*n))  if (n == 0)  *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS;   if (n == NULL)  *n = (void*)n; n = n;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream)  if (stream)  *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;
if (!__feature__) return FALSE;
return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0)  if (Z_TYPE_P(flags) == le_pstream)  if (stream)  *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_SUCCESS;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSISTENT_FAILURE;  return PHP_STREAM_PERSIST
return (PSM_CANCEL_PERSISTENT_FAILURE);

if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); <else <return (-1);
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr == '<0') &if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr == '&0') <if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); else <return (-1);
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* The '&"' option */
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); &else &return (-1);
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
<else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
return PHP_STREAM_PERSISTENT_DEAD;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
return PHP_STREAM_FAILURE;
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cnt++ == NULL) &return PHP_STREAM_PERSISTENT_UNKNOWN;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (cnt++ == NULL) return PHP_STREAM_PERSISTENT_UNKNOWN;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (z_type_P(le) == x) if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') &if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* Get the next id */ if (ap_id == '-') &ap_id = NULL; ap_id = ZEND_REGISTER_RESOURCE(NULL, ap_id, ap_id); return ap_id;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
return PHP_STREAM_PERSISTENT_FETCH;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); else return (-1);
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
/* get this thread so that the thread is not ready */ if (!l_pstream) &/* get a thread for free threads */ l_pstream = '0';
if (ptr == '0') &if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->refcount++ > 0) &/* XXX should not occur here */ return NS_OK;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr == '&0') if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ptr == '<0') if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
#endif
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') &if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<else
return PHP_STREAM_PERSISTENT_AFAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(PL_strlen("http: if (le->strlen == 0)) &PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) PL_strlen("http: PL_strlen("http:
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); else return (-1);
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); <else &return (-1);
return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NEXT_EXIST;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return EINVAL;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
return NULL;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ptr == '&0') &if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
return PHP_STREAM_PERSISTENT_STATUS;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr == '&0') &if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); <else &return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); &else return (-1);
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
&else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') <if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* get this thread so that the thread is not ready */ if (!l_pstream) </* get a thread for free threads */ l_pstream = '&0';
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
&return 0;
return PHP_STREAM_PerSISTENT_SUCCESS;
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (z_type_P(le) == x) <if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) <if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
&else *stream = NULL;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (ptr == '&0') <if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
if (ptr == '0') if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FLAGS;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FEATURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); &else return (-1);
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* XXX :: To get the stream from this code, a std::string_for_data */ if (STA_STA_DATA("ptr").equals(Ptr)) &return Ptr();
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
&return PHP_STREAM_PERSISTENT_FAILURE;
/* * The fpc_type, this type is valid. */ if ((!ptr) && ptr->flags & ZF_BUSY) <ptr = (Ptr) ptr->ptr; if ((ptr = ptr->ptr) || (ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, ptr->ptr, le_pstream))) return ptr; return ptr;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (z_type_P(le) == x) &if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) <if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
&else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!(l->refcount == 0)) <return NULL;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); else <return (-1);
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (PL_sync_rsrc_id == NULL) /* No more -P, 'P' will be an int */ if (!P_sync_res) &return NULL;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); &else &return (-1);
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
&#endif
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr == '<0') <if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* XXX */
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
return PL_HASH_REGISTER_RESOURCE(NULL, *stream, le_pstream);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); else &return (-1);
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
<return NULL;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* get this thread so that the thread is not ready */ if (!l_pstream) /* get a thread for free threads */ l_pstream = '0';
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); <else <return (-1);
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); else <return (-1);
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); &else &return (-1);
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
else if (L_KEY_PERSISTENT_NULL == 0) </* not possible in /* NOTABLE */
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg == NULL) </* * Allocate the cpu as well as * the kernel of the CPU */ if (!keg) return KEG_ISOCF_UNUSED;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!len) <return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!in_persist) &/* XXX */
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_WRITE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<else &*stream = NULL;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
&else if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (ptr == '0') <if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
return PHP_STREAM_PERSISTENT_OBJECT;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
else *stream = NULL;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); &else &return (-1);
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ptr == '0') <if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * See if the stream is freed. */ if (t == '&0') return 0;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ptr == '&0') if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); &else <return (-1);
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream)) &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
&else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (ptr == '<0') <if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); <else <return (-1);
return PERSISTENT_FAILURE;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
&else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
return PHP_STREAM_PERSISTENT_OK;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_tx_is_zero) return ZEXT_P(le);
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* XXX: sage: b_kernel_release();
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!(PL_strlen("http: if (le->strlen == 0)) <PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) <PL_strlen("http: PL_strlen("http:
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (!in_persist) /* XXX */
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
<else if (L_KEY_PERSISTENT_NULL == 0) &/* not possible in /* NOTABLE */
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_SUCCESS;
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); else return (-1);
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
return PHP_STREAM_PERSISTENT_INTERVAL;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); else return (-1);
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * See if the stream is freed. */ if (t == '<0') return 0;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream)) return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') &if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
<else <if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!in_persist) </* XXX */
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
<return 0;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (ptr == '&0') <if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); else <return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); &else return (-1);
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
if (z_type_P(le) == x) &if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) &if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); else return (-1);
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_ERROR;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Find the first slot in the current buffer. */ if ((isin(caddr_addr, (void*)&le->ptr))!= NULL) &if (isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, &le->ptr)) &&!isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL,
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
else
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
<else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
/* get this thread so that the thread is not ready */ if (!l_pstream) &/* get a thread for free threads */ l_pstream = '<0';
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * There are no buffers for the current stream. */ /* * Get a list of resources for rsrc */ while (rsrc == NULL) &rsrc = rsrc->rsrc; rsrc = rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc
return FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
if (ptr == '0') if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (PL_sync_rsrc_id == NULL) </* No more -P, 'P' will be an int */ if (!P_sync_res) return NULL;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (PL_sync_rsrc_id == NULL) &/* No more -P, 'P' will be an int */ if (!P_sync_res) return NULL;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
else &*stream = NULL;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<return NULL;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (mStreamListener) mStreamListener->update_type((void*) mStreamListener);
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); &else <return (-1);
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (ptr == '0') &if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (PL_sync_rsrc_id == NULL) &/* No more -P, 'P' will be an int */ if (!P_sync_res) &return NULL;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* Get the next id */ if (ap_id == '-') ap_id = NULL; ap_id = ZEND_REGISTER_RESOURCE(NULL, ap_id, ap_id); return ap_id;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
/* * Find the first slot in the current buffer. */ if ((isin(caddr_addr, (void*)&le->ptr))!= NULL) <if (isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, &le->ptr)) &&!isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL,
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); <else &return (-1);
if (ptr == '&0') if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (ptr == '&0') if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') <if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
if (ptr == '0') &if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); <else return (-1);
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
&else if (L_KEY_PERSISTENT_NULL == 0) /* not possible in /* NOTABLE */
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
/* XXX :: To get the stream from this code, a std::string_for_data */ if (STA_STA_DATA("ptr").equals(Ptr)) <return Ptr();
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
return PHP_STREAM_PERSISTENT_EMPTY;
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr == '<0') if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (! &in_pstream) &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); <else return (-1);
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return (PSM_CANCEL_PERSISTENT_FAILURE);
&else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_RUNNING;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (le->refcount++ > 0) /* XXX should not occur here */ return NS_OK;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (debug) errx(1, "%s: not available<n", __func__);
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (!(PL_strlen("http: if (le->strlen == 0)) <PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) PL_strlen("http: PL_strlen("http:
if (debug) errx(1, "%s: not available&n", __func__);
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
&else <if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
return ZEND_STREAM_PERSISTENT_INTERFACE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
&else &*stream = NULL;
&else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); &else <return (-1);
if (ptr == '<0') if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
&else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->id!= 0) if (!(*stream)->rsrc_id) return EINVAL; return (EINVAL);
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); <else &return (-1);
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
<else *stream = NULL;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_OK;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (PL_sync_rsrc_id == NULL) </* No more -P, 'P' will be an int */ if (!P_sync_res) <return NULL;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr == '&0') <if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); &else &return (-1);
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (! &in_pstream) return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
return PHP_STREAM_PERSISTENT_ILLEGAL;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_SAILURE;
else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (z_type_P(le) == x) <if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) &if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
return PHP_STREAM_SUCCESS;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (z_type_P(le) == x) &if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); &else return (-1);
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ptr == '<0') if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
return PHP_STREAM_PERSISTENT_INVALID;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') &if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
if (le->id!= 0) &if (!(*stream)->rsrc_id) return EINVAL; return (EINVAL);
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(l->refcount == 0)) return NULL;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (mStreamListener) &mStreamListener->update_type((void*) mStreamListener);
return PHP_STREAM_PERSISTENT_SUCCESS;
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_PAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (ptr == '<0') &if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
if (!(PL_strlen("http: if (le->strlen == 0)) PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) PL_strlen("http: PL_strlen("http:
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr == '<0') if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_ACCESS;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
return PHP_STREAM_PerSISTENT_FAILURE;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (debug) errx(1, "%s: not availablen", __func__);
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ptr == '0') &if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
return PHP_STREAM_PERSISTENT_ERR;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
if (ptr == '<0') if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!cache_defaults) <return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(PL_strlen("http: if (le->strlen == 0)) PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) &PL_strlen("http: PL_strlen("http:
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(PL_strlen("http: if (le->strlen == 0)) &PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) &PL_strlen("http: PL_strlen("http:
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
&else &if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
return PHP_STREAM_PERSISTENT_ADDRESS;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_WAIT;
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) return PZ_STREAM_PERSISTENT_SUCCESS; &return PZ_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
/* Get the next id */ if (ap_id == '-') <ap_id = NULL; ap_id = ZEND_REGISTER_RESOURCE(NULL, ap_id, ap_id); return ap_id;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
return PHP_STREAM_PERSISTENT_DELETE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ptr == '<0') &if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return 0;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return FALSE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* The '<"' option */
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); else return (-1);
<else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
&else if (L_KEY_PERSISTENT_NULL == 0) </* not possible in /* NOTABLE */
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (!(PL_strlen("http: if (le->strlen == 0)) &PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) <PL_strlen("http: PL_strlen("http:
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!(PL_strlen("http: if (le->strlen == 0)) <PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) &PL_strlen("http: PL_strlen("http:
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!need_next) <return nsCRT::strdup(nsnull, "");
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FINISHED;
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); &else return (-1);
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); <else return (-1);
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (PL_sync_rsrc_id == NULL) /* No more -P, 'P' will be an int */ if (!P_sync_res) return NULL;
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
&return 0;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (!need_next) &return nsCRT::strdup(nsnull, "");
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); &else <return (-1);
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
if (!z_tx_is_zero) &return ZEXT_P(le);
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_INIT;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); &else &return (-1);
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (keg == NULL) &/* * Allocate the cpu as well as * the kernel of the CPU */ if (!keg) return KEG_ISOCF_UNUSED;
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); <else return (-1);
return PHP_STREAM_PERSISTENT_FOUND;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); <else <return (-1);
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
return PHP_STREAM_PERSISTENT_READ;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
return NS_OK;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
return 0;
else <if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
return PHP_STREAM_PERSISTENT_ABORT;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
<else if (L_KEY_PERSISTENT_NULL == 0) /* not possible in /* NOTABLE */
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* check for invalid /dups */ if (ptr->ptr_type == TYPE_F_FILE) </* XXX */
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (PL_sync_rsrc_id == NULL) </* No more -P, 'P' will be an int */ if (!P_sync_res) &return NULL;
<else if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
if (le->refcount++ > 0) </* XXX should not occur here */ return NS_OK;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); <else <return (-1);
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (z_type_P(le) == x) <if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* * The fpc_type, this type is valid. */ if ((!ptr) && ptr->flags & ZF_BUSY) ptr = (Ptr) ptr->ptr; if ((ptr = ptr->ptr) || (ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, ptr->ptr, le_pstream))) return ptr; return ptr;
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); else <return (-1);
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); else return (-1);
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
&else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!z_tx_is_zero) <return ZEXT_P(le);
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); else return (-1);
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
if (ptr == '0') <if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') <if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
&return NULL;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); else &return (-1);
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
return PHP_STREAM_PERSISTENT_UNEXIST;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return rsrc_id;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); &else &return (-1);
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) <return PZ_STREAM_PERSISTENT_SUCCESS; return PZ_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); <else return (-1);
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') &if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
else <*stream = NULL;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
<else &if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
else if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (persistent_id && (persistent_id (int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ptr == '<0') <if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
if (!cache_defaults) return PHP_STREAM_PERSISTENT_FAILURE;
if (!len) return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') <if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
else if (L_KEY_PERSISTENT_NULL == 0) &/* not possible in /* NOTABLE */
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); <else return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); else &return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) &return (0); &else <return (-1);
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ptr == '&0') if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
<return 0;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
return PHP_STREAM_PERSISTENT_FULL;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_LOCK;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
if (ptr == '0') &if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_SUCCESS;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); else <return (-1);
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); else &return (-1);
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr == '0') if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (! &in_pstream) <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); &else <return (-1);
return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * There are no buffers for the current stream. */ /* * Get a list of resources for rsrc */ while (rsrc == NULL) <rsrc = rsrc->rsrc; rsrc = rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); <else &return (-1);
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
return PHP_STREAM_PERSISTENT_NEXT;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); &else return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); else &return (-1);
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') <if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); <else <return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); else <return (-1);
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (persistent_id && (persistent_id <(int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
<else <*stream = NULL;
if (mStreamListener) <mStreamListener->update_type((void*) mStreamListener);
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); else return (-1);
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id (int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') <if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg == NULL) /* * Allocate the cpu as well as * the kernel of the CPU */ if (!keg) return KEG_ISOCF_UNUSED;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
return PZ_STREAM_PERSISTENT_FUNCTION;
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NEXT_EXIST;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
else &if (pw_write(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen))))))))!= 0) && (rsrc_id == rsrc_id)))!= 0) ) rsrc_id = ZEND_REGISTER_RESOURCE(NULL,
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
else if (L_KEY_PERSISTENT_NULL == 0) /* not possible in /* NOTABLE */
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n (*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PR_FAILURE;
if (ptr == '&0') &if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NEXT_EXIST;
*stream = NULL;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') <if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); <else return (-1);
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') &if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
return this;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * There are no buffers for the current stream. */ /* * Get a list of resources for rsrc */ while (rsrc == NULL) rsrc = rsrc->rsrc; rsrc = rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc->rsrc
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_TAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); else &return (-1);
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); &else return (-1);
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) &return PZ_STREAM_PERSISTENT_SUCCESS; &return PZ_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); else <return (-1);
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ptr == '0') &if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); <else return (-1);
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n (*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
return result;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) if (len == le_pstream) <if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ptr == '<0') if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); &else return (-1);
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_NOT_EXIST;
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* get this thread so that the thread is not ready */ if (!l_pstream) </* get a thread for free threads */ l_pstream = '<0';
return PHP_STREAM_PERSISTENT_NULL;
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); else <return (-1);
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!cache_defaults) &return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); <else <return (-1);
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) <return (0); &else &return (-1);
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); &else <return (-1);
if (persistent_id && (persistent_id (int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
return PHP_STREAM_PERSISTENT_FUCCESS;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
if (ptr == '0') <if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) <rsrc_id = 0;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) return PZ_STREAM_PERSISTENT_SUCCESS; <return PZ_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (ptr == '0') <if (ptr->ptr == '0') <ptr = '0'; else ptr = '0';
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) <*stream = (PLength*)len;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Find the first slot in the current buffer. */ if ((isin(caddr_addr, (void*)&le->ptr))!= NULL) if (isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, &le->ptr)) &&!isin(caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESTORE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL, caddr_addr, ZEND_REGISTER_RESOURCE(NULL,
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<return PHP_STREAM_PERSISTENT_SUCCESS;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) &*stream = (PLength*)len;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
<return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ptr == '<0') if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) <rsrc_id = 0;
return NULL;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') if (ptr->ptr == '<0') <ptr = '0'; else ptr = '0';
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n <(*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (!z_TYPE_P(le)) &if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) <if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s<n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
<else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') &if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (zdb_req) if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_VALUE;
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); <else return (-1);
/* * See if the stream is freed. */ if (t == '0') return 0;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
<else if (L_KEY_PERSISTENT_NULL == 0) </* not possible in /* NOTABLE */
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) <return PZ_STREAM_PERSISTENT_SUCCESS; &return PZ_STREAM_PERSISTENT_FAILURE;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
if (len > 0) if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %s&n", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
return NULL; return NULL;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') <if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
if (keg!= NULL) &if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (PL_sync_rsrc_id == NULL) /* No more -P, 'P' will be an int */ if (!P_sync_res) <return NULL;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_SUCCESS;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) &return PZ_STREAM_PERSISTENT_SUCCESS; return PZ_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') &if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) &rsrc_id = 0;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
&else
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); <else &return (-1);
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) <if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '<0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) return (0); <else <return (-1);
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (!z_TYPE_P(le)) if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') &if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
return NULL; <return NULL;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) <return PZ_STREAM_PERSISTENT_SUCCESS; <return PZ_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr == '0') <if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); <else <return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) return (0); <else &return (-1);
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (!need_next) return nsCRT::strdup(nsnull, "");
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); <else &return (-1);
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (persistent_id == NULL) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* check for invalid /dups */ if (ptr->ptr_type == TYPE_F_FILE) /* XXX */
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (le->id!= 0) <if (!(*stream)->rsrc_id) return EINVAL; return (EINVAL);
if (ptr == '<0') &if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_INVALID;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) /* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n &(*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (z_type_P(le) == x) if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) &if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) <if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); else &return (-1);
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
return PHP_STREAM_PERSISTENT_REMOVE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (cnt++ == NULL) <return PHP_STREAM_PERSISTENT_UNKNOWN;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '0') <if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (PL_sync_rsrc_id == NULL) &/* No more -P, 'P' will be an int */ if (!P_sync_res) <return NULL;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_OK;
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) &if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) &if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; &&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') <if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) &ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') <if (ptr->ptr == '<0') ptr = '0'; else ptr = '0';
if (le->flags & TSRMLS_DUMP) &if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <&else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); &else <return (-1);
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
return (null!= rsrc_id);
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (*stream == NULL) /* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->flags & TSRMLS_DUMP) if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* check for invalid /dups */ if (ptr->ptr_type == TYPE_F_FILE) &/* XXX */
if (ptr == '<0') <if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * There is an error in the RPC mode if we have no a ptr and we can't return a pointer to the stream. */ if ((nptr->ptr->ptr = '&0') && (nptr->rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))!= 0) <*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->ptr) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* XXX :: To get the stream from this code, a std::string_for_data */ if (STA_STA_DATA("ptr").equals(Ptr)) return Ptr();
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) &*stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* get this thread so that the thread is not ready */ if (!l_pstream) /* get a thread for free threads */ l_pstream = '<0';
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (*stream == NULL) </* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
return PHP_STREAM_PERSISTENT_INTERFACE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) <return (0); &else return (-1);
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (!(l->refcount == 0)) &return NULL;
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) *stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * The fpc_type, this type is valid. */ if ((!ptr) && ptr->flags & ZF_BUSY) &ptr = (Ptr) ptr->ptr; if ((ptr = ptr->ptr) || (ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, ptr->ptr, le_pstream))) return ptr; return ptr;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) if ((n = get_key_save(")) == NULL) &return (0); <else &return (-1);
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
&else <*stream = NULL;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (ptr == '&0') <if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
&return PHP_STREAM_PERSISTENT_SUCCESS;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (le->flags & TSRMLS_DUMP) if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id <(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) &/* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') &if (ptr->ptr == '0') &ptr = '0'; else ptr = '0';
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) <*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (keg!= NULL) &if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount &0) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) &if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) <if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (ptr) &ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
&else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
&return NULL;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) return (0); else &return (-1);
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); else &return (-1);
if (!(le->flags & ZP_PROTO)) /* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
else &/* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n (*n)) if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
&else if (L_KEY_PERSISTENT_NULL == 0) &/* not possible in /* NOTABLE */
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
/* get this thread so that the thread is not ready */ if (!l_pstream) /* get a thread for free threads */ l_pstream = '&0';
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (me->flags & P_PHYPI) /* The static level to be rsrc_id is non-NULL. */ if (me->refcount 0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) &if (len == le_pstream) &if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (len > 0) &if (PL_Syslog(LOG_INFO, "%s: %s - unsigned char* %sn", __func__, len, strlen(Length(Length))), strlen(Length(Length))) == 0) *stream = (PLength*)len;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (ptr) <ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_INVALID;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream == NULL) &/* XXX */ (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) <if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* FIXME: We need to set __len__ to avoid unmap to the integer's default_c. */ if (LE_PRINTF("%s: %s", le->refcount, __len__)) == 0) *stream = (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) </* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr == '&0') if (ptr->ptr == '&0') <ptr = '0'; else ptr = '0';
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n <(*n)) <if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) <if ((n = get_key_save(")) == NULL) <return (0); &else &return (-1);
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
return PHP_STREAM_PERSISTENT_FAILED;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) int i; n = (*n)&n; if (n &(*n)) &if (n == 0) &*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (le->debuglevel >= level) &if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) &int i; n = (*n)&n; if (n <(*n)) &if (n == 0) *n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) <if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!len) &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If we got a zero, we have a zero, we've got zero. */ if (no_bytes_length) <int i; n = (*n)&n; if (n &(*n)) <if (n == 0) <*n = 0; return PHP_STREAM_PERSISTENT_SUCCESS; if (n == NULL) *n = (void*)n; n = n;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) &/* XXX: */ if (!prt_flags) /* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ptr == '0') if (ptr->ptr == '<0') &ptr = '0'; else ptr = '0';
<else /* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return rsrc_id;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if ((n = get_key_save((n = get_key_save("))) == NULL) || (n == NULL)) &if ((n = get_key_save(")) == NULL) &return (0); &else <return (-1);
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) <ke->ke_id = ke->ke_id; else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->name) <if (PZ_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (le->ptr) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) /* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) </* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (*stream) <*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '<0') &if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
if (le->ptr) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
return PHP_STREAM_PERSISTENT_FUNCTION;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) &if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) &0) rsrc_id = 0;
if (*stream) &*stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->ptr) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr == '&0') &if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (cache_has_key(&cache_again_key)) if (Z_TYPE_P(cache_again_key) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* The '"' option */
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) &/* XXX */ if (rsrc_id) if ((nsCRT::strlen(rsrc_id)) 0) &rsrc_id = 0;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') </* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
return PHP_STREAM_PERSISTENT_EXIST;
if (zdb_req) if (l__func__ == __func__) if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ptr->ptr == le_pstream) if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) &if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (ptr && Z_TYPE_P(ptr) == le_pstream) <if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (!z_TYPE_P(le)) if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) <if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; &if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* get this thread so that the thread is not ready */ if (!l_pstream) &/* get a thread for free threads */ l_pstream = '&0';
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) <if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') <if (__USE_PLATFORM(PLATFORM_FILE__) == '&0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) &return PZ_STREAM_PERSISTENT_SUCCESS; <return PZ_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) <if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) ptr = ptr; ptr->ptr = ptr->ptr;
if (ptr == '&0') &if (ptr->ptr == '&0') ptr = '0'; else ptr = '0';
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) &if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) /* don't let's call ptr: a ptr */ ptr = ptr; &if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (persistent_id == NULL) if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_NONE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (me->flags & P_PHYPI) &/* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
return PZ_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) <rsrc_id = 0;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (ptr && Z_TYPE_P(ptr) == le_pstream) if (stream) <*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) <if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) &if ((nsCRT::strlen(rsrc_id)) &0) &rsrc_id = 0;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; &else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (persistent_id && (persistent_id <(int) 0)) ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ptr->ptr == le_pstream) <if (ptr->ptr == le_pstream) ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id <(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) &if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (ptr == '&0') &if (ptr->ptr == '&0') &ptr = '0'; else ptr = '0';
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (persistent_id && (persistent_id &(int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) if (len == le_pstream) if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) </* XXX */ if (zsrc_next == NULL) &/* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_OK;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_TRUE;
if (le->flags & TSRMLS_DUMP) if (strlen(len) 1) <if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) /* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (persistent_id && (persistent_id <(int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) &if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (persistent_id && (persistent_id &(int) 0)) &ptr = && (persistent_id &(int) 0); if (persistent_id) ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) *stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (!(PL_strlen("http: if (le->strlen == 0)) PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("http: PL_strlen("")))) <PL_strlen("http: PL_strlen("http:
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) <*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (zh_hash_find(&EZ_TYPE_P(le)) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_NAME;
if (le->ptr) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') /* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) <if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) if (ztb_unlocked) if (ztb_unlocked) &if (ztb_unlocked) <if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (zdb_req) &if (l__func__ == __func__) <if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (*stream) *stream = ((php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_OK;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; <if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) /* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) 0) rsrc_id = 0;
if (keg!= NULL) <if (keg->ptr == NULL) if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (zdb_req) <if (l__func__ == __func__) <if (l__func__ == __func__) if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* the thread we need to write to. */ if (me->refcount == 0) <if (le->refcount == 0) if (len == le_pstream) &if (len == -1) <*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Get the freelist as well as the freelist from the list. */ if (!rsrc_id) </* XXX */ if (rsrc_id) <if ((nsCRT::strlen(rsrc_id)) <0) rsrc_id = 0;
if (!failed) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) <if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (rsrc_id == ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream)) <return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg->keg_type == keg_type) <if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
/* this does not have a link to the thread, because it * can be closed so we can * have it to stop here. */ if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return rsrc_id;
return nsAutoString::String::String(&m_id, le_pstream);
/* In case we can't a thread */ if ((node = node->next) &&!(node->tn_reply && node->tn_reply)) <if (ptr) &/* XXX */ if (zsrc_next == NULL) /* XXX */ if (ptr->flags & XXX) &/* XXX */ /* XXX */ if (ptr->flags & XXX) /* XXX */ if (Z_TYPE_P(ptr->flags) == le_pstream) /* * The nsnull case */ /* XXX */ else /* * The nsnull case */ /* * In case it is not
if (keg->keg_type == keg_type) if (keg->keg_type == keg->keg_type) &if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (!failed) &if (Z_TYPE_P(le) == le_pstream) <if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE;
if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) <if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* the thread we need to write to. */ if (me->refcount == 0) if (le->refcount == 0) <if (len == le_pstream) if (len == -1) &*stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (cache_has_key(&cache_again_key)) &if (Z_TYPE_P(cache_again_key) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (ptr && Z_TYPE_P(ptr) == le_pstream) &if (stream) &*stream = (ptr)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) <if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) &/* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* the thread we need to write to. */ if (me->refcount == 0) &if (le->refcount == 0) &if (len == le_pstream) <if (len == -1) *stream = (len = -1) le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) if (PZ_TYPE_P(le) == le_pstream) if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) &if (!HTTP_STATIC(le->ptr)) &if (Z_TYPE_P(le) == td) <if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (!z_TYPE_P(le)) &if (len) &*stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (!failed) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->ptr) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
<else </* * To make a.rsrc_id count of XXX or NSS */ rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return rsrc_id;
if (__USE_PLATFORM(PLATFORM_FILE__) == '0') &if (__USE_PLATFORM(PLATFORM_FILE__) == '<0') &/* The ptr has no value to set */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* The ptr' should be inserted in the src_initialized */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0') /* We need to parse src_initialized and * the src_initialized. */ if (__USE_PLATFORM(PLATFORM_FILE__) == '0')) if (__USE_PLATFORM(PLATFORM_FILE__) == '0') <unk>
if (ptr) ptr->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_INVALID;
/* get this thread so that the thread is not ready */ if (!l_pstream) </* get a thread for free threads */ l_pstream = '0';
if (keg->keg_type == keg_type) &if (keg->keg_type == keg->keg_type) <if (keg->keg_type == keg_type) &if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type == keg_type) if (keg->keg_type ==
if (keg!= NULL) if (keg->ptr == NULL) <if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (!(le->flags & ZP_PROTO)) </* XXX: */ if (prt_flags & ZP_PROTO) /* XXX: */ if (!prt_flags) </* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
if (ptr == '<0') <if (ptr->ptr == '0') ptr = '0'; else ptr = '0';
if (persistent_id && (persistent_id &(int) 0)) <ptr = && (persistent_id &(int) 0); if (persistent_id) &ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
if (le->ptr) &if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
return PHP_STREAM_PERSISTENT_FIXED;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) &if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; <if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
if (!(le->flags & ZP_PROTO)) &/* XXX: */ if (prt_flags & ZP_PROTO) </* XXX: */ if (!prt_flags) &/* XXX: */ if (!Prt_flags & ZP_PROTO) return Prt_FAILURE; if (!prt_flags) return Prt_FAILURE; /* XXX: */ if (((Prt_flags & ZP_PROTO) & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) /* XXX: */ if ((Prt_flags & ZP_PROTO) == 0) <unk>
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) &if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) /* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (me->flags & P_PHYPI) </* The static level to be rsrc_id is non-NULL. */ if (me->refcount <0) if (Z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!((*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream))) return PZ_STREAM_PERSISTENT_SUCCESS; return PZ_STREAM_PERSISTENT_FAILURE;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_NOT_EXIST;
/* * Instance of rsrc_instance is not supported, but will always work. */ if (!z_flags) <if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) <if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (ztb_unlocked) if (ztb_unlocked) <if (ztb_unlocked) <if (ztb_unlocked) &if (ztb_unlocked) if (ztb_unlocked) *stream = (php_stream*)ztb_unlocked; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNLOCK; return PHP_STREAM_PERSISTENT_UNLOCK;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) <if ((nsnull!= ptr) && (nsnull == ptr)) &/* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) <ptr = ptr; ptr->ptr = ptr->ptr;
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) <if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) ke->ke_id = ke->ke_id; <else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
/* * Check for this file name from a null stream */ if (persistent_type == PG_HOST_PERSISTENT_TYPE_ALL) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; <return PHP_STREAM_PERSISTENT_NOT_EXIST;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (!failed) &if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE;
/* * Find the loops of the string from the list for the function */ if (!FAILURE || Z_TYPE_P(le) == td) <if (!HTTP_STATIC(le->ptr) || Z_TYPE_P(le->ptr)) if (!HTTP_STATIC(le->ptr)) if (Z_TYPE_P(le) == td) &if (Z_TYPE_P(le) == td) if (P(le->ptr) && Z_TYPE_P(le->ptr) == td) if (Z_TYPE_P(le) == td) if (*stream) *stream = (php_stream*)td; td->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream,
if (persistent_id == NULL) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
return NULL; &return NULL;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) &if (zdb_req->__func__ == __func__) <if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (z_type_P(le) == x) if (strcmp(strcmp(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen(strlen)))))))!= 0) && Z_TYPE_P(le) == le_pstream) <if (strlen(strlen(strlen(strlen(strlen(strlen(strlen(
if (le->debuglevel >= level) <if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) &*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
if (le->flags & TSRMLS_DUMP) <if (strlen(len) <1) &if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_UNAVAILURE;
/* not true unless this thread is running or has been executed */ if ((disable_rsrc_initialized) == 0) if ((nsnull!= ptr) && (nsnull == ptr)) </* don't let's call ptr: a ptr */ ptr = ptr; if ((nsnull == ptr) || (nsnull!= ptr) && (nsnull!= ptr)) &ptr = ptr; ptr->ptr = ptr->ptr;
if (persistent_id && (persistent_id (int) 0)) ptr = && (persistent_id (int) 0); if (persistent_id) <ptr = && (persistent_id (int) 0); if (ptr == NULL) if (ptr == NULL) ptr = && ((ptr = &ptr) == NULL) && ((ptr = &ptr) == NULL) && ((ptr == NULL) && (ptr == NULL) && (ptr == NULL) && ((ptr == NULL) && (ptr == NULL)) && (ptr == NULL)) && (ptr ==
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) &if (Z_TYPE_P(flags) == le_pstream) &if (stream) &*stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (keg!= NULL) if (keg->ptr == NULL) if (keg->rsrc_id == NULL) &if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * If id is NULL, then we * assume that ZEND_REGISTER_RESOURCE is NULL, and we must use the regcount to do it with a FAILURE_VALUE. */ if ((flags & ICQ_SINK) == 0) if (Z_TYPE_P(flags) == le_pstream) &if (stream) *stream = ((flags & ICQ_SINK) + le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSIST
if (Z_TYPE_P(le) == le_pstream) &if (stream) <*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_FAILURE; &return PHP_STREAM_PERSISTENT_UNAVAILURE;
if (keg!= NULL) if (keg->ptr == NULL) &if (keg->rsrc_id == NULL) if (keg->ptr->ptr->ptr->ptr->rsrc_id) </* FIXME: ERROR when the ptr was "reg_t" is zero */ /* FIXME: ERROR when the ptr is "reg_t" is null */ /* FIXME: ERROR when the ptr was "reg_t" is "reg_t" */ if (F_STREAM_PERSISTENT_ERR) if (F_STREAM_PERSISTENT_ERR) return f_struct / * ZEND_READ_ERR; if (F_STREAM_PERSISTENT_ERR)
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
/* * Note that * this is the thread we must do before registering the stream. This is a bit of a string that is not supposed to have been inserted in the queue, and * we can't register the stream without the context. This is the case when the thread has been blocked. */ if (!zdebug_destroy_stream(&ke)) &if (ke->ke_id == ke->ke_id) return -1; if (ke->ke_id == ke->ke_id) &ke->ke_id = ke->ke_id; <<else ke->ke_id = ke->ke_id; ke->ke_id = ke->ke_id;
if (zdb_req) <if (l__func__ == __func__) &if (l__func__ == __func__) <if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
if (ptr->ptr == le_pstream) &if (ptr->ptr == le_pstream) <ptr = (Ptr)ptr->ptr; le->refcount++; (*ptr)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *ptr, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; <return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (zdb_req) if (l__func__ == __func__) &if (l__func__ == __func__) if (zdb_req->__func__ == __func__) &if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func__) if (zdb_req->__func__ == __func
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) &if (Z_TYPE_P(le) == le_pstream) &if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * The void */ if (zh_state!= EXIST_BEFORE_SUCCESS) <if (Z_TYPE_P(le) == le_pstream) if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
if (!z_TYPE_P(le)) if (len) *stream = (ptr)->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; return PHP_STREAM_PERSISTENT_FAILURE;
if (le->name) &if (PZ_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE;
/* * XXX */ if (Z_TYPE_P(le) == le_pstream) <if (stream) &*stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); &return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE;
if (le->flags & TSRMLS_DUMP) &if (strlen(len) &1) <if (z_TYPE_P(le) == le_pstream) <if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_FEAILURE;
<#endif
/* * Ignore all undefined groups. */ if (zs_key(ns_key)) &if (zs_key(ns_key)) &if (zs_key(ns_key)) <if (zs_key(ns_key)) &if (zs_key(ns_key)) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (zs_key(ns_key) == 0) if (Z_TYPE_P(le) == le_pstream) if (stream) *stream = (php_stream*)le->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); return PHP_STREAM_PERSISTENT_FAILURE
if (le->debuglevel >= level) if ((LE_TYPE_P(le) == le_pstream) && (le->debuglevel >= level)) <*stream = (PL_PHYS(LE_PHYS))->ptr; le->refcount++; (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream); <return PHP_STREAM_PERSISTENT_SUCCESS; &return PHP_STREAM_PERSISTENT_FAILURE; return PHP_STREAM_PERSISTENT_ERROR_SUCCESS;
