golden:
<extra_id_0>
inference:

mp_ptr b2p = 0;
mp_ptr b2p;
struct mp_ptr b2p;
mp_ptr b1p;
mp_ptr bp;
mp_srcptr b2p;
ptr b2p;
const mp_ptr b2p;
mp_ptr *b2p;
mp_ptr b3p;
mp_ptr b1;
mp_ptr_b2p;
mp_ptr bp = 0;
mp_ptr b2p = NULL;
mp_ptr (b2p);
mp_limb_t b2p;
mp_ptr b2p, n;
(void)mp_ptr b2p;
mp_ptr b2p, i;
int b2p;
mp_ptr b2p, p;
void mp_ptr b2p;
mp_ptr p2p;
mp_ptr b2, b2p;
struct ptr b2p;
srcptr b2p;
b2p;
mp_ptr b2p = 1;
mp_ptrb2p;
ptr_b2p;
mp_ptr b2;
struct mp_ptr *b2p;
_mp_ptr b2p;
mp_ptr &b2p;
mp_ptr b2);
mp_ptr b2p, 0;
u_int32_t b2p;
&mp_ptr b2p;
mp_ptr b;
mp_ptr tp;
__mp_ptr b2p;
mp_b2p;
int mp_ptr b2p;
mp_ptr b2p, v;
mp_ptr bp[2];
mmp_ptr b2p;
mp_t b2p;
mp_ptr b2p = -1;
mp_ptr ip;
mp_ptr ip2p;
mp_ptr bn;
(void) mp_ptr b2p;
mp_ptr ep;
mp_ptr cp;
*mp_ptr b2p;
tmp_ptr b2p;
mp_ptr a2p;
m_ptr b2p;
mp_ptr bp = NULL;
mp_ptr buf;
mp_bitcnt_t b2p;
mp_ptr (b2);
mp_ptr b2p,
mp_ptr b4p;
mp_ptr b2, b3p;
mp_ptr p;
mp_limb_t bp;
mp_ptr b2p = 2;
mp_ptr b2i;
mp_ptr bbp;
mp_ptr rp;
mp_size_t b2p;
mp_ptr(b2p);
mp_ptr b2p ;
mp_ptr bp[1];
bool b2p;
mp_ptr bb;
mp_ptr
mp_ptr b2p, m;
mp_ptr bp[0];
u_ptr b2p;
u_int b2p;
mp_ptr bp, tp;
mp_ptr b2p, en;
mp_ptr lp;
mp_lptr b2p;
mp_ptr bp, n;
mp_ptr bp, p;
mp_ptr sp;
n = mp_ptr b2p;
mp_ptr b2p
mp_ptr **b2p;
mp_ptr b2p [];
mp_ptr b2p = n;
u_long b2p;
mp_ptr b2p=0;
mp_ptr const b2p;
mp_ptr m2p;
mp_ptr b2p, size;
#endif
mp_int b2p;
mpptr b2p;
static mp_ptr b2p;
mp_ptr bp, i;
mp_ptr sb2p;
mp_ptr vp;
mp_ptr b0p;
mp_ptr b2p, s;
++mp_ptr b2p;
size_t b2p;
mp_ptr br2p;
mp_srcptr bp;
mp_ptr int b2p;
mp_ptrptr b2p;
(mp_ptr) b2p;
int i;
mp_ptr b2p, l;
mp_ptr bp1;
mp_ptr b2p, 1;
mp_ptr b2p1;
mp_ptr b2p, y;
mp_ptr b1, b2p;
mp_ptr-b2p;
mp_ptr bp[3];
mp_ptr b2p, len;
mp_ptr b2lp;
mp_ptr* b2p;
mp_ptr bp2p;
mp_ptr, b2p;
mp_ptr bp, ep;
struct mp_ptr_b2p;
this_ptr b2p;
mp_ptr bp, rp;
mp_ptr bsp;
mp_ptr h2p;
mp_ptr b2p, d;
mp_ptr ret;
mp_ptr b2p, h;
ulong b2p;
struct ptr *b2p;
mp_ptr b2p[0];
mp_ptr b2p, t;
mpn_ptr b2p;
mp_ptr mp2p;
mp_ptr& b2p;
::mp_ptr b2p;
mp_ptr b2, b1;
mp_ptr bp, v;
mp_ptr b2p, *p;
mp_ptr nb2p;
mp_ptr b2p 1;
lptr b2p;
mp_ptr "b2p";
mp_ptr s;
mp_ptr bpp;
mp_ptr bb2p;
mp_ptr bp, this_pp;
mp_ptr b2p, j;
mp_ptr bp, bn;
if (mp_ptr b2p)
mp_ptr n;
rp_ptr b2p;
src_ptr b2p;
ret;
mp_ptr/b2p;
mp_ptr b2p2;
mp2ptr b2p;
mp_type b2p;
mp_ptr b2, i;
mp_ptr r2p;
mp_ptr b2u;
mp_ptr i;
mp_ptr v2p;
mp_ptr v;
mp_ptr b2h;
mp_ptr b2p, flags;
mp_ptr blp;
mp_ptr b2p; #endif
void *b2p;
mp_ptr np;
mp_ptr pp;
mp_ptr t2p;
mp_ptr b2p, val;
mp_ptr tmp;
mp_ptr bs;
u_int8_t b2p;
int cnt;
mp_ptr b2p, f;
mp_ptr|b2p;
mp_ptr mpp;
mp_ptr b2, p2p;
mp_ptr b2f;
mp_ptr bp,
mp_ptr b2p, ip[2];
mp_ptr b2p, mp_ptr b2p;
mp_ptr b2p, &lp, 0;
mp_ptr b2p, p2p;
mp_ptr b2p ATTRIBUTE_UNUSED;
mp_ptr b2p, bn, i;
mp_ptr b2p, mp_ptr b3p;
mp_ptr bp =  mp_ptr b2p;
mp_ptr b2p; /* do the first few exponent bits without mod reductions, until the result is greater than the mod argument. */ for (;;)  mp_sqr (tp, this_pp, tn); tn = tn * tn;
mp_ptr bp, mp_t sc;
mp_ptr b2p, mp_srcptr b2, mp_size_t bn, mp_srcptr ep, mp_size_t en, mp_srcptr mp, mp_size_t n, mp_ptr tp);
mp_ptr b2p, mp_dm_t sm;
mp_ptr bp, mp_ptr rp, mp_ptr ep, mp_size_t n, mp_ptr tp, mp_size_t ep, mp_ptr tp;
mp_ptr b2p, rp;
mp_ptr b2p = 0,0,1;
mp_ptr bp, *v;
mp_ptr b2p, b1;
mp_ptr b2p, np;
mp_ptr b2p, mp_ptr p2p;
mp_ptr b2p, b2p, bp;
mp_ptr b2p, mp_srcptr b1;
mp_ptr b2p, lp;
mp_ptr b2p, b0;
mp_ptr b2p; mp_ptr b2p, b2p;
mp_ptr b2p = 0,1;
mp_ptr b2p =  0 ;
mp_ptr b2p, *mip;
mp_ptr b2p, p, d;
mp_ptr bp, mp_ptr rp;
mp_ptr b2p, mp_cptr tp;
mp_ptr bp, b2p;
mp_ptr b2p, b2p;
mp_ptr b2p, bs;
mp_ptr b2p, b2p2p2;
mp_ptr b2p, bp;
mp_ptr b2p; /* * If we don't have any physical planes then use this  if (!mip->mi_srcptr)  mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr bp, bp2p;
mp_ptr bp, *tp;
mp_ptr b2p, v2p;
mp_ptr b2p, mp_flags;
mp_ptr b2p; mp_ptr b2p = 0;
mp_ptr b2p, lnk;
mp_ptr b2p; /* * srcptr bp (empty) if we need to call nth; */
mp_ptr bp, bp1;
mp_ptr b2p, cnt;
mp_ptr b2p, ep;
mp_ptr b2p, ptr;
mp_ptr b2p, b0p, b2p;
mp_ptr b2p, *tmp;
mp_ptr b2p, *a2p;
mp_ptr b2p = (mp_ptr & 0xFFFF) /*ff000 if 0xFFFFFF!= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
mp_ptr b2p, mp_cnt;
mp_ptr b2p; /* Note that this is a bad option. */

mp_ptr b2p = <0,0,1;
mp_ptr <b2p;
mp_ptr b2p = &0 &;
mp_ptr &b2p;
mp_ptr bp = mp_ptr b2p;
<mp_ptr b2p;
mp_ptr bp = &mp_ptr b2p;
mp_ptr b2p;
mp_ptr b2p = 0 <;
mp_ptr b2p; /* * If we don't have any physical planes then use this &if (!mip->mi_srcptr) &mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p = &0,1;
mp_ptr b2p = <0,1;
mp_ptr b2p = 0,0,1<;
mp_ptr b2p = &0,0,1;
mp_ptr b2p; /* * If we don't have any physical planes then use this &if (!mip->mi_srcptr) <mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p; /* * If we don't have any physical planes then use this <if (!mip->mi_srcptr) &mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p = 0,0,1&;
mp_ptr b2p; /* * If we don't have any physical planes then use this <if (!mip->mi_srcptr) mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p = &0,0,1&;
mp_ptr b2p = <0,0,1&;
mp_ptr b2p = <0,0,1<;
mp_ptr bp = <mp_ptr b2p;
mp_ptr b2p;
mp_ptr b2p; /* * If we don't have any physical planes then use this if (!mip->mi_srcptr) &mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p = 0 ;
mp_ptr b2p = 0,1;
mp_ptr b2p = <0 ;
mp_ptr b2p; /* do the first few exponent bits without mod reductions, until the result is greater than the mod argument. */ for (;;) &mp_sqr (tp, this_pp, tn); tn = tn * tn;
mp_ptr b2p; /* do the first few exponent bits without mod reductions, until the result is greater than the mod argument. */ for (;;) mp_sqr (tp, this_pp, tn); tn = tn * tn;
mp_ptr b2p = &0 <;
mp_ptr b2p = &0,0,1<;
mp_ptr b2p; /* * If we don't have any physical planes then use this &if (!mip->mi_srcptr) mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p = &0 ;
mp_ptr bp;
mp_ptr b2p = 0,0,1;
mp_ptr b2p = <0 <;
mp_ptr b2p; /* * If we don't have any physical planes then use this <if (!mip->mi_srcptr) <mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p; /* do the first few exponent bits without mod reductions, until the result is greater than the mod argument. */ for (;;) <mp_sqr (tp, this_pp, tn); tn = tn * tn;
&mp_ptr b2p;
mp_ptr b2p; /* * If we don't have any physical planes then use this if (!mip->mi_srcptr) mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p; /* * If we don't have any physical planes then use this if (!mip->mi_srcptr) <mpn_powm (mp_limb_t ip[2], *mip, &n, &n, &mp_ptr tp);
mp_ptr b2p = <0 &;
mp_ptr b2p = 0 &;
