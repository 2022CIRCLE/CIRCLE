golden:
if (!EG(exception)) { /* open failed w/out notice (turned to exception due to EH_THROW) */ zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0  TSRMLS_CC, "Failed to open directory \"%s\"", path); }
inference:
#endif

return 0;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
intern->u.dir.dirp = NULL;
spl_filesystem_dir_open(intern->u.dir.entry.d_name);
break;
spl_filesystem_dir_read(intern TSRMLS_CC);
/* XXX */
spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC);
intern->_path = estrndup(path, --intern->_path_len);
return NULL;
return (0);
spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC)
spl_dir.dirp = NULL;
*/
spl_filesystem_dir_open(spl_filesystem_object* intern, char *path);
spl_filesystem_dir_write(intern TSRMLS_DC);
spl_filesystem_dir_open(spl_filesystem_object* intern);
else  spl_filesystem_dir_read(intern TSRMLS_CC);
intern->dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
/* open a directory resource */
spl_filesystem_dir_open(spl_filesystem_object);
spl_filesystem_dir_read(intern TSRMLS_DC);
else
spl_filesystem_dir_write(intern TSRMLS_CC);
spl_filesystem_dir_open(intern TSRMLS_DC);
else  spl_filesystem_dir_open(intern TSRMLS_DC);
return -1;
spl_filesystem_dir_open(intern->u.dir.dirp);
spl_filesystem_dir_open(spl_filesystem_object* intern, char *path)
spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name);
spl_filesystem_dir_open(intern);
return;
@endif
intern->dir.dirp = NULL;
.d_name[0] = '0';
else  do  spl_filesystem_dir_read(intern TSRMLS_CC);
u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
spl_filesystem_dir_free(intern->u.dir.entry.d_name);
static void spl_filesystem_dir_open(intern->u.dir.entry.d_name);
#ifdef DEBUG
/*
intern->type = SPL_FS_DIR;
return TRUE;
spl_filesystem_dir_close(spl_filesystem_object);
free(path);
interne->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
spl_filesystem_dir_close(intern);
spl_filesystem_dir_open(spl_filesystem_object*, char *path);
spl_filesystem_dir_open(spl_filesystem_object* intern, char *pathTSRMLS_DC);
static void spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC)
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, 0);
else  intern->_path = estrndup(path, --intern->_path_len);
(void) spl_filesystem_dir_open(intern->u.dir.entry.d_name);
Intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
internal->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS);
Intern->u.dir.dirp = NULL;
spl_filesystem_dir_free(spl_filesystem_object);
intern->u.dir.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
exit(1);
spl_filesystem_dir_open(internTSRMLS_DC);
spl_filesystem_dir_write(intern->u.dir.entry.d_name);
spl_filesystem_dir_write(intern);
spl_filesystem_dir_close(intern->u.dir.dirp);
intern->_path = '0';
.d_name = '0';
/* * XXX */
/* spl_filesystem_dir_open(intern->u.dir.entry.d_name); */
#endif /* XXX */
free(intern->u.dir.dirp);
intern->u.dir.dirp = spl_stream_opendir(path, REPORT_ERRORS, NULL);
spl_filesystem_dir_open(spl->u.dir.entry.d_name);
intern->_path_len = strlen(path);
intern->u.dir.dirp = php_stream_opendir(path, NULL);
intern->u.dir.dirp = 0;
internal->u.dir.dirp = NULL;
spl_filesystem_dir_open(spl_filesystem_object* intern, NULL);
continue;
(void)spl_filesystem_dir_open(intern->u.dir.entry.d_name);
spl_filesystem_dir_open(spl_filesystem_object* intern->u.dir.dirp);
/* open a directory resource */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
interne->u.dir.dirp = NULL;
spl_filesystem_dir_open();
spl_filesystem_dir_open(spl_filesystem_object* intern, char *pathTSRMLS_DC)
intern->u.dir.dirp = '0';
intern->u.dir.dirp = p;
else  spl_filesystem_dir_open(intern->u.dir.entry.d_name);
u.dir.dirp = NULL;
spl_filesystem_dir_open(spl_filesystem_object*)
static void spl_filesystem_dir_open(intern->u.dir.entry.d_name)
spl_filesystem_dir_open(intern, char *path);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, null);
if (!intern->_path_len) return;
spl_filesystem_dir_open(spl_filesystem_object*
intern->u.dir.dirp = php_stream_open(path, REPORT_ERRORS, NULL);
spl_filesystem_dir_open(intern->flags, SPL_FILE_DIR_SKIPDOTS);
spl_u.dir.dirp = NULL;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))
intern->u.dir.dirp = nsnull;
intern->u.dir.dirp = php_stream_opendir(path, TRUE, NULL);
intern->u.dir.dir = NULL;
/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);
intern->u.dir.dirp = path;
spl_filesystem_dir_read(spl_filesystem_object);
spl_filesystem_dir_open(intern->dir.entry.d_name);
else spl_filesystem_dir_read(intern TSRMLS_CC);
intern->u.dir.dirp = estrndup(path, --intern->_path_len);
intern->u.dir.dirp.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
else spl_filesystem_dir_open(intern->u.dir.entry.d_name);
spl_filesystem_dir_open(intern->u.dir.open);
else  spl_filesystem_dir_write(intern TSRMLS_CC);
intern->u.dir.dirp = null;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERROR, NULL);
if (!intern->u.dir.dirp) return;
(void) spl_filesystem_dir_read(intern TSRMLS_CC);
if (!intern->_path_len)  return;
/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);
spl_filesystem_dir_open(spl_filesystem_object*, char *path)
spl_filesystem_dir_open(spl_filesystem_object* intern, char *name)
spl_filesystem_dir_free(intern->u.dir.dirp);
/* skip dots */
if (intern->u.dir.dirp == NULL)
spl_u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
spl_filesystem_dir_open(spl_filesystem_object*);
spl_filesystem_dir_read(internTSRMLS_CC);
intern->u.dir.dir.dirp = NULL;
else  break;
spl_filesystem_dir_empty(intern->u.dir.entry.d_name);
if (intern->u.dir.dirp == NULL) return;
intern->u.dir.dirp = php_stream_opendir(path,
/* throw exception: should have been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1 && IS_SLASH_AT(path,
/* XXX */ /* XXX */
if (!spl_filesystem_dir_open(intern->u.dir.entry.d_name)) return;
else spl_filesystem_dir_open(intern TSRMLS_DC);
(void)spl_filesystem_dir_read(intern TSRMLS_CC);
spl_filesystem_dir_write(spl_filesystem_object);
intern->u.dir.dirp->dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
do  spl_filesystem_dir_read(intern TSRMLS_CC);
spl_filesystem_dir_close(intern->u.dir.entry.d_name);
printf("spl_filesystem_dir_open: %sn", path);
spl_filesystem_dir_open(spl_filesystem_object* intern->u.dir.entry.d_name);
spl_filesystem_dir_open(spl_filesystem_object*, TSRMLS_DC);
spl_filesystem_dir_open(intern->u.dir.entry.d_name[0]);
spl_filesystem_dir_open(spl_filesystem_object* intern, char *name);
spl_filesystem_dir_open(intern->u.dir.entry.name);
spl_filesystem_dir_open(spl_filesystem_object*, intern);
,
spl_filesystem_dir_open(spl_filesystem_object*, intern, char *path);
spl_filesystem_dir_open(spl_filesystem_object* intern, const char *path)
spl_filesystem_dir_open(intern->flags, SPL_FS_DIR_SKIPDOTS);
spl_filesystem_dir_open(spl_filesystem_object* spl_filesystem_dir_open);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, 0, NULL);
spl_filesystem_dir_open(intern->u.dir.entry.dirp);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))
spl_filesystem_dir_open(spl_filesystem_object, intern->u.dir.entry.d_name);
/* XXX */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
static void spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC);
spl_filesystem_dir_open(spl_filesystem_object* intern)
else  do  spl_filesystem_dir_open(intern TSRMLS_DC);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); break;
spl_filesystem_dir_open(spl_filesystem_object* spl, char *path);
spl_filesystem_dir_open(spl_filesystem_object* intern, char **path);
spl_filesystem_dir_open(spl_filesystem_object*, char *path TSRMLS_DC);
intern->u.dir.dirp = php_stream_opendir(path, FILE_DIR_SKIPDOTS);
if (!spl_filesystem_dir_open(intern->u.dir.entry.d_name))  return;
spl_filesystem_dir_open(spl_filesystem_object* extern, char *path TSRMLS_DC);
intern->u.dir.dirp = php_stream_opendir(path, &intern->_path_len);
/* XXX: shouldn't fix it up yet... */
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1))  /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1))  /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1)  /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);  intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL)  /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));   /* skip_dots = SPL_HAS_FLAG(intern->
/* if (!!is_flags) return;
/* XXX - if any */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL))  /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0))  spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))  spl_dir.dirp = estrndup(path, --intern->_path_len);  if (EG(exception) || intern->u.dir.dirp == NULL)  /* throw exception: should
/* clear path for */
/* XXX - is not free or not yet free-null. */
/* XXX - XXX should work */ if (spl_dir.dirp == NULL)  /* throw exception: should have been already done */ spl_dir.dirp = 0;  else  do  spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* don't do this as well */
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))  if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))  if (estrndup(path, --intern->_path_len)  else  if (EG(exception) || intern->u.dir.dirp == NULL)  /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_cmd == '0')  /* use the uint32_t */ break;
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name)))  /* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*)))  /* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
if (!is_rootroot)  /* XXX */ return;
/* ignore a dir resource */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);  intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL)  /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));  /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name))  /* save the name of a '%s' in the
/* * Free a directory resource. */ spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC);
/* in case spl_resources '' (ie) is already done */ /* open a directory resource */
if (!spl_filesystem_dir_open)  /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1))  /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp)  /* * Is the safe place to read the user's data and the DB's filesystem database? */  else  /* * XXX '%s' does not support '0', * 0)  spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * If we are the new in spl_filesystem_dir_open we are going to revert and open it from the root directory * and get it * to a directory if we don't know the type of the spl_filesystem_dir_open, we're in it now. */ if (intern->_path_len > 1)  spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1))  /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR)  if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1))  pstrlen(path); pstrlen(path);  else  pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (spl_filesystem_is_dot(intern->u.dir.entry.d_name) == 0)
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1)))  /* remove the filesystem */  if (intern->_path_len > 1)  /* remove the filesystem */
/* throw exception: shouldn't have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);
/* XXX XXX */
/* try spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC) */
/* don't open a directory resource! */
/* * No static flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1)  /* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
else  /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS)  /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);  if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS)  /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);  if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0))  /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* throw exception: should have been already happened */
if (intern->_path_len > 1)  if (IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);  u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL)  /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull == path)  /* don't give error to nsnull; do  spl_filesystem_dir_read(intern TSRMLS_CC);
/* get the directory spl_filesystem_dir_open(), then _cpl_dir_open(intern->u.dir.entry.d_name); */
if (intern->_path_len > 1)  if (IS_SLASH_AT(path, &intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
if (Intern->_path_len > 1)  /* ignore this error */
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '0'))  spl_filesystem_dir_read(intern TSRMLS_CC);
/* don't know what to do with spl_filesystem_dir_open (SPL_FILE_DIR_SKIPDOTS)? */
/* skip the files to start in the filesystem. */ if (!intern->spl_filesystem_path_is_dot(intern->u.dir.entry.d_name))  /* not a directory, use spl_filesystem_dir_open() */ return;
else  /* throw exception: should have been already done */  if (spl_filesystem_is_dot(intern->u.dir.entry.d_name))  /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = spl_filesystem_dir_open(spl_filesystem_object*, intern->type);
else  do  spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags)  /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots)))  /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots))  /* do nothing to do */ iocmd_is_type(spl_dots)  if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots)  /* do nothing to do */ iocmd_is_type(spl_dots)  /* do nothing to do *
/* ignore spl_filesystem_dir_open. */
/* clear spl_filesystem_dir_open */ /* clear spl_filesystem_dir_open */
if (ioctl)  spl_filesystem_dir_open(spl_filesystem_object*, NULL);
#if defined(DEBUG) if (intern->u.dir.dirp == NULL)  printf("spl: open a directory resource */ return -1;  #endif
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp)  /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL))  /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp))  spl_filesystem_dir_write(intern->u.dir.dirp);   /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* this is not possible in an open-dir, just if we don't want to make it */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*));
/* XXX we've got to allocate the free directory and we don't know which path we'll need. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1))  /* do not try to clean up the directory resource */  /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len  3))  /* fix up a directory resource */  else  /* fix up a directory resource */  /* delete it from the directory */  if ((intern->_path_len - 1) > 1) && (intern->_path_len  4))  /* lock the directory resources */
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1))  /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name));  else  /* XXX */  /* XXX */
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1))  fsid = fsid;  else  fsid = fsid;
/* * Open a directory resource */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))  if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1))  /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_type == SPL_FS_DIR)  spl_filesystem_dir_open(spl_filesystem_object*, &spl_path_len);
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path)))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
/* XXX*/
/* XXX ignore that it's only temporary. */
/* * Write a directory and start the thread */ spl_filesystem_dir_open(spl_filesystem_object*, intern, char *path);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name)  1)  /* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * The cache cvs */ cvs = spl_filesystem_dir_open(intern->u.dir.entry.d_name); if (cvs)  cvs->spl_reply("spl_filesystem_dir_open: %s", cvs);
if (spl_filesystem_dots && spl_filesystem_is_dot(spl_filesystem_dot(spl_filesystem_dir_open(spl_filesystem_object))))
if (intern->_path_len > 0 && IS_SLASH_AT(path, (unsigned char *)ptr))
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS)  /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR)  /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS)  /* XXX is a different one. */ break;   if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
#if defined(DEBUG_USER_DEBUG) if (!debug_debug) debug_debug("%s", __func__); #endif
if (!spl_dir.dirp)  spl_dir.dirp = NULL;
if (intern->_path_len > 1)  /* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));  /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR)  intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --inter
/* check if we can have an interface. */ if (is_close)  if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  if (is_close)  if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  if (IS_SLASH_AT(path, intern->_path_len-1))  if (is_close)  if (is_close)  if (intern->_path_len > 1)  if (IS_SLASH_AT(path, intern->_path_len-1))  if (IS_SLASH_AT(path, intern->_path_len-1))  if (IS_SLASH_AT(path, intern->_path_len-1))  if (IS_SLASH_AT(path, intern->_path_len-
if (!intern->_path_len) return -1;
/* * check for missing data that can be found */ if (spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS)) == -1)  spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS));
/* try to free spl_filesystem_dir_open to the server if the spl_filesystem_dir_open was created. */ if (spl_spl_dir.dirp == NULL)  /* save spl_filesystem_dir_open. */ spl_filesystem_dir_write(spl_filesystem_dir_open);
if (intern->_path_len > 1)  /* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open))  spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* open a directory resource */ /* open a directory resource */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 1)  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i)  int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);  else if (i)  int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0)  /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1)  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
/* try to resync */ /* if (no_dots)  return (NULL);
/* * Open a directory resource */
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name))  /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->dir.dirp == NULL)  /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* find a directory */ if (dirp == NULL)  /* find directory */ if (dirp == NULL)  /* find directory */
/* ignore all unrefs */ if (spl_filesystem_dir_empty)  spl_filesystem_dir_empty(spl_filesystem_dir_empty);
if (is_shutdown(path, NULL))
if (!intern->_path_len)  /* throw exception: %sn", errno);
if (is_lash_at(path, _filesystem_dirp))  /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip_dots */ /* open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC); int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); intern->type = SPL_FS_DIR; intern->_path_len = strlen(path); /* open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC); /* open a directory resource */
if (intern->_path_len > 1)  /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))  /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len);  else  /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!is_filesystem_dir_open(intern->u.dir.entry.d_name))  /* destroy a filesystem resource */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* reset a resource */ if (intern->_path_len > 1)  /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1))  /* * The directory is unlinked */ url->url_len = url->url_len;  else  url->url_len = url->url_len;
if (!spl_filesystem_is_dot(intern->u.dir.entry.d_name))  return 0;
/* break */ spl_filesystem_dir_open(spl_filesystem_object* intern, char *path);
if ((path == '0') && (nsnull == spl_dir.dirp))  /* let's use a filesystem dir, to set ns directory names */ return -1;
if (!intern->_path_len && is_SLASH_AT(path, 1, 0))  /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open);  else  spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
if (spl_path_len == 0)  spl_path_unref(spl_path_len, 0);
/* break params in the directory system */ if (spl_flags_in_dir(intern->flags, SPL_FS_DIR_SKIPDOTS) == 0) break;
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1)))  /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (!g_found)  /* XXX */
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__)  if (__func__ == __func__)  spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs)  if (Intern->u.dir.dirp == NULL)  /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);  else  /* XXX */
if (nsnull!= spl_filesystem_dir_open)  /* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0)  /* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);  intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL)  /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0';  else  do  spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name))  spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name));   if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1))  if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  if (is_SLASH_AT(path, intern->_path_len-1))  if (
else  /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * To do this again, the "local filesystem %s" */ %(local_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL)  #if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exitingn")); #endif
/* XXX - if this is a directory, make sure it is not. */ if (spl_path_len >= 1)  PR_LOG(PhWARN, "spl_path_len %d is not a directory" % (path + 1), &spl_path_len); break;
/* skip dots in open a directory resource. */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG)  /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG)  /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG)  /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG)  /* Write the cache and clear the cache. */ break;   else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG)  /* * The cache is the correct case */ /* *
/* check if any */ spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name); spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name);
/* * Don't open a directory resource! */
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1))  intern->_path = estrndup(path, --intern->_path_len);  else  intern->_path = estrndup(path, --intern->_path_len);
/* XXX should be */ if (spl_filesystem_dir_open(intern->u.dir.entry.d_name)!= 0)  /* get a directory resource */
/* FIXME: nsdb */
if (intern->dir.dirp == NULL)  /* throw exception: should've been already done */ if (spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name))
/* XXX: the directory name is 0 */ /* ignore it's not an object! */ if (spl_filesystem_is_dot(spl_filesystem_object_dir))  /* handle this function if there is a filesystem name */ return;
if (is_file_unmodifiable(path))  /* XXX */ spl_filesystem_dir_read(intern TSRMLS_CC);
if (spl_filesystem_dir_flags && SPL_FS_DIR_SKIPDOTS)  /* try to open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); spl_filesystem_dir_free(spl_filesystem_object);
/* * open a directory resource */
/* in py_py -f %s, %s, %s, %s */ if (inline->flags & SPL_NOT_OBSERVER_SHOULD_NO_OBSERVER)  return (0);
else  /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL)  /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL)  /* * This is not necessary. */
if (intern->_path_len > 1)  spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1)  /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern);  else  /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0'))  /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC);  while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* don't */
/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); intern->type = SPL_FS_DIR;
/* XXX don't have a space for spl_filesystem_dir_open() */ if (intern->_path_len > 0 && IS_SLASH_AT(path, /* XXX */ 0, /* XXX */ 0))  /* do not open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0,

/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) </* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
<else &intern->_path = estrndup(path, --intern->_path_len);
else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ </* XXX */
else do spl_filesystem_dir_open(intern TSRMLS_DC);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
&else
else <do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ if (intern->_path_len > 1) &/* remove the filesystem */
/* ignore all unrefs */ if (spl_filesystem_dir_empty) <spl_filesystem_dir_empty(spl_filesystem_dir_empty);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
&else do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* skip the files to start in the filesystem. */ if (!intern->spl_filesystem_path_is_dot(intern->u.dir.entry.d_name)) /* not a directory, use spl_filesystem_dir_open() */ return;
<else &spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (is_lash_at(path, _filesystem_dirp)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '&0')) spl_filesystem_dir_read(intern TSRMLS_CC);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else &do <spl_filesystem_dir_open(intern TSRMLS_DC);
<else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if ((path == '&0') && (nsnull == spl_dir.dirp)) &/* let's use a filesystem dir, to set ns directory names */ return -1;
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; <else fsid = fsid;
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ /* XXX */
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1) &/* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
<else do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &do &spl_filesystem_dir_open(intern TSRMLS_DC);
/* try to free spl_filesystem_dir_open to the server if the spl_filesystem_dir_open was created. */ if (spl_spl_dir.dirp == NULL) </* save spl_filesystem_dir_open. */ spl_filesystem_dir_write(spl_filesystem_dir_open);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; &else &fsid = fsid;
<else intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if ((path == '<0') && (nsnull == spl_dir.dirp)) </* let's use a filesystem dir, to set ns directory names */ return -1;
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ &if (intern->_path_len > 1) /* remove the filesystem */
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ &/* XXX */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) &1) /* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
<else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ </* XXX */
/* find a directory */ if (dirp == NULL) </* find directory */ if (dirp == NULL) </* find directory */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
<else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
<else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
else do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* find a directory */ if (dirp == NULL) /* find directory */ if (dirp == NULL) &/* find directory */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (!intern->_path_len) </* throw exception: %s&n", errno);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (spl_cmd == '<0') &/* use the uint32_t */ break;
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
/* * No static flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) </* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ /* XXX */
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ /* XXX */
#endif
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; &else &fsid = fsid;
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
<else <do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) printf("spl: open a directory resource */ return -1; <#endif
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
<else
<else <spl_filesystem_dir_open(intern TSRMLS_DC);
&else <spl_filesystem_dir_open(intern TSRMLS_DC);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
if ((path == '0') && (nsnull == spl_dir.dirp)) &/* let's use a filesystem dir, to set ns directory names */ return -1;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else <do <spl_filesystem_dir_open(intern TSRMLS_DC);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
&else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
&else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) /* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) /* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
&else do <spl_filesystem_dir_open(intern TSRMLS_DC);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
return NULL;
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ /* XXX */
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
<else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (spl_filesystem_dir_flags && SPL_FS_DIR_SKIPDOTS) </* try to open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); spl_filesystem_dir_free(spl_filesystem_object);
if (intern->_path_len > 1) /* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
&else <spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) printf("spl: open a directory resource */ return -1; &#endif
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ /* XXX */
if (intern->dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ /* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ </* XXX */
else <do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
&else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
<else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else &spl_filesystem_dir_read(intern TSRMLS_CC);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* skip the files to start in the filesystem. */ if (!intern->spl_filesystem_path_is_dot(intern->u.dir.entry.d_name)) &/* not a directory, use spl_filesystem_dir_open() */ return;
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
&else spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ &/* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
&else <do <spl_filesystem_dir_open(intern TSRMLS_DC);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (is_lash_at(path, _filesystem_dirp)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
<else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else do &spl_filesystem_dir_open(intern TSRMLS_DC);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; <else <fsid = fsid;
if (ioctl) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* try to free spl_filesystem_dir_open to the server if the spl_filesystem_dir_open was created. */ if (spl_spl_dir.dirp == NULL) &/* save spl_filesystem_dir_open. */ spl_filesystem_dir_write(spl_filesystem_dir_open);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open(intern->u.dir.entry.d_name)) <return;
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ &/* XXX */
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (is_lash_at(path, _filesystem_dirp)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
<else do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
<else do <spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ &/* XXX */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
else do &spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else &do &spl_filesystem_dir_read(intern TSRMLS_CC);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * No static &flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) /* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
&else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull == path) &/* don't give error to nsnull; do <spl_filesystem_dir_read(intern TSRMLS_CC);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
printf("spl_filesystem_dir_open: %s&n", path);
else &spl_filesystem_dir_write(intern TSRMLS_CC);
&#endif
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (is_shutdown(path, NULL))
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ &/* XXX */
<else &spl_filesystem_dir_read(intern TSRMLS_CC);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
.d_name = '0';
if ((path == '&0') && (nsnull == spl_dir.dirp)) </* let's use a filesystem dir, to set ns directory names */ return -1;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ &/* XXX */
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (!intern->_path_len) &/* throw exception: %s&n", errno);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) &printf("spl: open a directory resource */ return -1; <#endif
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ &/* XXX */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ &/* XXX */
&else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
&else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * If we are the new in spl_filesystem_dir_open we are going to revert and open it from the root directory * and get it * to a directory if we don't know the type of the spl_filesystem_dir_open, we're in it now. */ if (intern->_path_len > 1) &spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
&else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
if (Intern->_path_len > 1) /* ignore this error */
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else <do &spl_filesystem_dir_open(intern TSRMLS_DC);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ if (intern->_path_len > 1) &/* remove the filesystem */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ &/* XXX */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) </* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ </* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else <spl_filesystem_dir_read(intern TSRMLS_CC);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) <printf("spl: open a directory resource */ return -1; <#endif
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->dir.dirp == NULL) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) 1) &/* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
else <spl_filesystem_dir_write(intern TSRMLS_CC);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
<else <spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ &if (intern->_path_len > 1) /* remove the filesystem */
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = '0';
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
else &do &spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
<else do <spl_filesystem_dir_read(intern TSRMLS_CC);
if (spl_cmd == '0') /* use the uint32_t */ break;
<else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len) /* throw exception: %s<n", errno);
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ &if (intern->_path_len > 1) /* remove the filesystem */
else spl_filesystem_dir_open(intern TSRMLS_DC);
<else &do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
else if (!g_found) /* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
if (spl_cmd == '<0') /* use the uint32_t */ break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) <#if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exitingn")); #endif
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) &/* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) </* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ <if (intern->_path_len > 1) </* remove the filesystem */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * check for missing data that can be found */ if (spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS)) == -1) <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
<else <do &spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * check for missing data that can be found */ if (spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS)) == -1) &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS));
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
else spl_filesystem_dir_read(intern TSRMLS_CC);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ </* XXX */
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; &else fsid = fsid;
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; <else <fsid = fsid;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ &/* XXX */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (nsnull!= spl_filesystem_dir_open) &/* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) /* XXX */
&else spl_filesystem_dir_open(intern TSRMLS_DC);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else <intern->_path = estrndup(path, --intern->_path_len);
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
intern->u.dir.dirp = '<0';
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; else &fsid = fsid;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
&else &spl_filesystem_dir_write(intern TSRMLS_CC);
intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
.d_name = '<0';
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ </* XXX */
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; else <fsid = fsid;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) </* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
<else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '<0')) <spl_filesystem_dir_read(intern TSRMLS_CC);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
&else do spl_filesystem_dir_read(intern TSRMLS_CC);
/* XXX: the directory name is 0 */ /* ignore it's not an object! */ if (spl_filesystem_is_dot(spl_filesystem_object_dir)) </* handle this function if there is a filesystem name */ return;
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (spl_path_len == 0) <spl_path_unref(spl_path_len, 0);
&else do <spl_filesystem_dir_read(intern TSRMLS_CC);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) &printf("spl: open a directory resource */ return -1; #endif
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ /* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
&else spl_filesystem_dir_write(intern TSRMLS_CC);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else break;
<else spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else <spl_filesystem_dir_read(intern TSRMLS_CC);
/* XXX should be */ if (spl_filesystem_dir_open(intern->u.dir.entry.d_name)!= 0) /* get a directory resource */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
&else do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC)
<else <do spl_filesystem_dir_read(intern TSRMLS_CC);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
if (intern->_path_len > 1) /* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ /* XXX */
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ &if (intern->_path_len > 1) &/* remove the filesystem */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; &else <fsid = fsid;
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else <intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
/* XXX: the directory name is 0 */ /* ignore it's not an object! */ if (spl_filesystem_is_dot(spl_filesystem_object_dir)) /* handle this function if there is a filesystem name */ return;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ /* XXX */
else
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
else &do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull == path) </* don't give error to nsnull; do <spl_filesystem_dir_read(intern TSRMLS_CC);
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ /* XXX */
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; else fsid = fsid;
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
if (nsnull!= spl_filesystem_dir_open) &/* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) </* XXX */
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ </* XXX */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* XXX - if this is a directory, make sure it is not. */ if (spl_path_len >= 1) &PR_LOG(PhWARN, "spl_path_len %d is not a directory" % (path + 1), &spl_path_len); break;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
<else break;
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '0')) spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) </* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* find a directory */ if (dirp == NULL) &/* find directory */ if (dirp == NULL) </* find directory */
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ &if (intern->_path_len > 1) &/* remove the filesystem */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ </* XXX */
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
else <do spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ /* XXX */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ &/* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ <if (intern->_path_len > 1) &/* remove the filesystem */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
.d_name = '&0';
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ /* XXX */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
&else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * No static &flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) &/* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* in py_py -f %s, %s, %s, %s */ if (inline->flags & SPL_NOT_OBSERVER_SHOULD_NO_OBSERVER) &return (0);
<else &do spl_filesystem_dir_open(intern TSRMLS_DC);
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (!is_rootroot) </* XXX */ return;
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ /* XXX */
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &return 0;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
&else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) &/* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) /* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) <1) &/* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ /* XXX */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else <do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
printf("spl_filesystem_dir_open: %sn", path);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->dir.dirp == NULL) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '0')) &spl_filesystem_dir_read(intern TSRMLS_CC);
if (!spl_dir.dirp) spl_dir.dirp = NULL;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* * check for missing data that can be found */ if (spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS)) == -1) spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, SPL_FS_DIR_SKIPDOTS));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) </* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
do spl_filesystem_dir_read(intern TSRMLS_CC);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) </* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (Intern->_path_len > 1) </* ignore this error */
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
if (!spl_filesystem_dir_open(intern->u.dir.entry.d_name)) return;
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (nsnull == path) &/* don't give error to nsnull; do &spl_filesystem_dir_read(intern TSRMLS_CC);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* find a directory */ if (dirp == NULL) /* find directory */ if (dirp == NULL) </* find directory */
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* XXX don't have a space for spl_filesystem_dir_open() */ if (intern->_path_len > 0 && IS_SLASH_AT(path, /* XXX */ 0, /* XXX */ 0)) /* do not open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0,
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
<else <do <spl_filesystem_dir_open(intern TSRMLS_DC);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) &/* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) &/* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) /* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) </* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* find a directory */ if (dirp == NULL) </* find directory */ if (dirp == NULL) &/* find directory */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
<else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
if ((path == '<0') && (nsnull == spl_dir.dirp)) /* let's use a filesystem dir, to set ns directory names */ return -1;
if (intern->_path_len > 1) &/* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
<else do &spl_filesystem_dir_read(intern TSRMLS_CC);
else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else <do &spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) <printf("spl: open a directory resource */ return -1; #endif
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
if (spl_filesystem_dots && spl_filesystem_is_dot(spl_filesystem_dot(spl_filesystem_dir_open(spl_filesystem_object))))
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else <do &spl_filesystem_dir_open(intern TSRMLS_DC);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ &/* XXX */
<else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
&else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ </* XXX */
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
<else do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - if this is a directory, make sure it is not. */ if (spl_path_len >= 1) <PR_LOG(PhWARN, "spl_path_len %d is not a directory" % (path + 1), &spl_path_len); break;
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ </* XXX */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (!spl_dir.dirp) &spl_dir.dirp = NULL;
else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull!= spl_filesystem_dir_open) /* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) </* XXX */
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (nsnull == path) &/* don't give error to nsnull; do spl_filesystem_dir_read(intern TSRMLS_CC);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ &/* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
else <spl_filesystem_dir_read(intern TSRMLS_CC);
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
else &do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len) &return;
<else &do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ </* XXX */
else &spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull!= spl_filesystem_dir_open) </* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) &/* XXX */
<else <do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * If we are the new in spl_filesystem_dir_open we are going to revert and open it from the root directory * and get it * to a directory if we don't know the type of the spl_filesystem_dir_open, we're in it now. */ if (intern->_path_len > 1) spl_filesystem_dir_read(intern TSRMLS_CC);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) &/* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) &/* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ </* XXX */
<else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ &/* XXX */
else spl_filesystem_dir_read(intern TSRMLS_CC);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ </* XXX */
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ <if (intern->_path_len > 1) &/* remove the filesystem */
&else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) &/* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
if (nsnull!= spl_filesystem_dir_open) /* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) &/* XXX */
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) &/* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
<else spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <return 0;
if (intern->_path_len > 1) spl_filesystem_dir_open(intern->u.dir.entry.d_name);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
.d_name[0] = '0';
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
&else if (!g_found) /* XXX */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
<else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* in py_py -f %s, %s, %s, %s */ if (inline->flags & SPL_NOT_OBSERVER_SHOULD_NO_OBSERVER) return (0);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; &else &fsid = fsid;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
else &spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) &#if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exitingn")); #endif
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ if (intern->_path_len > 1) </* remove the filesystem */
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ /* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else <spl_filesystem_dir_open(intern TSRMLS_DC);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
<else &do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
&else &do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
&else spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ if (intern->_path_len > 1) </* remove the filesystem */
else do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
else <spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ &if (intern->_path_len > 1) </* remove the filesystem */
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) /* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) &/* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ &if (intern->_path_len > 1) &/* remove the filesystem */
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
&else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) printf("spl: open a directory resource */ return -1; #endif
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; &else fsid = fsid;
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
<else &spl_filesystem_dir_open(intern->u.dir.entry.d_name);
<else if (!g_found) /* XXX */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ &/* XXX */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
<else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
<else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len) return;
/* XXX - if this is a directory, make sure it is not. */ if (spl_path_len >= 1) PR_LOG(PhWARN, "spl_path_len %d is not a directory" % (path + 1), &spl_path_len); break;
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * No static &flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) </* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
return 0;
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* try to resync */ /* if (no_dots) <return (NULL);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; <else fsid = fsid;
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
<else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else <do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
&else <break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
&else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (is_lash_at(path, _filesystem_dirp)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
else &spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '<0')) spl_filesystem_dir_read(intern TSRMLS_CC);
if (spl_type == SPL_FS_DIR) spl_filesystem_dir_open(spl_filesystem_object*, &spl_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else <spl_filesystem_dir_open(intern TSRMLS_DC);
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
&else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; <else fsid = fsid;
if (intern->_path_len > 1) /* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; &else <fsid = fsid;
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ /* XXX */
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) </* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &break;
&else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (spl_path_len == 0) spl_path_unref(spl_path_len, 0);
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ /* XXX */
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->dir.dirp == NULL) /* throw exception: should've been already done */ if (spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name))
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ </* XXX */
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
<else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
&else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ </* XXX */
if (nsnull!= spl_filesystem_dir_open) /* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) /* XXX */
if (intern->dir.dirp == NULL) &/* throw exception: should've been already done */ if (spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name))
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) #if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exiting<n")); #endif
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* * No static <flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) </* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ <if (intern->_path_len > 1) /* remove the filesystem */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
&else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ if (intern->_path_len > 1) /* remove the filesystem */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
<else do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
if (spl_filesystem_dir_flags && SPL_FS_DIR_SKIPDOTS) /* try to open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); spl_filesystem_dir_free(spl_filesystem_object);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = NULL;
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_cmd == '0') </* use the uint32_t */ break;
else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * No static flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) &/* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
/* XXX don't have a space for spl_filesystem_dir_open() */ if (intern->_path_len > 0 && IS_SLASH_AT(path, /* XXX */ 0, /* XXX */ 0)) &/* do not open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0,
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ </* XXX */
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->dir.dirp == NULL) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '0')) <spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * No static <flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) &/* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
&else <do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
else &do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else <do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (is_lash_at(path, _filesystem_dirp)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ /* XXX */
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) &1) &/* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
else break;
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else <url->url_len = url->url_len;
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* find a directory */ if (dirp == NULL) &/* find directory */ if (dirp == NULL) &/* find directory */
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ &/* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1) /* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &spl_filesystem_dir_open(intern TSRMLS_DC);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else <break;
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ &/* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
<else <intern->_path = estrndup(path, --intern->_path_len);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ </* XXX */
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ /* XXX */
else intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
printf("spl_filesystem_dir_open: %s<n", path);
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) <1) </* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (!g_found) &/* XXX */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) &/* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* * The cache cvs */ cvs = spl_filesystem_dir_open(intern->u.dir.entry.d_name); if (cvs) <cvs->spl_reply("spl_filesystem_dir_open: %s", cvs);
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->dir.dirp == NULL) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
else do <spl_filesystem_dir_read(intern TSRMLS_CC);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
else <do &spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 1) </* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
<else <intern->_path = estrndup(path, --intern->_path_len);
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else spl_filesystem_dir_open(intern TSRMLS_DC);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; <else <fsid = fsid;
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &spl_filesystem_dir_open(intern TSRMLS_DC);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) 1) /* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
else <spl_filesystem_dir_open(intern TSRMLS_DC);
&else do spl_filesystem_dir_open(intern TSRMLS_DC);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
else spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
else &spl_filesystem_dir_read(intern TSRMLS_CC);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else <do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
&else &do <spl_filesystem_dir_read(intern TSRMLS_CC);
&else &spl_filesystem_dir_open(intern->u.dir.entry.d_name);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
<else &do <spl_filesystem_dir_open(intern TSRMLS_DC);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
else spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
<else <do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (is_lash_at(path, _filesystem_dirp)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
if (!intern->_path_len) </* throw exception: %sn", errno);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* try to resync */ /* if (no_dots) &return (NULL);
else <do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ </* XXX */
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
else <do spl_filesystem_dir_open(intern TSRMLS_DC);
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
&else &spl_filesystem_dir_read(intern TSRMLS_CC);
else &do <spl_filesystem_dir_read(intern TSRMLS_CC);
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) #if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exiting&n")); #endif
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ <if (intern->_path_len > 1) /* remove the filesystem */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* * The cache cvs */ cvs = spl_filesystem_dir_open(intern->u.dir.entry.d_name); if (cvs) &cvs->spl_reply("spl_filesystem_dir_open: %s", cvs);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
else do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* find a directory */ if (dirp == NULL) /* find directory */ if (dirp == NULL) /* find directory */
.d_name[0] = '&0';
<else &do &spl_filesystem_dir_read(intern TSRMLS_CC);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* ignore all unrefs */ if (spl_filesystem_dir_empty) &spl_filesystem_dir_empty(spl_filesystem_dir_empty);
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
<else &spl_filesystem_dir_read(intern TSRMLS_CC);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else spl_filesystem_dir_read(intern TSRMLS_CC);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) /* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ if (intern->_path_len > 1) /* remove the filesystem */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (spl_cmd == '&0') </* use the uint32_t */ break;
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) /* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) <printf("spl: open a directory resource */ return -1; &#endif
/* in py_py -f %s, %s, %s, %s */ if (inline->flags & SPL_NOT_OBSERVER_SHOULD_NO_OBSERVER) <return (0);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ &/* XXX */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_cmd == '<0') </* use the uint32_t */ break;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (!is_rootroot) &/* XXX */ return;
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ </* XXX */
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
intern->u.dir.dirp = '&0';
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
intern->_path = '<0';
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
<else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
.d_name[0] = '<0';
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
&else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) </* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
<else &do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ </* XXX */
if (spl_filesystem_dir_flags && SPL_FS_DIR_SKIPDOTS) &/* try to open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); spl_filesystem_dir_free(spl_filesystem_object);
return (0);
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else <spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
else if (!g_found) </* XXX */
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
spl_filesystem_dir_read(intern TSRMLS_CC);
<else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) /* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) <#if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exiting&n")); #endif
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
&else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
&else do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->dir.dirp == NULL) </* throw exception: should've been already done */ if (spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name))
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) &1) </* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else spl_filesystem_dir_write(intern TSRMLS_CC);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 1 && IS_SLASH_AT(path, *intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
&else &do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (spl_path_len == 0) &spl_path_unref(spl_path_len, 0);
&else spl_filesystem_dir_read(intern TSRMLS_CC);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (is_file_unmodifiable(path)) &/* XXX */ spl_filesystem_dir_read(intern TSRMLS_CC);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if ((path == '0') && (nsnull == spl_dir.dirp)) </* let's use a filesystem dir, to set ns directory names */ return -1;
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else &url->url_len = url->url_len;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ </* XXX */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) &/* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ &/* XXX */
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ /* XXX */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) 1) </* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
&else do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) </* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
<else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
<else <break;
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
else &do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) </* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) </* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
spl_filesystem_dir_is_dot(intern->u.dir.entry.d_name);
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
else spl_filesystem_dir_write(intern TSRMLS_CC);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
else &do spl_filesystem_dir_read(intern TSRMLS_CC);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; else <fsid = fsid;
<else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &do <spl_filesystem_dir_open(intern TSRMLS_DC);
&else <spl_filesystem_dir_read(intern TSRMLS_CC);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) /* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
if (is_file_unmodifiable(path)) </* XXX */ spl_filesystem_dir_read(intern TSRMLS_CC);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* XXX don't have a space for spl_filesystem_dir_open() */ if (intern->_path_len > 0 && IS_SLASH_AT(path, /* XXX */ 0, /* XXX */ 0)) </* do not open a directory resource */ spl_filesystem_dir_open(spl_filesystem_object*, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0, /* XXX */ 0,
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else do <spl_filesystem_dir_open(intern TSRMLS_DC);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; &else <fsid = fsid;
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
&else &do &spl_filesystem_dir_open(intern TSRMLS_DC);
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else <do <spl_filesystem_dir_read(intern TSRMLS_CC);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1) </* * Remove the '<0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else <do spl_filesystem_dir_read(intern TSRMLS_CC);
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
<else spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else <spl_filesystem_dir_write(intern TSRMLS_CC);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (nsnull == path) /* don't give error to nsnull; do spl_filesystem_dir_read(intern TSRMLS_CC);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ /* XXX */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
&else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX should be */ if (spl_filesystem_dir_open(intern->u.dir.entry.d_name)!= 0) </* get a directory resource */
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ if (intern->_path_len > 1) /* remove the filesystem */
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else &/* XXX */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ &/* XXX */
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ <if (intern->_path_len > 1) /* remove the filesystem */
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
<else <do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '<0')) &spl_filesystem_dir_read(intern TSRMLS_CC);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (nsnull!= spl_filesystem_dir_open) </* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) </* XXX */
else &intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; else &fsid = fsid;
if (!intern->_path_len) &/* throw exception: %sn", errno);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ /* XXX */
else spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
<else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
do &spl_filesystem_dir_read(intern TSRMLS_CC);
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->dir.dirp == NULL) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 1) &/* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else &url->url_len = url->url_len;
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '&0')) &spl_filesystem_dir_read(intern TSRMLS_CC);
&else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else /* XXX */ </* XXX */
else &spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
else do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (!intern->_path_len) /* throw exception: %s&n", errno);
if (!intern->_path_len) </* throw exception: %s<n", errno);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* try to free spl_filesystem_dir_open to the server if the spl_filesystem_dir_open was created. */ if (spl_spl_dir.dirp == NULL) /* save spl_filesystem_dir_open. */ spl_filesystem_dir_write(spl_filesystem_dir_open);
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ <if (intern->_path_len > 1) </* remove the filesystem */
&else <do spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else <spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
<else &break;
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else </* XXX */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
<else &do spl_filesystem_dir_read(intern TSRMLS_CC);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; else <fsid = fsid;
if (is_lash_at(path, _filesystem_dirp)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
&else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
<else do spl_filesystem_dir_read(intern TSRMLS_CC);
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
<else <do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) /* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) </* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
else do spl_filesystem_dir_read(intern TSRMLS_CC);
else <do <spl_filesystem_dir_read(intern TSRMLS_CC);
<else <do &spl_filesystem_dir_open(intern TSRMLS_DC);
else &do spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ &/* XXX */
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; &else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open(intern->u.dir.entry.d_name)) &return;
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * The cache cvs */ cvs = spl_filesystem_dir_open(intern->u.dir.entry.d_name); if (cvs) cvs->spl_reply("spl_filesystem_dir_open: %s", cvs);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
&else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; <else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (!g_found) </* XXX */
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull == path) </* don't give error to nsnull; do &spl_filesystem_dir_read(intern TSRMLS_CC);
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
<else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
&else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else </* XXX */
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
do <spl_filesystem_dir_read(intern TSRMLS_CC);
&else if (!g_found) </* XXX */
else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, (unsigned char *)ptr))
&else &spl_filesystem_dir_open(intern TSRMLS_DC);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * If this is an internal file, we don't have a hard way to make sure that the filesystem is not inserted */ if ((intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) && (intern->_path_len >= 0 && IS_SLASH_AT(path, intern->_path_len-1))) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
&else &do spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; else &fsid = fsid;
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ if (intern->_path_len > 1) &/* remove the filesystem */
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (!is_filesystem_dir_open(intern->u.dir.entry.d_name)) /* destroy a filesystem resource */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* try to resync */ /* if (no_dots) return (NULL);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
<else spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (nsnull == path) /* don't give error to nsnull; do &spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; &else fsid = fsid;
if (spl_cmd == '&0') /* use the uint32_t */ break;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; else fsid = fsid;
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else <url->url_len = url->url_len;
else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else do spl_filesystem_dir_open(intern TSRMLS_DC);
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
&else <do <spl_filesystem_dir_read(intern TSRMLS_CC);
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
<else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
else <intern->_path = estrndup(path, --intern->_path_len);
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
else do &spl_filesystem_dir_open(intern TSRMLS_DC);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ </* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else &/* XXX */ /* XXX */
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &&if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
/* find a directory */ if (dirp == NULL) </* find directory */ if (dirp == NULL) /* find directory */
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (Intern->_path_len > 1) &/* ignore this error */
if (ioctl) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
&else
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) #if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exitingn")); #endif
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 1) &spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) </* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull!= spl_filesystem_dir_open) </* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) /* XXX */
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) /* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) </* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_cmd == '&0') &/* use the uint32_t */ break;
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (!is_filesystem_dir_open(intern->u.dir.entry.d_name)) </* destroy a filesystem resource */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) </* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else <spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) </* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) &/* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) </* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ </* XXX */
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &<if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
break;
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) &#if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exiting<n")); #endif
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * No static <flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) /* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &do spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
<else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ &/* XXX */
if (!intern->_path_len) /* throw exception: %sn", errno);
if ((path == '0') && (nsnull == spl_dir.dirp)) /* let's use a filesystem dir, to set ns directory names */ return -1;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
<else &do <spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
<else <spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else /* XXX */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (!intern->_path_len) <return;
intern->_path = '&0';
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) </* remove the filesystem */ &if (intern->_path_len > 1) </* remove the filesystem */
<else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ <if (intern->_path_len > 1) </* remove the filesystem */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
&else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ /* XXX */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else <do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len 3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
if (intern->_path_len > 1) /* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (!is_filesystem_dir_open(intern->u.dir.entry.d_name)) &/* destroy a filesystem resource */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * A full path is used for the * entry of the __path. */ if (!(spl_filesystem_dir_open(intern->u.dir.entry.d_name))) </* * Throw a dummy-t* filesystem to be unlocked. */ if (spl_filesystem_dir_open(spl_filesystem_object, &spl_dir_open(spl_filesystem_object*))) /* throw a dummy-t* filesystem to be opened. */ spl_filesystem_dir_open(spl_filesystem_object*);
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) <pstrlen(path); pstrlen(path); <else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ &/* XXX */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* * This should be used for * the "dots" spl_filesystem_dir_open, but the path doesn't exist * so the filesystem * is * read by spl_filesystem_dir_open. */ if (!(intern->u.dir.entry.d_name == '&0')) <spl_filesystem_dir_read(intern TSRMLS_CC);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; <else &fsid = fsid;
else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_open(intern->u.dir.entry.d_name) <1) /* avoid spl_dots. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else &do spl_filesystem_dir_open(intern TSRMLS_DC);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
&else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
<else <do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->dir.dirp == NULL) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else <spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else <do <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); &/* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
<else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) &/* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) &spl_filesystem_dir_open(spl_filesystem_object*, NULL);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
spl_filesystem_dir_write(intern TSRMLS_DC);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) </* * The directory is unlinked */ url->url_len = url->url_len; &else &url->url_len = url->url_len;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) &/* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ </* XXX */
&else do &spl_filesystem_dir_open(intern TSRMLS_DC);
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; &else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else do spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_dir.dirp) <spl_dir.dirp = NULL;
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* * If we are the new in spl_filesystem_dir_open we are going to revert and open it from the root directory * and get it * to a directory if we don't know the type of the spl_filesystem_dir_open, we're in it now. */ if (intern->_path_len > 1) <spl_filesystem_dir_read(intern TSRMLS_CC);
<else do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull == path) </* don't give error to nsnull; do spl_filesystem_dir_read(intern TSRMLS_CC);
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
&else do &spl_filesystem_dir_read(intern TSRMLS_CC);
&else <spl_filesystem_dir_write(intern TSRMLS_CC);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
<else &do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (is_file_unmodifiable(path)) /* XXX */ spl_filesystem_dir_read(intern TSRMLS_CC);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) = 1)) /* do not try to clean up the directory resource */ /* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len <3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
<else &/* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
else &spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; <else <url->url_len = url->url_len;
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); <else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) return 0;
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) </* do not try to clean up the directory resource */ &/* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else intern->_path = estrndup(path, --intern->_path_len);
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ if (intern->_path_len > 1) </* remove the filesystem */
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); &else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
if (nsnull!= spl_filesystem_dir_open) &/* * It's not clear why we don't really want to open the directory. */ if (((*spl_filesystem_dir_open)->insert_filesystem) == 0) &/* XXX */
/* * No static flags' files. */ if (spl_filesystem_dir_open(intern->flags, spl_FILE_DIR_SKIPDOTS) == -1) /* XXX FIXME: the spl_filesystem_dir_open failed */ spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* skip the files to start in the filesystem. */ if (!intern->spl_filesystem_path_is_dot(intern->u.dir.entry.d_name)) </* not a directory, use spl_filesystem_dir_open() */ return;
&else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) &/* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
&else &intern->_path = estrndup(path, --intern->_path_len);
if (spl_type == SPL_FS_DIR) <spl_filesystem_dir_open(spl_filesystem_object*, &spl_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_type == SPL_FS_DIR) &spl_filesystem_dir_open(spl_filesystem_object*, &spl_path_len);
<else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); else spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ /* XXX */
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &do &spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
#if defined(DEBUG) if (intern->u.dir.dirp == NULL) &printf("spl: open a directory resource */ return -1; &#endif
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else </* XXX */ /* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) fsid = fsid; <else &fsid = fsid;
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (ioctl) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1) &/* get a filesystem entry. */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) &/* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) <fsid = fsid; else fsid = fsid;
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); &else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) <#if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exiting<n")); #endif
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
else
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* get an fsid from the log filesystem */ /* * Use SPL_FAS_FLAG (spl_fsid, SPL_FS_DIR); */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &fsid = fsid; <else &fsid = fsid;
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) <if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) &pstrlen(path); pstrlen(path); &else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) &if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
&else <do &spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip the object in the filesystem */ if (!intern->_path_len && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) </* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else
if (intern->_path_len > 1) <spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (is_lash_at(path, _filesystem_dirp)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
<else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) <spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) if (IS_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ &/* XXX */
&else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); else <pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* XXX should be */ if (spl_filesystem_dir_open(intern->u.dir.entry.d_name)!= 0) &/* get a directory resource */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) </* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else /* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &do &spl_filesystem_dir_read(intern TSRMLS_CC);
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
&else <do <spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) /* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) /* throw exception: should have been already done */ spl_dir.dirp = 0; else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) &/* remove the filesystem */ <if (intern->_path_len > 1) &/* remove the filesystem */
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) &/* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) /* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
if (intern->u.dir.dirp == NULL)
<else <spl_filesystem_dir_open(intern TSRMLS_DC);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
<else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else /* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
intern->_path = '0';
/* reset the filesystem idle */ if (spl_fs_flags == 0 &&!(intern->_path_len >= 0 && IS_SLASH_AT(path, &intern->_path_len-1))) /* remove the filesystem */ &if (intern->_path_len > 1) </* remove the filesystem */
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; else url->url_len = url->url_len;
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
<else &spl_filesystem_dir_write(intern TSRMLS_CC);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
&else &/* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) /* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &/* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) &/* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
<else /* throw exception: should have been already done */ if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) &spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
&else <spl_filesystem_dir_open(intern->u.dir.entry.d_name);
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else &/* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
/* find a directory */ if (dirp == NULL) &/* find directory */ if (dirp == NULL) /* find directory */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else /* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) <intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
&else /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (!is_rootroot) /* XXX */ return;
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else /* XXX */
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) /* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) &/* throw exception: should have been already done */ spl_dir.dirp = 0; &else &do <spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* spl_filesystem_dir_open(spl_filesystem_object*) -> unlink; /* spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*, char *path TSRMLS_DC) */ if (intern->type == SPL_FS_DIR) &if (intern->_path_len > 1 && IS_SLASH_AT(path, pstrlen(path) - 1)) pstrlen(path); pstrlen(path); <else &pstrlen(path); pstrlen(path); pstrlen(path); pstrlen(path);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else </* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1) </* * Remove the '&0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) <spl_filesystem_dir_open(spl_filesystem_object*, NULL);
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* reset a resource */ if (intern->_path_len > 1) /* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) &/* * The directory is unlinked */ url->url_len = url->url_len; <else url->url_len = url->url_len;
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) /* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else </* XXX */ </* XXX */
/* * XXX why */ if (intern->_path_len > 0 && IS_SLASH_AT(path, Intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); &else /* XXX */ /* XXX */
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) /* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '<0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) &/* * This is not necessary. */
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); <else </* XXX */
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len);
else &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* throw exception: should have been already done */ &if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) &/* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) </* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) <int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (is_slsh(path, path) &&! (is_slsh(path, path) && (is_slsh(path, path) && is_slsh(path))) &intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len);
<else <do spl_filesystem_dir_open(intern TSRMLS_DC);
else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) &/* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); else &/* XXX */ </* XXX */
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &spl_dir.dirp = estrndup(path, --intern->_path_len); if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) &/* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) /* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) <spl_filesystem_dir_write(intern->u.dir.dirp); </* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
<else <do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else /* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (is_lash_at(path, _filesystem_dirp)) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); &while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_is_dot(intern->u.dir.entry.d_name) == 0)
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else /* XXX */ &/* XXX */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) </* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else </* XXX */ &/* XXX */
if (spl_cmd == '0') &/* use the uint32_t */ break;
<else &do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* * For safe-lock */ if (intern->_path_len > 1 && IS_SLASH_AT(path, &intern->_path_len-1)) /* * If the system has a cached path, * then we may have to allocate the path to the cached path * to the new entry. */ if (intern->_path_len >= 1 && IS_SLASH_AT(path, &intern->_path_len-1)) </* * We can't allocate a cached path, because the path must be extracted as the cached path, because the cached path will be relocated in the filesystem * directory, which might cause cleanups * the stdout. */ if (intern->_path_len >= 1) </* * There is a cached path, so we'll do a cached path in the spl_dir.dirp to make spl_dir.dirp.r
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) &/* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
/* XXX - XXX should work */ if (spl_dir.dirp == NULL) </* throw exception: should have been already done */ spl_dir.dirp = 0; else do &spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (nsnull == path) /* don't give error to nsnull; do <spl_filesystem_dir_read(intern TSRMLS_CC);
&else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_open(spl_filesystem_object*) == NULL) &#if defined(DEBUG_flags) && DEBUG_LOC_TRACE_SUCCEEDED(("FileSystem: spl_filesystem_dir_open: exiting&n")); #endif
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) </* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); else </* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* XXX: This does not make sense to allocate a safe, and it seems to be * much easier than writing to the cache. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * This is a hack to give the host no more than one version of the * bytecode. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) </* * Write the cache and clear it. */ if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) &/* Write the cache and clear the cache. */ break; else if (intern->flags & SPL_FRAME_DIR_LAYER_ARG) /* * The cache is the correct case */ /* *
&else &/* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); </* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (!intern->_path_len) &/* throw exception: %s<n", errno);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else &/* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else &/* do not make the directory */ if (intern->u.dir.entry.d_name == '0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else /* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len);
<else if (!g_found) &/* XXX */
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) </* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) <if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) /* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) <if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
/* reset a resource */ if (intern->_path_len > 1) </* XXX check to see if this is a PKLEvent* problem */ if (intern->_path_len > 0 && is_SLASH_AT(path, url->url_len-1)) /* * The directory is unlinked */ url->url_len = url->url_len; &else url->url_len = url->url_len;
/* XXX: the directory name is 0 */ /* ignore it's not an object! */ if (spl_filesystem_is_dot(spl_filesystem_object_dir)) &/* handle this function if there is a filesystem name */ return;
/* * Fix up the name of the filesystem. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, ip_file_len-1)) &/* no name of filesystem. */ spl_filesystem_dir_read(spl_filesystem_object_open(intern->u.dir.entry.d_name)); <else &/* XXX */ &/* XXX */
/* make sure that the '' directory is already open by the filesystem_dir. */ if (!intern->u.dir.dirp) </* don't break in the list of files. */ /* do not free the directory from the '.' filesystem */ if ((intern->u.dir.dirp = NULL) && (intern->u.dir.dirp = NULL)) </* if no directory exists, run a directory. */ if ((intern->u.dir.dirp = &spl_filesystem_dirp)) spl_filesystem_dir_write(intern->u.dir.dirp); /* if no directory exists, delete the directory and no local directory. */ spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(intern->u.dir.dirp); spl_filesystem_dir_write(
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) </* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) &spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else &intern->_path = estrndup(path, --intern->_path_len);
/* * We need to do this to avoid a struct filesystem dir, if the filesystem is not found. */ if (intern->_path_len > 1) intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
&else if (!g_found) &/* XXX */
<else </* throw exception: should have been already done */ <if (spl_filesystem_is_dot(intern->u.dir.entry.d_name)) &/* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* ignore all unrefs */ if (spl_filesystem_dir_empty) spl_filesystem_dir_empty(spl_filesystem_dir_empty);
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
&else &spl_filesystem_dir_open(intern TSRMLS_DC);
if (!intern->_path_len && is_SLASH_AT(path, 1, 0)) &/* should be zeroed */ spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_dir_open); &else &spl_filesystem_dir_open(spl_filesystem_object*, spl_filesystem_object*);
&else </* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) </* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) /* * This is not necessary. */
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) /* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) /* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) &if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) &else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &/* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); &/* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->type == SPL_FS_DIR) &intern->type = SPL_FS_DIR; if (is_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --inter
if ((path == '&0') && (nsnull == spl_dir.dirp)) /* let's use a filesystem dir, to set ns directory names */ return -1;
else /* throw exception: should've been already done */ if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); &if (intern->u.dir.flags & SPL_FS_DIR_SKIPDOTS) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (intern->u.dir.dirp &&!(strlen(path) &&!(strlen(path) && (strlen(path) = 0)) /* skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE
/* * try again. */ if (intern->_path_len > 1 && IS_SLASH_AT(path, (int)intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
/* * XXX should just use the ':' function. */ if (intern->_path_len > 0 && is_SLASH_AT(path, &intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len);
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) /* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); else &/* XXX */
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) </* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) /* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* XXX is a different one. */ break; &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
/* XXX */ if (spl_disabled_refs &&!spl_disabled_refs) <if (Intern->u.dir.dirp == NULL) </* delete the filesystem. */ spl_filesystem_dir_open(intern->u.dir.entry.d_name); &else &/* XXX */
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) &= 1)) &/* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); else if (i) &int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) </* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
/* open a directory resource */ if ((intern->_path_len > 1) && ((intern->_path_len-1) > 1) && ((intern->_path_len-1) > 0) && ((intern->_path_len-1) <= 1)) </* do not try to clean up the directory resource */ </* ignore the root directory */ if ((intern->_path_len > 1) && (intern->_path_len &3)) /* fix up a directory resource */ else /* fix up a directory resource */ /* delete it from the directory */ if ((intern->_path_len - 1) > 1) && (intern->_path_len 4)) /* lock the directory resources */
if (intern->_path_len > 1) <intern->_path = estrndup(path, --intern->_path_len); &else intern->_path = estrndup(path, --intern->_path_len);
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 1) &/* * Remove the '0' directory. */ if ((nsnull!= spl_filesystem_dir_open) && (nsnull!= spl_filesystem_dir_open)) spl_filesystem_dir_open(spl_filesystem_object*, NULL);
if (intern->_path_len > 1) <if (IS_SLASH_AT(path, &intern->_path_len-1)) intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* throw exception: should've been already happened */ if (elflags || elflags & elflags) &/* throw exception: should've been already happened */ if (iocmd_is_type(&iocmd_is_type(spl_dots))) </* we should ignore '-' to avoid all XP_INET issues. */ if (iocmd_is_type(spl_dots)) </* do nothing to do */ iocmd_is_type(spl_dots) if (iocmd_is_type(spl_dots)) iocmd_is_type(spl_dots) /* do nothing to do */ iocmd_is_type(spl_dots) /* do nothing to do *
if ((path == '<0') && (nsnull == spl_dir.dirp)) &/* let's use a filesystem dir, to set ns directory names */ return -1;
if (!spl_filesystem_dir_open) &/* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) &/* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) &/* * Is the safe place to read the user's data and the DB's filesystem database? */ &else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* FIXME: spl_filesystem_dir_open should not be called with the __flags, in the __flags in case the __flags are defined. */ if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); <else if (i) int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS); if (spl_stream_opendir(path, REPORT_ERRORS, NULL)!= 0) &/* ignore the path of the filesystem, so we don't re-sync filesystem... */ break;
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (spl_filesystem_dir_is_dir(intern->u.dir.entry.d_name)) /* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else <intern->_path = estrndup(path, --intern->_path_len);
if (intern->_path_len > 1) &/* ignore the path-- as well as the path's value. */ if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) /* ignore the path-- as well as the path-- is the filesystem */ intern->_path = estrndup(path, --intern->_path_len); <else </* ignore the path-- except for the dummy */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else </* throw exception: should have been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* remove any flags */ /* * Add a flag in the directory */ if (ntob(strlen(path)) == -1) &/* use the name of the filesystem in the directory */ spl_filesystem_dir_read(intern); <else </* do not make the directory */ if (intern->u.dir.entry.d_name == '&0' && (intern->u.dir.entry.d_name == '0')) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ intern->u.dir.entry.d_name[0] = '0'; else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) &if (Intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); &else &intern->_path = estrndup(path, --intern->_path_len);
/* get the directory id of the type from the filesystem. */ if (__func__ == __func__) &if (__func__ == __func__) spl_filesystem_dir_read(intern TSRMLS_CC); <while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) if (estrndup(path, --intern->_path_len) <else if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already done */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else <do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) /* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); &if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) &intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); &intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
else do spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
&else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) /* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
/* * We cannot open the filesystem directory if there is no spl_filesystem_dir_open, because we don't have any spl_filesystem_dir_opens. */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) /* SPL_FS_DIR */ if (intern->type == SPL_FS_DIR) </* SPL_FS_DIR */ if (intern->flags & SPL_FS_DIR_SKIPDOTS) &/* XXX is a different one. */ break; <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) /* SPL_FS_DIR */ /* XXX is an empty filesystem filesystem */ if (intern->_path_len > 2 && IS_SLASH_AT(path
if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else <intern->_path = estrndup(path, --intern->_path_len); <intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* if (!spl_filesystem_dir_read(intern->u.dir.entry.d_name)) /* save the name of a '%s' in the
if (intern->_path_len > 1) &if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); <else &intern->_path = estrndup(path, --intern->_path_len); intern->u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name)); /* skip_dots = SPL_HAS_FLAG(intern->
/* in the spl_filesystem_dir_open option */ if (intern->spl_docs == 0 && (*intern->spl_dir.dirp == NULL)) &/* in the spl_docs process for a directory entry */ if ((intern->spl_docs == 0) || (intern->spl_docs == 0)) <spl_dir.dirp = php_stream_opendir(path, REPORT_ERRORS, NULL); if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) spl_dir.dirp = estrndup(path, --intern->_path_len); <if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should
if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) <intern->_path = estrndup(path, --intern->_path_len); else intern->_path = estrndup(path, --intern->_path_len); u.dir.index = 0; if (EG(exception) || intern->u.dir.dirp == NULL) /* throw exception: should've been already happened */ spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* skip dots if we're running a directory directory already */ if (!spl_dots &&!spl_filesystem_is_dot(intern->u.dir.entry.d_name)) <spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); spl_filesystem_dir_open(spl_filesystem_object_dot(intern->u.dir.entry.d_name)); <if (intern->_path_len > 0 && IS_SLASH_AT(path, intern->_path_len-1)) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (is_SLASH_AT(path, intern->_path_len-1)) if (
if (!spl_filesystem_dir_open) </* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) </* * Is the safe place to read the user's data and the DB's filesystem database? */ else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
<else spl_filesystem_dir_read(intern TSRMLS_CC);
if (!spl_filesystem_dir_open) /* not clear */ if (is_SLASH_AT(path, intern->_path_len-1)) /* set the user data for the user-defined resource */ if (!intern->u.dir.dirp) /* * Is the safe place to read the user's data and the DB's filesystem database? */ <else /* * XXX '%s' does not support '0', * 0) spl_filesystem_dir_read(intern TSRMLS_CC); while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));
/* check if we can have an interface. */ if (is_close) <if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) <if (is_close) &if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (is_close) if (is_close) if (intern->_path_len > 1) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-1)) if (IS_SLASH_AT(path, intern->_path_len-
<else &/* get out of directory data */ /* * If we're a directory, we should get * the directory to do a new one. */ if (intern->u.dir.dirp == NULL) &/* check that our local directory is at the directory end of the directory we're removing. */ if (intern->u.dir.dirp == NULL) </* * This is not necessary. */
&else spl_filesystem_dir_open(intern TSRMLS_DC);
<#endif
