golden:
zval_copy_ctor(tmp);
inference:

#endif
Z_SET_REFCOUNT_P(tmp);
tmp = EG(uninitialized_zval_ptr);
ZVAL_COPY_VALUE(tmp, *p);
Z_SET_REF_P(tmp);
return 0;
if (is_ref)  Z_SET_ISREF_P(tmp);
if (is_ref)  Z_SET_REF_P(tmp);
free(tmp);
Z_SET_REFERENCE_P(tmp);
ZVAL_SET_REFCOUNT_P(tmp);
is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else  tmp = EG(uninitialized_zval_ptr);
splx(s);
Z_SET_ISREF_P(tmp);
else if (is_ref)  Z_SET_ISREF_P(tmp);
return (0);
Z_INIT_ZVAL(tmp);
else  Z_SET_ISREF_P(tmp);
Z_SET_REFCOUNT(tmp);
SEPARATE_ZVAL_TO_MAKE_IS_REF(p);
/* XXX */
Z_UNLOCK_GIANT(tmp);
Z_SET_REFCOUNT_P(p);
if (is_ref)  ZVAL_COPY_VALUE(tmp, *p);
return NULL;
else
tmp = EG(active_symbol_table);
ZVAL_UNLOCK_GIANT(tmp);
ZVAL_UNLOCK(tmp);
tmp = NULL;
ZEND_API
if (is_ref) Z_SET_REF_P(tmp);
ZVAL_UNLOCK_GIANT();
if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref)
Z_UNLOCK_GIANT();
zend_rebuild_symbol_table(TSRMLS_C);
else if (is_ref)  ZVAL_COPY_VALUE(tmp, *p);
Z_SET_REG_P(tmp);
SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
else  if (is_ref)  Z_SET_ISREF_P(tmp);
else  ZVAL_COPY_VALUE(tmp, *p);
Z_SET_REFCOUNT_P(tmp); Z_SET_REFCOUNT_P(tmp);
break;
Z_UNLOCK(tmp);
*p = NULL;
return is_ref;
zend_hash_rebuild_symbol_table(TSRMLS_C);
return;
if (is_ref) return;
free(p);
ZVAL_SET_REFCOUNT(tmp);
ZVAL_COPY_VALUE(tmp, p);
va_arg(args, HashTable*);
Z_SET_REF_P(p);
else if (is_ref)
ZVAL_COPY_P(tmp);
Z_SET_REFERENCE_P(p);
else tmp = EG(uninitialized_zval_ptr);
Z_SET_REFCOUNT(p);
else  Z_SET_REF_P(tmp);
@endif
ZSET_REFCOUNT_P(tmp);
if (is_ref)  Z_SET_REFCOUNT_P(tmp);
Z_LOCK_ASSERT(p);
tmp = *p;
return -1;
ZVAL_COPY_VALUE(p);
return TRUE;
ZVAL_LOCK_ASSERT(p);
Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
p = NULL;
ZVAL_INIT_ZVAL(tmp);
Z_SET_P(tmp);
else if (is_ref)  Z_SET_REF_P(tmp);
*p = *p;
Z_SET_REFERENCE(tmp);
(void**)&p;
/*
ZVAL_COUNT_P(tmp);
Z_ISREF_P(tmp);
is_ref = Z_TYPE_PP(p) &IS_LEXICAL_REF;
exit(1);
Z_RELEASE(tmp);
*p = p;
ZVAL_SET_REFCOUNT_P(p);
p = p;
Z_SET_REF(tmp);
i = 0;
return true;
ZVAL_SET_REFERENCE_P(tmp);
else  splx(s);
free(key->arKey);
NULL,
ZVAL_LOCK_ASSERT(tmp);
Z_UNLOCK_GIANT(p);
ZVAL_INIT(tmp);
int i;
#ifdef DEBUG
Z_SET_READ_P(tmp);
p = 0;
Z_IF_RELEASE(tmp);
ZVAL_UNLOCK_GIANT(p);
if (is_ref) return 0;
ZVAL_COPY_VALUE(tmp);
Z_LOCK_ASSERT(tmp);
Z_LOCK_ASSERT();
ZVAL_SET_REF_P(tmp);
ZVAL_LOCK_ASSERT();
Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp);
(void**) &p;
Z_SET_REFCOUNT_P(tmp, sizeof(zval_ptr));
ZVAL_UNLOCK();
Z_UNLOCK_GIANT(zval);
errno = EINVAL;
ZVAL_SET_REFCOUNT(p);
Z_SET_REFERENCE_P(tmp); Z_SET_REFERENCE_P(tmp);
ZVAL_LOCK_GIANT();
ZVAL_UNLOCK(p);
Z_SET_REFCNT_P(tmp);
PZ_UNLOCK_GIANT();
if (is_ref) tmp = EG(uninitialized_zval_ptr);
#ifdef ZEND_API
ZVAL_COPY_VALUE(tmp, &p);
(void **) &p;
Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref)  splx(s);
Z_UNLOCK_ASSERT(p);
else  zend_hash_rebuild_symbol_table(TSRMLS_C);
if (is_ref)  Z_SET_REF_P(p);
is_ref = Z_TYPE_PP(p);
uninitialized_zval_ptr = NULL;
ZVAL_LOCK_ASSERT(zval);
else  if (is_ref)
if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p);
if(is_ref)  Z_SET_REF_P(tmp);
free_symbol_table(TSRMLS_C);
if (is_ref)  ZVAL_SET_REFCOUNT_P(tmp);
else if (is_ref)  splx(s);
if(is_ref)  Z_SET_ISREF_P(tmp);
if (is_ref)  ZVAL_SET_REF_P(tmp);
else if (is_ref)  ALLOC_INIT_ZVAL(tmp);
is_ref = Z_TYPE_PP(p) & is_lexICAL_REF;
else  ZVAL_SET_REF_P(tmp);
ZVAL_COPY_VALUE(tmp, (void **)&p);
if (is_ref)  Z_ISREF_P(tmp);
tmp = EG(uninitialized_tmp_ptr);
if (is_ref)  Z_SET_ISREF_P(p);
else  ZVAL_SET_REFCOUNT_P(tmp);
if (is_ref)  /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);  else  /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (is_ref)  Z_UNREACH_ZVAL(tmp); Z_SET_ISREF_P(tmp);
Z_ADD_ZVAL(tmp);
if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);
if (is_ref)  Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);  else  tmp = EG(uninitialized_zval_ptr);  else  Z_SET_REF_P(tmp);
else  if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p)  p = tmp; else  p = tmp;
Z_REFCOUNT_P(tmp);
if (is_ref)  Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (p->key)  zval_set_free_ptr(p);
ZVAL_UNLOCK_GIANT(&send)  send->hash_signal_signal = 0; return send->hash_signal;
ZVAL_LOCK_ASSERT(tmp == NULL);
if (is_ref)  Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);  else  Z_SET_REF_P(tmp);
if (is_ref)  Z_TYPE_PP(p) & IS_LEXICAL_REF;
ZVAL_REMOVE_P(tmp);
ZVAL_UNLOCK(&v);
else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else  /* XXX no reference */
if (is_ref)  Z_IF_INIT(tmp); Z_SET_ISREF_P(tmp);
if (p->type == gc_symbol_type)  zend_finit_free_symbol(tmp);
ZVAL_INIT_IS_WRITE_COUNT(tmp);
if (is_ref)  Z_DEBUG_SINK("%s", key->arKey);
ZEND_API.s_symbol_get_symbol_table(PSRMLS_C);
else  zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  tmp = EG(uninitialized_zval_ptr);   else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else  Z_SET_REF_P(tmp);
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref)  Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id))  Z_SET_ID(&kobj->id);
tmp = EG(uninitialized_zval_ptr); /*  0x8f  -Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref)  sys->sys->pOST = 0;  else  sys->sys->pOST = 0;
Z_REMOVE_SPACE(tmp);
if (is_ref)  if (mgr_type == z_type_p)   Z_SET_ISO_PTR(tmp);  else  Z_SET_ISO_PTR(tmp);
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);   else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else  ZVAL_COPY_VALUE(
else if (is_ref)  if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Restore the zval_stats and in the zval * function * to the next zval by zval_stats_std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std
if (p)  is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX a problem */
Z_INSERT_ERR(&is_ref);
/* XXX */ if (is_ref)  if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF))  is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;  if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
Z_IF_INIT_VALUE(tmp);
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else  if (is_ref)  Z_TYPE_PP(p) & IS_LEXICAL_REF;  if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr);
else  Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref)  ntohs(p); ntohs = 0;
if (!is_ref)  Z_SET_REF_P(tmp);
else if (is_ref)  NS_RELEASE(sc->sc->sc_key);
ZVAL_COPY_FROM_LOCK(strlen(p));
else  if (is_ref)  /* Not implemented. */
else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF))  is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
Z_REMOVE_SYMBOL(tmp);
else  zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
ZVAL_POP_D(tmp);
/* XXX - * Now we can do that for the first one */ tmp = EG(uninitialized_zval_ptr);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  tmp = EG(uninitialized_zval_
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end)  zend_debug("ZEND_API %s n", zval_dc->ptr_end); zval_set_ptr_end("--");
Z_DEBUG_REFCOUNT_P(tmp);
/* XXX: Init from zero-value_ret value. */
/* not an empty string */
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);  else  tmp = EG(uninitialized_zval_ptr);
else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else  zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else  if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else  /* XXX */
else  zval_set_symbol_table(TSRMLS_C);  if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref)  nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp);
if (is_ref)  if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp);  zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);   else
Z_UNLOCK_PANIC(tmp);
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);  else  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);  else  tmp = EG(uninitialized_zval_ptr);
if (! zval_is_free(p))  if (!zval_get_symbol_table(TSRMLS_C))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* XXX */ /* XXX */ /* XXX */ /* XXX */ /* * XXX */
/* XXX */ zend_hash_symbol_table = 0;
ZVAL_STATUS(is_ref);
ZEND_API zval_clear_tag(target);
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_pt
if (is_ref)  symbol_table = (struct symbol_table *) key->arKey; symbol_table->int_flags |= Z_F_REG_REF; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol
if (!is_ref)  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);   else  if (is_ref)  SEPARATE_ZVAL_
else if (is_ref)  zval_update_symbol_table(TSRMLS_DC);
Z_LOCK_ASSERT(mgr);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType)  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else  ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else  zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref)  Z_ADD_STYLE_SYMBOL(symbol_table); Z_ADD_STYLE_SYMBOL(symbol_table);
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * Find a map for a value whose value is stored. */ if (p)  tmp = EG(active_symbol_table); Z_SET_ISREF_P(tmp); Z_SET_REFCOUNT_P(tmp);
if (!v3)  v3 = v4; Z_SET_REFCOUNT_P(v3) = 0;
if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);   else  if (is_ref)
Z_REPLACE_BASE(tmp);
else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * If we're a zval, we have to call the tmp command. */
ZVAL_UNLOCK(s);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key)  if (!(args->arena_key))  tmp = EG(uninitialized_zval_ptr);  else  tmp = EG(uninitialized_zval_ptr);   else  tmp = EG(uninitialized_zval_ptr);   else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else   else
else  /* XXX */ /* XXX */
if (is_ref)  Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp);  else  Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
else if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF))  is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  tmp = EG(uninitialized_zval_ptr);   else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else
ZVAL_ADD_P(tmp);
if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_symbol_table = NG_SYMBOL_AR; Z_SET_ISREF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE))  p = Z_TYPE_PP(p); if (!p)  p = Z_TYPE_PP(p);  if (p)  Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);   else  Z_SET_REF_P(tmp);
else  zend_hash_close(&key->p);
Z_GET_TAG(tmp, "HEADING");
else if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref)  sa_release_symbol(tmp);
if (is_ref)  zval_copy_static_var(key->arKey, key->nKeyLength, key->h, *p); ZVAL_COPY_VALUE(tmp, *p);
/* XXX to be safe. */ if (is_ref)  Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp); Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp);
if (p)  is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;  if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_zval_ptr);  else  Z_ERR
if (!P_ERROR_TOO_FEW_LOCK)  P_ERROR_TOO_FEW_LOCK(ZVAL_LOCK);
if (is_ref)  /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else  /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* if (!IsNegated())  Z_IF_RELEASE(tmp);
if (is_ref)  Z_REG_PUSH(tmp);
Z_TYPE_PP(p) &=  (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR)  Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR)  Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR)  Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR)  Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR)  Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR)  Z_TYPE_PP(p) &  (SIZE_PROTOCOL_STR)  Z_TYPE_PP(p)
Z_INIT_FROM_ZVAL(tmp);
else  if (is_ref)  Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);  else  tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);   else  if (is_ref)  SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;  else  ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);  else  ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
Z_GET_VAR(tmp);
if (p)  zend_add_symbol_table(TSRMLS_C);  if (!EG(active_symbol_table))  zend_rebuild_symbol_table(TSRMLS_C);  if (!EG(active_symbol_table))  zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE)  if (is_ref)  ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);  else  tmp = EG(uninitialized_z
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1))  p = __ZVAL___P(tmp);  else  tmp = EG(uninitialized_zval_ptr);  else  p = EG(uninitialized_zval_ptr);  /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref)  Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF);
else  zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);

else <if (is_ref) </* Not implemented. */
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else <if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else sys->sys->pOST = 0;
if (is_ref) &zval_copy_static_var(key->arKey, key->nKeyLength, key->h, *p); ZVAL_COPY_VALUE(tmp, *p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
&else
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else <Z_SET_ISREF_P(tmp);
/* * Restore the zval_stats and in the zval * function * to the next zval by &zval_stats_std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &ZVAL_SET_REF_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF;
SEPARATE_ZVAL_TO_MAKE_IS_REF(p);
else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else &zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else <sys->sys->pOST = 0;
else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else <zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else zend_hash_close(&key->p);
else Z_SET_REF_P(tmp);
if (is_ref) <if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else <if (is_ref)
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* XXX to be safe. */ if (is_ref) <Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp); Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) p = tmp; else <p = tmp;
else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) <ntohs(p); ntohs = 0;
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
&else &splx(s);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
&else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
&else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else <tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else if (is_ref) Z_SET_ISREF_P(tmp);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else if (is_ref) ALLOC_INIT_ZVAL(tmp);
else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
#endif
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else if (is_ref)
if (is_ref) <Z_SET_REF_P(tmp);
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else <sys->sys->pOST = 0;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) &symbol_table = (struct symbol_table *) key->arKey; symbol_table->int_flags |= Z_F_REG_REF; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (is_ref) Z_IF_INIT(tmp); Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
ZVAL_UNLOCK_GIANT(&send) <send->hash_signal_signal = 0; return send->hash_signal;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_REF_P(tmp);
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_REF_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else &ZVAL_SET_REF_P(tmp);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Find a map for a value whose value is stored. */ if (p) <tmp = EG(active_symbol_table); Z_SET_ISREF_P(tmp); Z_SET_REFCOUNT_P(tmp);
&else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else if (is_ref) &zval_update_symbol_table(TSRMLS_DC);
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!v3) &v3 = v4; Z_SET_REFCOUNT_P(v3) = 0;
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
&else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<if (is_ref) &Z_SET_ISREF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) <if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) &if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
else &Z_SET_ISREF_P(tmp);
if(is_ref) <Z_SET_ISREF_P(tmp);
if (!is_ref) &Z_SET_REF_P(tmp);
<else if (is_ref) &ZVAL_COPY_VALUE(tmp, *p);
&else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <tmp = EG(uninitialized_zval_ptr);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else if (is_ref) <Z_SET_ISREF_P(tmp);
if (is_ref) if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else sys->sys->pOST = 0;
<else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else if (is_ref) &splx(s);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else <if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else &if (is_ref)
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if(is_ref) <Z_SET_REF_P(tmp);
&else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else &if (is_ref)
else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
&else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) &Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) <Z_SET_ID(&kobj->id);
<else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else </* XXX */
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else sys->sys->pOST = 0;
else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else /* XXX */ /* XXX */
<else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
<else tmp = EG(uninitialized_zval_ptr);
else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
&else &if (is_ref) </* Not implemented. */
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
<else ZVAL_COPY_VALUE(tmp, *p);
&else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
<else <Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else &ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else /* XXX */
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else /* XXX */
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_REF_P(tmp);
else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) <p = tmp; else p = tmp;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_REF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &tmp = EG(uninitialized_zval_ptr);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
else if (is_ref) ZVAL_COPY_VALUE(tmp, *p);
/* if (!IsNegated()) Z_IF_RELEASE(tmp);
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else <Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Find a map for a value whose value is stored. */ if (p) tmp = EG(active_symbol_table); Z_SET_ISREF_P(tmp); Z_SET_REFCOUNT_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) <ZVAL_COPY_VALUE(tmp, *p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) <if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) &zend_debug("ZEND_API %s n", zval_dc->ptr_end); zval_set_ptr_end("--");
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&#endif
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else if (is_ref) NS_RELEASE(sc->sc->sc_key);
&else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else Z_SET_REF_P(tmp);
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) &zend_debug("ZEND_API %s &n", zval_dc->ptr_end); zval_set_ptr_end("--");
&else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else if (is_ref) Z_SET_ISREF_P(tmp);
else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else &tmp = EG(uninitialized_zval_ptr);
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
<else <if (is_ref) Z_SET_ISREF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else if (is_ref) <ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_REF_P(tmp);
<else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <Z_SET_ISREF_P(p);
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else if (is_ref) NS_RELEASE(sc->sc->sc_key);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else if (is_ref) Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
ZVAL_SET_REFCOUNT_P(tmp);
&else &/* XXX no reference */
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
<else &ZVAL_SET_REFCOUNT_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Find a map for a value whose value is stored. */ if (p) &tmp = EG(active_symbol_table); Z_SET_ISREF_P(tmp); Z_SET_REFCOUNT_P(tmp);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else <ZVAL_COPY_VALUE(tmp, *p);
<else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
<else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
&if (is_ref) Z_SET_REF_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else if (is_ref)
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
&else if (is_ref) &zval_update_symbol_table(TSRMLS_DC);
<else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <Z_SET_ISREF_P(tmp);
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else &ZVAL_COPY_VALUE(tmp, *p);
&else &zend_hash_rebuild_symbol_table(TSRMLS_C);
<else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else if (is_ref) &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) <p = tmp; else &p = tmp;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else zend_hash_rebuild_symbol_table(TSRMLS_C);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else &sys->sys->pOST = 0;
else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else &ZVAL_SET_REFCOUNT_P(tmp);
&else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else <if (is_ref)
else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
else &if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else &zend_hash_rebuild_symbol_table(TSRMLS_C);
<else if (is_ref) &zval_update_symbol_table(TSRMLS_DC);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!is_ref) <Z_SET_REF_P(tmp);
<else if (is_ref) if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!P_ERROR_TOO_FEW_LOCK) P_ERROR_TOO_FEW_LOCK(ZVAL_LOCK);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (p->key) &zval_set_free_ptr(p);
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<if (is_ref) <Z_SET_ISREF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else &if (is_ref) &Z_SET_ISREF_P(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else <ZVAL_SET_REFCOUNT_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <ZVAL_SET_REFCOUNT_P(tmp);
&else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else if (is_ref) <NS_RELEASE(sc->sc->sc_key);
if (!is_ref) Z_SET_REF_P(tmp);
else if (is_ref) <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else <if (is_ref) </* Not implemented. */
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else Z_SET_REF_P(tmp);
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
if (!v3) <v3 = v4; Z_SET_REFCOUNT_P(v3) = 0;
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C);
&else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
<else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else <if (is_ref) <Z_SET_ISREF_P(tmp);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else if (is_ref) <Z_SET_REF_P(tmp);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else <if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
/* if (!IsNegated()) <Z_IF_RELEASE(tmp);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else sys->sys->pOST = 0;
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else <zend_hash_close(&key->p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &tmp = EG(uninitialized_zval_ptr);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
<else <if (is_ref) /* Not implemented. */
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else &zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) <Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) &Z_SET_ID(&kobj->id);
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <zend_hash_rebuild_symbol_table(TSRMLS_C);
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
<else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
&else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else if (is_ref) splx(s);
&else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else &if (is_ref) Z_SET_ISREF_P(tmp);
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else <if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
tmp = EG(uninitialized_zval_ptr); /* 0x8f &-Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
<else if (is_ref) <ZVAL_COPY_VALUE(tmp, *p);
else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else &Z_SET_REF_P(tmp);
else if (is_ref) &Z_SET_ISREF_P(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
&else <if (is_ref) </* Not implemented. */
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
&if (is_ref) &Z_SET_ISREF_P(tmp);
&else if (is_ref) if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else &tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) &sa_release_symbol(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
else &Z_SET_REF_P(tmp);
if (is_ref) Z_DEBUG_SINK("%s", key->arKey);
else if (is_ref) <ZVAL_COPY_VALUE(tmp, *p);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) &p = tmp; else <p = tmp;
<else &/* XXX */
else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else sys->sys->pOST = 0;
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
<else ZVAL_SET_REF_P(tmp);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else <Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <tmp = EG(uninitialized_zval_ptr);
&else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_ADD_STYLE_SYMBOL(symbol_table); Z_ADD_STYLE_SYMBOL(symbol_table);
<else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if(is_ref) &Z_SET_ISREF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else if (is_ref) &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &splx(s);
else &splx(s);
else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) &if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else if (is_ref) splx(s);
tmp = EG(uninitialized_zval_ptr); /* 0x8f -Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
else ZVAL_SET_REF_P(tmp);
<else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
else if (is_ref) &ZVAL_COPY_VALUE(tmp, *p);
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) &Z_ADD_STYLE_SYMBOL(symbol_table); Z_ADD_STYLE_SYMBOL(symbol_table);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
&else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else sys->sys->pOST = 0;
<else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
&else &zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_REF_P(tmp);
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
else <if (is_ref) <Z_SET_ISREF_P(tmp);
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) <ZVAL_COPY_VALUE(tmp, *p);
ZEND_API
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else sys->sys->pOST = 0;
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else if (is_ref) <Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else Z_SET_ISREF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else if (is_ref)
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else if (is_ref) &/* Not implemented. */
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) &Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) Z_SET_ID(&kobj->id);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp);
if (p->key) <zval_set_free_ptr(p);
<else <ZVAL_SET_REF_P(tmp);
<else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else &sys->sys->pOST = 0;
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
else /* XXX no reference */
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else &zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
&else if (is_ref)
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
&else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else &zend_hash_close(&key->p);
else if (is_ref) ZVAL_COPY_VALUE(tmp, *p);
&else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else if (is_ref) if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else Z_SET_REF_P(tmp);
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
<else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
<else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else tmp = EG(uninitialized_zval_ptr);
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
&else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else /* XXX no reference */
else &if (is_ref) &/* Not implemented. */
else if (is_ref) Z_SET_ISREF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else &ZVAL_COPY_VALUE(tmp, *p);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else <ZVAL_SET_REFCOUNT_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else &Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <ZVAL_SET_REF_P(tmp);
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) sa_release_symbol(tmp);
&else if (is_ref) &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
<else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_REF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else /* XXX no reference */
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_REF_P(tmp);
else </* XXX no reference */
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
&else Z_SET_ISREF_P(tmp);
if (is_ref) ZVAL_SET_REF_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else <zend_hash_close(&key->p);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else if (is_ref) <Z_SET_REF_P(tmp);
&else splx(s);
<else if (is_ref) <zval_update_symbol_table(TSRMLS_DC);
&else if (is_ref) ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else sys->sys->pOST = 0;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else if (is_ref) <Z_SET_ISREF_P(tmp);
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
<else &ZVAL_COPY_VALUE(tmp, *p);
&else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
<else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else sys->sys->pOST = 0;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else if (is_ref) Z_SET_REF_P(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
&else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
&else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else &zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
&else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
&else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
<else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_SET_REFCOUNT_P(tmp);
if (is_ref) <Z_SET_REFCOUNT_P(tmp);
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
&else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <ZVAL_COPY_VALUE(tmp, *p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
if (is_ref) Z_ISREF_P(tmp);
<else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&if (is_ref) &Z_SET_REF_P(tmp);
<else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_REF_P(tmp);
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <symbol_table = (struct symbol_table *) key->arKey; symbol_table->int_flags |= Z_F_REG_REF; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_REF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else if (is_ref) &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) <p = tmp; else <p = tmp;
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) p = tmp; else &p = tmp;
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_REF_P(tmp);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <sa_release_symbol(tmp);
&else </* XXX */ /* XXX */
else if (is_ref) if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else <sys->sys->pOST = 0;
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
&else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else </* XXX */
&else <zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else <if (is_ref) &Z_SET_ISREF_P(tmp);
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
<else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else Z_SET_ISREF_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
<else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else <Z_SET_ISREF_P(tmp);
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
&else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) <Z_DEBUG_SINK("%s", key->arKey);
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else <Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else sys->sys->pOST = 0;
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_SET_ISREF_P(p);
<else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else &ZVAL_SET_REFCOUNT_P(tmp);
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) p = tmp; else p = tmp;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) &Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) &if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
<if (is_ref) Z_SET_ISREF_P(tmp);
&else &if (is_ref)
&else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
&else &ZVAL_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else &if (is_ref) Z_SET_ISREF_P(tmp);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else sys->sys->pOST = 0;
&else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&if (is_ref) Z_SET_ISREF_P(tmp);
else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) <ZVAL_SET_REFCOUNT_P(tmp);
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
&else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) <nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp);
else &/* XXX */
<if (is_ref) <Z_SET_ISREF_P(tmp);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
<else &if (is_ref) Z_SET_ISREF_P(tmp);
&else if (is_ref) &/* Not implemented. */
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_symbol_table = NG_SYMBOL_AR; Z_SET_ISREF_P(tmp);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else Z_SET_ISREF_P(tmp);
else &if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else if (is_ref) Z_SET_ISREF_P(tmp);
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if(is_ref) Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else &if (is_ref)
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
tmp = EG(active_symbol_table);
&else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else sys->sys->pOST = 0;
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else <Z_SET_REF_P(tmp);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else /* XXX */ /* XXX */
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else &if (is_ref) &Z_SET_ISREF_P(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) &if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else if (is_ref) &/* Not implemented. */
else &if (is_ref) /* Not implemented. */
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else &Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <tmp = EG(uninitialized_zval_ptr);
else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else zend_hash_close(&key->p);
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
&else if (is_ref) if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
&else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else if (is_ref) &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else if (is_ref) <splx(s);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
&else if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) <zend_debug("ZEND_API %s n", zval_dc->ptr_end); zval_set_ptr_end("--");
tmp = EG(uninitialized_zval_ptr); /* <0x8f <-Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else sys->sys->pOST = 0;
else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
&else if (is_ref) &NS_RELEASE(sc->sc->sc_key);
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &ZVAL_SET_REF_P(tmp);
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&if (is_ref) <Z_SET_REF_P(tmp);
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
&else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else <ZVAL_COPY_VALUE(tmp, *p);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
<else if (is_ref) <splx(s);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) &if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else ZVAL_SET_REFCOUNT_P(tmp);
<else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else if (is_ref) &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<if (is_ref) <Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
return 0;
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
zend_hash_rebuild_symbol_table(TSRMLS_C);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
&else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&if (is_ref) Z_SET_REF_P(tmp);
if(is_ref) &Z_SET_REF_P(tmp);
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
<else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
ZVAL_UNLOCK_GIANT(&send) &send->hash_signal_signal = 0; return send->hash_signal;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
else <if (is_ref) <Z_SET_ISREF_P(tmp);
else <zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else Z_SET_ISREF_P(tmp);
if (is_ref) if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
<else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
&else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else &if (is_ref) <Z_SET_ISREF_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
ZVAL_COPY_VALUE(tmp, *p);
else if (is_ref) &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
&else &if (is_ref) &Z_SET_ISREF_P(tmp);
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) </* Not implemented. */
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<if (is_ref) &Z_SET_REF_P(tmp);
&else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) <Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF);
<else ZVAL_COPY_VALUE(tmp, *p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <if (is_ref) &/* Not implemented. */
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else <zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&if (is_ref) &Z_SET_REF_P(tmp);
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else /* XXX */
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else &ZVAL_SET_REFCOUNT_P(tmp);
if (is_ref) <Z_SET_REF_P(p);
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) zend_debug("ZEND_API %s n", zval_dc->ptr_end); zval_set_ptr_end("--");
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else <sys->sys->pOST = 0;
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else &/* XXX */ /* XXX */
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) &p = tmp; else p = tmp;
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else if (is_ref) zval_update_symbol_table(TSRMLS_DC);
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
<else &if (is_ref) <Z_SET_ISREF_P(tmp);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else <zend_hash_rebuild_symbol_table(TSRMLS_C);
else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else <if (is_ref) Z_SET_ISREF_P(tmp);
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
tmp = EG(uninitialized_zval_ptr); /* 0x8f <-Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
&else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (is_ref) zval_copy_static_var(key->arKey, key->nKeyLength, key->h, *p); ZVAL_COPY_VALUE(tmp, *p);
<else if (is_ref) if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
tmp = EG(uninitialized_zval_ptr); /* <0x8f -Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_REF_P(p);
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
&else zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else &ZVAL_COPY_VALUE(tmp, *p);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
&else if (is_ref) Z_SET_REF_P(tmp);
&else </* XXX */
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else &if (is_ref)
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else <if (is_ref) &/* Not implemented. */
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_symbol_table = NG_SYMBOL_AR; Z_SET_ISREF_P(tmp);
<else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else <if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!P_ERROR_TOO_FEW_LOCK) <P_ERROR_TOO_FEW_LOCK(ZVAL_LOCK);
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_REF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
else zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
else if (is_ref) <ALLOC_INIT_ZVAL(tmp);
&else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else ZVAL_COPY_VALUE(tmp, *p);
else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else </* XXX */ /* XXX */
<else &if (is_ref) /* Not implemented. */
else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else if (is_ref) &ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp);
else ZVAL_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (p->type == gc_symbol_type) <zend_finit_free_symbol(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &tmp = EG(uninitialized_zval_ptr);
else <Z_SET_REF_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <splx(s);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else sys->sys->pOST = 0;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
&else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else <ZVAL_SET_REF_P(tmp);
else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
<else &if (is_ref) &/* Not implemented. */
else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else <if (is_ref)
&else if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <tmp = EG(uninitialized_zval_ptr);
if (is_ref) &ntohs(p); ntohs = 0;
&else if (is_ref) &Z_SET_REF_P(tmp);
<else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) &Z_SET_ISREF_P(tmp);
Z_SET_REFCOUNT_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_REF_P(tmp);
<else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else sys->sys->pOST = 0;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
else if (is_ref) <NS_RELEASE(sc->sc->sc_key);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else </* XXX */ /* XXX */
<else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) &Z_ISREF_P(tmp);
<else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (is_ref) <zval_copy_static_var(key->arKey, key->nKeyLength, key->h, *p); ZVAL_COPY_VALUE(tmp, *p);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) Z_SET_ID(&kobj->id);
else &zend_hash_rebuild_symbol_table(TSRMLS_C);
<else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else ZVAL_COPY_VALUE(tmp, *p);
&else <if (is_ref) <Z_SET_ISREF_P(tmp);
else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (is_ref) <if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
<else &splx(s);
<else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else if (is_ref) &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else &zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <ZVAL_SET_REF_P(tmp);
&else ZVAL_SET_REF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
<else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else <sys->sys->pOST = 0;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
&else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else <ZVAL_SET_REF_P(tmp);
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else &if (is_ref) &Z_SET_ISREF_P(tmp);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (is_ref) &if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else sys->sys->pOST = 0;
&else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&if (is_ref) <Z_SET_ISREF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
<else if (is_ref) <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else &if (is_ref)
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else <if (is_ref) &Z_SET_ISREF_P(tmp);
<else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C);
<else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else if (is_ref) NS_RELEASE(sc->sc->sc_key);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) &Z_UNREACH_ZVAL(tmp); Z_SET_ISREF_P(tmp);
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_SET_REF_P(tmp);
if (is_ref) <Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
else Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_symbol_table = NG_SYMBOL_AR; Z_SET_ISREF_P(tmp);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
<else <splx(s);
else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_REF_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else &if (is_ref) Z_SET_ISREF_P(tmp);
&if (is_ref) <Z_SET_REF_P(tmp);
if (p->type == gc_symbol_type) zend_finit_free_symbol(tmp);
&else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <if (is_ref) Z_SET_ISREF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
<else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else ZVAL_SET_REFCOUNT_P(tmp);
<else <zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) &zend_debug("ZEND_API %s <n", zval_dc->ptr_end); zval_set_ptr_end("--");
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
if (is_ref) &if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (p->key) zval_set_free_ptr(p);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
Z_SET_REF_P(tmp);
else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else if (is_ref) if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) &if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else if (is_ref) <zval_update_symbol_table(TSRMLS_DC);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <tmp = EG(uninitialized_zval_ptr);
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
if (is_ref) &if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
<else &Z_SET_ISREF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
<else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else if (is_ref) &NS_RELEASE(sc->sc->sc_key);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
&else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &tmp = EG(uninitialized_zval_ptr);
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
&else if (is_ref) &ALLOC_INIT_ZVAL(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &tmp = EG(uninitialized_zval_ptr);
&else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else &sys->sys->pOST = 0;
if (is_ref) ZVAL_COPY_VALUE(tmp, *p);
<else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else &if (is_ref) /* Not implemented. */
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (p->type == gc_symbol_type) &zend_finit_free_symbol(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &tmp = EG(uninitialized_zval_ptr);
<else &ZVAL_SET_REFCOUNT_P(tmp);
else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else if (is_ref) zval_update_symbol_table(TSRMLS_DC);
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
<else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else <tmp = EG(uninitialized_zval_ptr);
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else if (is_ref) &splx(s);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else &Z_SET_ISREF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <if (is_ref)
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (is_ref) &if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_REF_P(tmp);
&else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
else <if (is_ref) &Z_SET_ISREF_P(tmp);
tmp = EG(uninitialized_zval_ptr); /* &0x8f &-Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
<else &ZVAL_SET_REF_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
else &ZVAL_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
&else ZVAL_SET_REFCOUNT_P(tmp);
<else <zend_hash_close(&key->p);
<else <if (is_ref) <Z_SET_ISREF_P(tmp);
<else &tmp = EG(uninitialized_zval_ptr);
&else &if (is_ref) Z_SET_ISREF_P(tmp);
<if (is_ref) &Z_SET_ISREF_P(tmp);
&if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else &/* XXX */ /* XXX */
else <tmp = EG(uninitialized_zval_ptr);
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_REF_P(tmp);
else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else if (is_ref) zval_update_symbol_table(TSRMLS_DC);
if (is_ref) <Z_SET_ISREF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else if (is_ref) &ALLOC_INIT_ZVAL(tmp);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else if (is_ref) <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) <Z_SET_ISREF_P(tmp);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
<#endif
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
if (is_ref) <if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
&else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else <Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
<else if (is_ref) <Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else &Z_SET_REF_P(tmp);
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
<else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else sys->sys->pOST = 0;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
&else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) Z_REG_PUSH(tmp);
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
<else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) <if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
<else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
&else if (is_ref) &Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
&else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
<else <tmp = EG(uninitialized_zval_ptr);
&else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &tmp = EG(uninitialized_zval_ptr);
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else <sys->sys->pOST = 0;
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else if (is_ref) Z_SET_ISREF_P(tmp);
if (is_ref) &Z_DEBUG_SINK("%s", key->arKey);
<else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_ISREF_P(tmp);
<else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else if (is_ref) ALLOC_INIT_ZVAL(tmp);
&else if (is_ref)
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else &sys->sys->pOST = 0;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
&else if (is_ref) <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else sys->sys->pOST = 0;
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Restore the zval_stats and in the zval * function * to the next zval by zval_stats_std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std
else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) ALLOC_INIT_ZVAL(tmp);
<else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else <ZVAL_SET_REFCOUNT_P(tmp);
<else /* XXX */ /* XXX */
<else if (is_ref) <Z_SET_ISREF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else if (is_ref) &NS_RELEASE(sc->sc->sc_key);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else &sys->sys->pOST = 0;
if (is_ref) Z_ADD_STYLE_SYMBOL(symbol_table); Z_ADD_STYLE_SYMBOL(symbol_table);
&else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) &Z_SET_REF_P(tmp);
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
else <Z_SET_ISREF_P(tmp);
tmp = EG(uninitialized_zval_ptr); /* &0x8f -Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
&else <if (is_ref) <Z_SET_ISREF_P(tmp);
else if (is_ref) Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
&else zend_hash_rebuild_symbol_table(TSRMLS_C);
else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp);
else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else zend_hash_rebuild_symbol_table(TSRMLS_C);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) <if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (is_ref) Z_SET_ISREF_P(tmp);
<else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
&else &ZVAL_COPY_VALUE(tmp, *p);
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else if (is_ref) /* Not implemented. */
<if (is_ref) Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (p) &zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
else if (is_ref)
<else <ZVAL_SET_REFCOUNT_P(tmp);
&else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
<else <zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (is_ref) <Z_REG_PUSH(tmp);
&else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
<else &Z_SET_ISREF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); &else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (is_ref) <if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (is_ref) Z_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); <else Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (is_ref) &ZVAL_COPY_VALUE(tmp, *p);
<else <tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else <sys->sys->pOST = 0;
if (is_ref) &if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else if (is_ref) <Z_SET_ISREF_P(tmp);
<if (is_ref) &Z_SET_REF_P(tmp);
if (is_ref) Z_UNREACH_ZVAL(tmp); Z_SET_ISREF_P(tmp);
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <Z_SET_ISREF_P(tmp);
<else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (is_ref) /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
&else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
<else if (is_ref) ZVAL_COPY_VALUE(tmp, *p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) &Z_SET_ISREF_P(p);
if (is_ref) <if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* XXX to be safe. */ if (is_ref) Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp); Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else if (is_ref) <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else &/* XXX */
<else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) <zend_debug("ZEND_API %s <n", zval_dc->ptr_end); zval_set_ptr_end("--");
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
&else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
/* * If it was a string, we've already allocated the value of the value for the value * of the value. We do not * have to allocate a new value for this * spec. */ if (tmp->p) &p = tmp; else &p = tmp;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else &sys->sys->pOST = 0;
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
<else <zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) &/* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else sys->sys->pOST = 0;
&else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (is_ref) ntohs(p); ntohs = 0;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else if (is_ref) <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else if (is_ref) <zval_update_symbol_table(TSRMLS_DC);
&else <tmp = EG(uninitialized_zval_ptr);
else if (is_ref) splx(s);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else if (is_ref) Z_SET_REF_P(tmp);
<else if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) &Z_SET_ID(&kobj->id);
<else if (is_ref) &Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else &if (is_ref) <Z_SET_ISREF_P(tmp);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
<else ZVAL_SET_REFCOUNT_P(tmp);
if (!v3) v3 = v4; Z_SET_REFCOUNT_P(v3) = 0;
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) <Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) <Z_SET_ID(&kobj->id);
if (is_ref) <if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
&else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else <sys->sys->pOST = 0;
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else tmp = EG(uninitialized_zval_pt
if (is_ref) &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
&else <zend_hash_rebuild_symbol_table(TSRMLS_C);
if (is_ref) &Z_SET_ISREF_P(tmp);
else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else &tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_REF_P(tmp);
<else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (p) zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &if (is_ref) </* Not implemented. */
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else sys->sys->pOST = 0;
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref)
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) <if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
&else ZVAL_SET_REF_P(tmp);
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else ZVAL_SET_REFCOUNT_P(tmp);
&else zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else &Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
<else &zend_hash_close(&key->p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) <Z_SET_ID(&kobj->id);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else if (is_ref) &splx(s);
else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
<else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
else <zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
else if (is_ref) &Z_SET_REF_P(tmp);
<else &Z_SET_REF_P(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
<else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; else &sys->sys->pOST = 0;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else &/* XXX no reference */
&else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) &if (mgr_type == z_type_p) Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else splx(s);
if (is_ref) &if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
<else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); <else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else if (is_ref) <NS_RELEASE(sc->sc->sc_key);
if (is_ref) if (mgr_type == z_type_p) <<Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
&else Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else &sys->sys->pOST = 0;
&else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
&else
else if (is_ref) if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; else <sys->sys->pOST = 0;
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) zend_debug("ZEND_API %s &n", zval_dc->ptr_end); zval_set_ptr_end("--");
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
<else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) </* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else /* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else &tmp = EG(uninitialized_zval_ptr);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
else if (is_ref) <Z_SET_REF_P(tmp);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (p) zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF);
else &if (is_ref) </* Not implemented. */
if (is_ref) &ZVAL_SET_REFCOUNT_P(tmp);
<else </* XXX no reference */
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
&else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else &if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
&else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (is_ref) ZVAL_COPY_VALUE(tmp, *p);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else <zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
&else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
ZVAL_UNLOCK_GIANT(&send) send->hash_signal_signal = 0; return send->hash_signal;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
<else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
<else &if (is_ref) <Z_SET_ISREF_P(tmp);
else <splx(s);
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) &nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp); nsCRT::free(tmp);
if (is_ref) &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &/* SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
&else if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else sys->sys->pOST = 0;
else if (is_ref) <splx(s);
<else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
&else <if (is_ref) Z_SET_ISREF_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else &ZVAL_SET_REF_P(tmp);
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
<else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if(is_ref) Z_SET_ISREF_P(tmp);
else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else if (is_ref) /* Not implemented. */
if (!P_ERROR_TOO_FEW_LOCK) &P_ERROR_TOO_FEW_LOCK(ZVAL_LOCK);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&if (is_ref) &Z_SET_ISREF_P(tmp);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (is_ref) &Z_REG_PUSH(tmp);
else ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!is_ref) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
tmp = EG(uninitialized_zval_ptr); /* <0x8f &-Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
if (is_ref) &if (mgr_type == z_type_p) &<Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <ZVAL_COPY_VALUE(tmp, *p);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else </* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
&else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else ZVAL_COPY_VALUE(tmp, *p);
else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else ZVAL_SET_REFCOUNT_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else sys->sys->pOST = 0;
&else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else <sys->sys->pOST = 0;
zend_rebuild_symbol_table(TSRMLS_C);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX to be safe. */ if (is_ref) &Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp); Z_UNLOCK_RP(tmp); Z_UNLOCK_P(tmp);
<else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
<else if (is_ref) &Z_SET_ISREF_P(tmp);
&else <zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
else <ZVAL_COPY_VALUE(tmp, *p);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
&else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else <if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else <ZVAL_COPY_VALUE(tmp, *p);
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) zend_debug("ZEND_API %s <n", zval_dc->ptr_end); zval_set_ptr_end("--");
<else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
&else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (p) &zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else &if (is_ref) <Z_SET_ISREF_P(tmp);
<else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; <else sys->sys->pOST = 0;
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else <tmp = EG(uninitialized_zval_ptr);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<if (is_ref) <Z_SET_REF_P(tmp);
&else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; <else &sys->sys->pOST = 0;
if (p) zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
<if (is_ref) Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else sys->sys->pOST = 0;
&else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_REF_P(tmp);
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
&else <zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else zend_hash_close(&key->p);
if (p) <zend_add_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else &Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else Z_SET_ISREF_P(tmp);
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) <Z_SET_REF_P(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_IF_INIT(tmp); Z_SET_ISREF_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else &Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
else if (is_ref) /* Not implemented. */
if (is_ref) <if (mgr_type == z_type_p) &Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; else &sys->sys->pOST = 0;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
&else if (is_ref) &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else &if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
<else <Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_REF_P(tmp);
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
else
if (is_ref) &Z_SET_REFCOUNT_P(tmp);
else zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
<else <if (is_ref) &/* Not implemented. */
if (is_ref) &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else &tmp = EG(uninitialized_zval_pt
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else <sys->sys->pOST = 0;
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else <tmp = EG(uninitialized_zval_pt
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
if (is_ref) <if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); else Z_SET_ISO_PTR(tmp);
<else if (is_ref) &Z_SET_ISREF_P(tmp);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else if (is_ref) &Z_SET_REF_P(tmp);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else tmp = EG(uninitialized_zval_pt
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
<else if (is_ref) Z_SET_REF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
/* if (!IsNegated()) &Z_IF_RELEASE(tmp);
&else </* XXX no reference */
&if (is_ref) <Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
if (is_ref) if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else &zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) &Z_SET_REF_P(tmp);
if (is_ref) &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
else <zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
else if (is_ref) &ZVAL_COPY_VALUE(tmp, *p);
else <if (is_ref)
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else <ZVAL_SET_REFCOUNT_P(tmp);
if (is_ref) if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
&else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p;
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else tmp = EG(uninitialized_zval_ptr);
<else Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else <zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) &p = __ZVAL___P(tmp); <else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; &else sys->sys->pOST = 0;
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else if (is_ref) </* Not implemented. */
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (is_ref) <Z_UNREACH_ZVAL(tmp); Z_SET_ISREF_P(tmp);
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else &if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else <splx(s);
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) <sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
&else &if (is_ref) &/* Not implemented. */
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
&else &tmp = EG(uninitialized_zval_ptr);
<else splx(s);
<else &/* XXX no reference */
if (is_ref) <if (mgr_type == z_type_p) &&Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) &Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) &Z_SET_ID(&kobj->id);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); <else Z_SET_REF_P(tmp);
<else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_pt
/* * The &POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else sys->sys->pOST = 0;
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (is_ref) /* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else &tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else <tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); &else &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
<else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else <ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* XXX: can't handle uninitialized zval_ptr as well */ /* not a bug in ptr_dc, since we've got a buffer to delete * this byte. */ if (zval_dc->ptr_end) <zend_debug("ZEND_API %s &n", zval_dc->ptr_end); zval_set_ptr_end("--");
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * Get a ZVAL_OPTION on the client to see if the object isn't configured. */ if (is_ref) <Z_GET_ID(&kobj->id); if (Z_GET_ID(&kobj->id)) Z_SET_ID(&kobj->id);
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
<else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else &tmp = EG(uninitialized_zval_pt
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else <ZVAL_SET_REF_P(tmp);
if (is_ref) <Z_IF_INIT(tmp); Z_SET_ISREF_P(tmp);
<else <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); &else &tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
&else &Z_SET_ISREF_P(tmp);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* XXX */ if (is_ref) if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
&else <Z_SET_REF_P(tmp);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else tmp = EG(uninitialized_zval_ptr);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
<else <if (is_ref)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else <if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else &if (is_ref) <Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
<else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (! zval_is_free(p)) if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
&else if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) <if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); &else Z_SET_ISO_PTR(tmp);
if (p) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
&else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else tmp = EG(uninitialized_zval_ptr);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
&else if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else tmp = EG(uninitialized_zval_ptr);
&else <if (is_ref) /* Not implemented. */
<else &if (is_ref) Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
else <if (is_ref) /* Not implemented. */
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); <else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
&else if (is_ref) </* Not implemented. */
else <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
&else &ZVAL_SET_REFCOUNT_P(tmp);
<else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (is_ref) if (mgr_type == z_type_p) <Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
else &if (is_ref) <Z_SET_ISREF_P(tmp);
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else &zval_set_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
else &Z_SET_ISREF_P(tmp);
<else &if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
else if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_pt
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
if (p) <zend_add_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* XXX */ if (is_ref) &if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref)
&else if (is_ref) <Z_SET_ISREF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
if (is_ref) ZVAL_SET_REFCOUNT_P(tmp);
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else if (is_ref) <ZVAL_COPY_VALUE(tmp, *p);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
<else &if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
<else &zval_set_symbol_table(TSRMLS_C); <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) splx(s);
<else <Z_TYPE_PP(p) &= KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
if (p) <zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; <if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); <else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
else if (is_ref) <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
/* XXX */ if (is_ref) <if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) &is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h,
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else &ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
else zend_hash_uninitialized_zval_ptr = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
Z_TYPE_PP(p) &= (SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
<else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (! zval_is_free(p)) &if (!zval_get_symbol_table(TSRMLS_C)) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
if (p) &zend_add_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (!EG(active_symbol_table)) zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_z
/* * The POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) sys->sys->pOST = 0; &else &sys->sys->pOST = 0;
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else <if (is_ref) &Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr);
if (is_ref) &if (mgr_type == z_type_p) <&Z_SET_ISO_PTR(tmp); <else Z_SET_ISO_PTR(tmp);
else <ZVAL_SET_REF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); <else <tmp = EG(uninitialized_zval_pt
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) p = __ZVAL___P(tmp); &else <tmp = EG(uninitialized_zval_ptr); else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
Z_TYPE_PP(p) &= <(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
&else &if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) Z_SET_REF_P(tmp);
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
<else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE &if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
&else <if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p);
if (!EG(active_symbol_table)) &zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
/* * XXX if we have an a %s, just write to the value of the value of this string. */ if (!symbol_table.mType) <if (is_ref) <SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else ZVAL_COPY_VALUE(tmp, *p); Z_SET_REFCOUNT_P(tmp);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) &Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else Z_SET_REF_P(tmp);
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); <else &/* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); <else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Check if it is a valid arg. */ if ((tmp = EG(p)) && (tmp == -1)) <p = __ZVAL___P(tmp); else tmp = EG(uninitialized_zval_ptr); &else p = EG(uninitialized_zval_ptr); /* It's the only -lptr and this has a new string */ tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Failed to get ptr ptr.");
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) <if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) &p = Z_TYPE_PP(p); <if (p) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
<else &zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p);
if (p) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
/* * The <POST' variable is set by the POST function, and not a part of the input list. */ if (is_ref) &sys->sys->pOST = 0; <else sys->sys->pOST = 0;
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) tmp = EG(uninitialized_zval_ptr); &else <tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Allocate the array in the atom_get() register if we are using this atom, a non-atomic structure to set atom_get() registers. */ if (!Z_TYPE_PP(p) & ZERO_GET_PROTO)) zend_rebuild_symbol_table(TSRMLS_C); <if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_
<else ZVAL_SET_REF_P(tmp);
if (!is_ref) &zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
<else if (is_ref) <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (p) <is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF; if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); else Z_ERR
else <if (is_ref) &SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; <else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
<else <if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
if (is_ref) Z_SET_REF_P(p);
if (!EG(active_symbol_table)) zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) <if (is_ref) <ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else <unk>
else if (is_ref) &Z_SET_ISREF_P(tmp);
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &if (is_ref) <Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(
if (is_ref) symbol_table = (struct symbol_table *) key->arKey; symbol_table->int_flags |= Z_F_REG_REF; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol_table->int_flags |= Z_F_REG_RAGE; symbol
<else <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); else <Z_SET_REF_P(tmp);
if (is_ref) <Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else tmp = EG(uninitialized_zval_ptr); &else Z_SET_REF_P(tmp);
Z_TYPE_PP(p) &= &(SIZE_PROTOCOL_STR)? Z_TYPE_PP(p) : Z_TYPE_PP(p) & &(SIZE_PROTOCOL_STR) : Z_TYPE_PP(p) & <(SIZE_PROTOCOL_STR) <Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p) & (SIZE_PROTOCOL_STR) Z_TYPE_PP(p)
if (is_ref) </* * ns is used */ Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); &else /* * No special variable XML */ tmp = EG(uninitialized_zval_ptr); Z_SET_REF_P(tmp);
<else &/* XXX */ /* XXX */
<else if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) <tmp = EG(uninitialized_zval_ptr); <else tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
if (! zval_is_free(p)) <if (!zval_get_symbol_table(TSRMLS_C)) zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s
&else &zend_hash_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE <if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else Z_SET_REF_P(tmp);
else &zend_hash_close(&key->p);
if (is_ref) <Z_ISREF_P(tmp);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) <p = Z_TYPE_PP(p); if (!p) <p = Z_TYPE_PP(p); <if (p) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
/* Get a symbol table for a single key in the g_type */ symbol_table_init(&key->arKey, &key->nKeyLength, key->h, &tmp, sizeof(zval_table)); /* Get the name of the real key in the slot of the symbol */ if (!symbol_table_init(&key->arKey, &key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, &tmp, sizeof(zval*), (void**)&p); else &tmp = EG(uninitialized_zval_pt
<else if (is_ref) <if (is_ref) &Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p);
<else <Z_TYPE_PP(p) &= &KEY_VAR; Z_TYPE_PP(p) &= <KEY_VAR; Z_TYPE_PP(p) &= KEY_VAR;
<else &zval_set_symbol_table(TSRMLS_C); &if (!EG(active_symbol_table)) <zend_rebuild_symbol_table(TSRMLS_C); if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable:
if (is_ref) <Z_SET_REF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **)&p); <else Z_SET_REF_P(tmp);
if (!is_ref) <zend_rebuild_symbol_table(TSRMLS_C); &if (zend_hash_quick_find(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p) == FAILURE) &if (is_ref) &ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_
if (is_ref) Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else <tmp = EG(uninitialized_zval_ptr); else Z_SET_REF_P(tmp);
<else if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p); else ZVAL_COPY_VALUE(tmp, *p); ZVAL_COPY_VALUE(tmp, *p);
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); &if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; &else if (Z_TYPE_PP(p) & (IS_LEXICAL_VAR|IS_LEXICAL_REF)) is_ref = Z_TYPE_PP(p) & IS_LEXICAL_REF;
/* XXX: Invalid variable length is NULL, check it */ if ((type == TYPE_TYPE) || (type == TYPE_TYPE)) &p = Z_TYPE_PP(p); if (!p) p = Z_TYPE_PP(p); if (p) &Z_SET_REF_P(tmp); Z_SET_REF_P(tmp); else Z_SET_REF_P(tmp);
else if (is_ref) ALLOC_INIT_ZVAL(tmp); Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, (void **) &p); &else &tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
tmp = EG(uninitialized_zval_ptr); /* &0x8f <-Z0X0010C -z0x00001 -z0x0010C -z0x0040 -z0x00000 */ tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr); tmp = EG(uninitialized_zval_ptr);
/* * Make sure we get a pointer to the /tmp/target variable * */ if (!args->arena_key) &if (!(args->arena_key)) &tmp = EG(uninitialized_zval_ptr); &else &tmp = EG(uninitialized_zval_ptr); else tmp = EG(uninitialized_zval_ptr); else if (is_ref) SEPARATE_ZVAL_TO_MAKE_IS_REF(p); tmp = *p; else else
/* * Restore the zval_stats and in the zval * function * to the next zval by <zval_stats_std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std::std
if (is_ref) Z_SET_ISREF_P(tmp); zend_hash_quick_add(EG(active_symbol_table), key->arKey, key->nKeyLength, key->h, sizeof(zval*), (void**)&p); &else <tmp = EG(uninitialized_zval_ptr); zend_error(E_NOTICE,"Undefined variable: %s", key->arKey);
