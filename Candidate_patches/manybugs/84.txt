golden:
tif->tif_flags |= TIFF_BUF4WRITE;
inference:

#endif
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
return ((tmsize_t) -1);
if (!WRITECHECKSTRIPS(tif, module)) return ((tmsize_t) -1);
return -1;
td->td_planarconfig = PLANARCONFIG_SEPARATE;
TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
*/
break;
TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes");
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
return (tmsize_t) -1;
splx(s);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
else  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
static const char module[] = "TIFFWriteEncodedStrip";
td->td_nstrips = 0;
const char module[] = "TIFFWriteEncodedStrip";
if (!BuFFERCHECK(tif)) return ((tmsize_t) -1);
printf("TIFFWriteEncodedStripn");
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return -1;
td->td_planarconfig == PLANARCONFIG_SEPARATE;
if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1);
return ((tmsize_t) - 1);
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
TIFFerrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (!WRITECHECKSTRIPS(tif, module)) return ((tmsize_t) - 1);
#ifdef DEBUG
if (td->td_nstrips)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
return 0;
TIFF_UNLOCK(tif);
td->td_nstrips = td->td_nstrips;
TIFFWriteEncodedStrip(tif, uint32 strip, void* data, tmsize_t cc);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
TIFFWriteEncodedStrip(tif, uint32 strip, void* data, tmsize_t cc)
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
TIFFerrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
uint16 sample;
free(td->td_planarconfig);
module[] = "TIFFWriteEncodedStrip";
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return (tmsize_t) -1;
td->td_nstrips = strip;
if (!BufFERCHECK(tif)) return ((tmsize_t) -1);
if (strip >= td->td_nstrips)
td->td_flags = 0;
TIFFGrowStrips(tif, 1, module);
else  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
return (-1);
free(td->td_nstrips);
td->td_planarconfig = 0;
module[0] = "TIFFWriteEncodedStrip";
@endif
int i;
static const char module[] = "TIFFWriteEncodedStrip"; TIFFDirectory *td = &tif->tif_dir; uint16 sample;
printf("TIFFWriteEncodedStrip");
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
TIFFErrorExt(tif->tif_clientdata, module, "Can't grow image by strips when using separate planes"); return ((tmsize_t) -1);
return (tmsize_t);
td->td_planarconfig = td->td_planarconfig;
if (!WRITECHECKSTRIPS(tif, module)) return -1;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return 0;
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module,
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t)-1);
if (strip >= td->td_nstrips)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes."); return ((tmsize_t) -1);
TIFFERRORExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can't grow image by strips when using separate planes");
if (strip >= td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not expand image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1) - 1;
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1));
td->td_nstrips = td->td_planarconfig;
tif->tif_curstrip = strip;
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) td->td_planarconfig = PLANARCONFIG_SEPARATE;
tif->tif_planarconfig = PLANARCONFIG_SEPARATE;
if (td->td_planarconfig)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFERRORExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (!WRITECHECKSTRIPS(tif, module)) return (-1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) 0);
/*
else  TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1));
TIFFErrorExt(tif->tif_clientdata, module, "Can not expand image by strips when using separate planes");
TIFFErrorExt(tif->tif_clientdata, module, _("Can not grow image by strips when using separate planes")); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes.");
TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if (td->td_nstrips)  TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) td->td_planarconfig == PLANARCONFIG_SEPARATE;
td->td_nstrips = -1;
static const char module[] = "TIFFWriteEncodedStrip"; TIFFDirectory *td = &tif->tif_dir;
TIFFErrorExt(tif->tif_clientdata, module, _("Can not grow image by strips when using separate planes"));
td->td_nstrips++;
if (strip >= td->td_nstrips)  td->td_planarconfig == PLANARCONFIG_SEPARATE;
const char module[] = "TIFFWriteEncodedStrip"; TIFFDirectory *td = &tif->tif_dir; uint16 sample;
else if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_flags = flags;
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strip when using separate planes"); return ((tmsize_t) -1);
if (!BUFFERCHECK(tif)) return ((tmsize_t) - 1);
TIFFErrorExt(tif->tif_clientdata, module, "can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) td->td_planarconfig == PLANARCONFIG_SEPARATE;
printf("TIFFWriteEncodedStrip()n");
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */
if (!BuFFERCHECK(tif)) return ((tmsize_t) - 1);
if (td->td_nstrips)
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) - 1));
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips while using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not build image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
if (td->td_nstrips) td->td_planarconfig = PLANARCONFIG_SEPARATE;
continue;
TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return -1;
tif->tif_planarconfig == PLANARCONFIG_SEPARATE;
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "can not grow image by strips when using separate planes");
td->td_planarconfig = NULL;
TIFF_LOCK_ASSERT(tif);
const char module[] = "TIFFWriteEncodedStrip"; TIFFDirectory *td = &tif->tif_dir;
TIFFErrorExt(tif->tif_clientdata, module, "cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips)  td->td_planarconfig == PLANARCONFIG_SEPARATE
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes");
return ((tmsize_t) - 1));
/* Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * Handle delayed allocation of data buffer. This * allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strip when using separate planes");
/* * Encode the supplied data and write it to the specified strip. */
td->td_nstrips = td->td_planarconfig == PLANARCONFIG_SEPARATE;
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip;
else  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
TIFFWriteEncodedStrip(tif, strip, void* data, tmsize_t cc)
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * information. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
TIFFWriteEncodedStrip(tif, uint32 strip, void* data, tmsize_t cc)  static const char module[] = "TIFFWriteEncodedStrip";
TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
if (td->td_nstrips)  td->td_planarconfig == PLANARCONFIG_SEPARATE;
if (strip >= td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
TIFFErrorExt(tif, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_flags = td->td_flags;
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) - 1);
tif->tif_nstrips = 0;
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1);
TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc);
else  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (!BUFFERCHECK(tif)) return -1;
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip;
/* * See if we have a row of space. */ td->td_reshape = td->td_reshape - (td->td_reshape * td->td_mapmap->td_reshape); if (td->td_reshape == 0)  td->td_reshape = td->td_reshape;
tif->tif_retval = 0;
td->td_curr_planarconfig = (TIFF_CTOR_IS_ALLOW_ANY)? -1 : -1;
if (td->td_nstrips)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_nstrips = td->td_nstrips; td->td_planarconfig == PLANARCONFIG_SEPARATE; if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * This is only if the image length is in a separate plane. */ if (td->td_td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE))  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); td->td_nstrips = td->td_planarconfig;
/* * No plugin mode exists! */
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace)  /* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE)  /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if (tif->tif_mode == FILE_B_DIR)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
/* * Read only the file on the file. */ if (!TIFFLock(tif->tif_ptr_lock)) return (-1);
if (td->td_maxdata)  td->td_maxdata = 0;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
td->td_data = td->td_data;
if (!TIFFFetchInitCmd(td, td->td_nstrips, td->td_map)) return ((tmsize_t) -1);
/* * * We need to use a sysconf with the sysconf with the sysconf with the sysconf flag. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes)  /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0)  TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0)  TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
td->td_stripperstrip = strip; if (!BufferChanged(td)) return ((tmsize_t) -1);
/* * Note that a file does not know how to handle multiple file objects. This may be a hack to make sure the file does not work properly, but we want to create a new ptid space. */ if ((tif->tif_global_ptid == NULL) || (tif->tif_global_ptid == NULL)) return ((tmsize_t) - 1));
if (td->td_xoptions)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
#ifdef MAC if (!BindSetModule())  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  #endif
if (td->td_resetmode)  TIFFErrorExt(td->td_resetmode, module, "TIFFResetmode %s", td->td_resetmode);
if (tif->tif_version == 0) return ((tmsize_t) -1);
if (td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_rp_nstrips) == 0) return ((td->td_rp_nstrips) -1);
if (!BASE_REFLOW)  td->td_td_td_stripsperimage = BASE_REFERENCE; return ((tmsize_t) -1);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row;  if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (td->td_freecc)  TIFFErrorExt(tif->tif_clientdata, module, "Can not freecc %s with freecc" % td->td_freecc); return ((tmsize_t) -1);
TIFFSetDebugPtr(tif->tif_device);
td->td_retval = td->td_retval;
if (td->td_prevline && td->td_prevline)  if (td->td_prevline && td->td_prevline)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
tif->tif_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_rowperstrip;
TIFF_REMOVE(&tif->tif_end);
if (!tif->tif_flags)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_flags |= TIFFFLOW_COUNT;
td->td_path = td->td_path; if (!td->td_path) return ((td->td_path) -1);
if ((td->td_debuglevel == 0) && (td->td_debuglevel == 0))  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_flags |= TIFFF_SETFROM_DIR;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((td->td_nstrips  0) || (td->td_planarconfig  0)) return (-1);
TIFFGrow(tif, 1, module);
TIFF_REMOVE(td->td_tree_row);
if (td->td_status == TRUE) return ((td->td_status) -1);
TIFFInit(tif->tif_if_curstrip, td->td_if_row);
/* * Handle delay of data buffer. This * allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowperimage) * td->td_rowsperstrip;
if (!td->td_cache) return ((td->td_cache) -1);
if (td->td_xnstrips)  /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_ynstrips = td->td_xnstrips;
/* * If the int' flags are used, so we can ignore the int' flags. */ tif->tif_flags = 0;
/* * Encode the supplied data and write it to the specified strip. */ if (!True) return ((tmsize_t) -1);
tif->tif_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->td_filenames[td->t
TIFF_UNLOCK_GIANT(tif);
if (!WITFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If the strip strip is inserted, the strip will be used if the file will be read and written by a strip. */ if (!RUTH_INSERT_EXPECTED(tif->tif_file, strip)) return ((tmsize_t) -1); td->td_flags |= td->td_flags | TIFF_FORWARD_EXPECTED; /* * Find the size of the file */ TIFF_DEFAULT(td->td_filename, strip, td->td_filename, td->td_filename, td->td_filename, td->td_filename, td->td_filename); if (!TIFF_RETURN_IS_INTERFACE(td->td_filename, td->td_filename)) return ((tmsize_t) -1);
if (!tif->tif_curdir)  tif->tif_curdir = strip;
tif->tif_module = NULL;
if (!SWINDOW_ROUTE)  TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip);  if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_clean_page = (td->td_clean_page % td->td_clean_page) * td->td_clean_page; td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page); td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page) * td->td_clean_page; if (td->td_clean_page == td->td_clean_page)  if (td->td_clean_page == td->td_clean_page
if (tif->tif_reflowend)  TIFF_RETURN(tif->tif_reflowend, tif->tif_reflowend);
if (strip >= td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '0')  td->td_stripperimage = td->td_imagelength;
if (strip >= td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curcurp = td->td_curcurp;
/* * When initializing, all the files must be set to zero. */
tif->tif_name = td->td_name;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S)  if (td->td_flags & TIFF_VARIABLE_S)  td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S;  if (td->td_flags & TIFF_VARIABLE_S)  if (td->td_flags & TIFF_VARIABLE_S)  td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (!IS_ANY(td->td_debug)) return (-1);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
if (strip >= td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL)  TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  #endif
/* * XXX XXX */
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
if (strip >= td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (!BufferFileHandle(tif, cc)) return ((tmsize_t) -1);
/* XXX */
if (td->td_nstrips  0)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawroot = td->td_rawroot; if (!WRITECHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td->td_rawroot = td->td_rawroot;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL))  if (td->td_curthread == NULL)  /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL))  /* * Get the code to a buffer. */ td->td_curthread = NULL;  td->td_curthread = NULL;
tif->tif_reglist = td->td_reglist;
if (!TIFFRECT_REFLOW) return (-1);
if (td->td_pmapspace == NULL)  td->td_spmapspace = NULL;
tif->tif_nstrips |= td->td_planarconfig;
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
if (td->td_cc.c_datasize  0)  TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
/* * If the data is not created, use the tif file. */ if (td->td_map.tqe_map.size() == 0)  if (td->td_map.tqe_map.size() == 0) return ((td->td_map.tqe_map.size() - 1) == 0) return ((td->td_map.tqe_map.size() - 1) == 0);
/* * The ptr array must be a string of numbers. */ if (td->td_planarconfig == INTF_BLOCK || td->td_planarconfig == INTF_BLOCK)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_idx = td->td_idx;
if (!(td->td_planarconfig == PLANARCONFIG_SEPARATE)) return ((tmsize_t) -1);
if (!NULL_PRINTF(tif->tif_packet, "TIFFWriteEncodedStrip")) return ((tmsize_t) - 1);
TIFFSetStopCnt();
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_flags & TIFFF_NOFREE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
tif->tif_clientdata.tif_curdir = &tif->tif_dir;
if (td->td_flags & TASKFAILURE) return ((td->td_flags & TASK_FIRST)? ((td->td_flags & TASKFIRST) : ((td->td_flags & TASK_LAST) || (td->td_flags & TASK_REFLOW)));
/* * Handle delay of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row;
if ((td->td_vp)!= 0)  if (td->td_vp->vp_stripsize == 0)  /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp;  else  /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_defines.strip[0] = strip; td->td_defines.strip[1] = strip; td->td_defines.strip[2] = strip; td->td_defines.strip[3] = strip; td->td_defines.strip[4] = strip; td->td_defines.strip[5] = strip; td->td_defines.strip[5] = strip; td->td_defines.strip[5] = strip; td->td_defines.strip[6] = strip; td->td_defines.strip[7] = strip; td->td_defines
if (td->td_len!= 0)  if (td->td_len  0)  TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
td->td_space.td_sample = td->td_space.td_space.td_sample; td->td_space.td_sample = td->td_space.td_sample;
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_row) * td->td_row;
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsaved = strip; td->td_stripsaved = strip; td->td_stripsaved = strip;
if (td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if ((td->td_samples & SAVEBITS) == 0)  TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
td->td_flags |= (TIFF_FICT_DIR_FILE); td->td_flags |= TIFF_FICT_DIR_FILE;
td->td_modularconfig == PLANARCONFIG_SEPARATE;
if (strip == td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE;   if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row;   if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (tif->tif_stripspaces == NULL)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_global >= TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1);
/* * XXX ::
if (td->td_imagelength == 0)  /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
td->td_map = map;
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_planarconfig == PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); tif->tif_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath)  if (td->td_canonpath)  td->td_canonpath = td->td_canonpath;   if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If the imagelength is set correctly, * then re-set it and clear the image length. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_type == TIFF_INT)  if (td->td_type == TIFF_INTERFACE) return ((tmsize_t) -1); TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL)  if (td->td_mapmap == NULL)  if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
/* * Note that this may not have any possible result. */ if (td->td_flags == TIFF_F_MAP)  /* * Reset the buffer. */ td->td_flags = TIFF_F_MAP;
if (td->td_nstrips)  if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);   if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BufferCheck(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips)  td->td_planarconfig == PLANARCONFIG_SEPARATE;
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE)  TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);  if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips

/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
<else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * Make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the <int' flags are used, so we can ignore the &int' flags. */ tif->tif_flags = 0;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
&else <TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (!SWINDOW_ROUTE) TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) if (td->td_mapmap == NULL) if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
if (!SWINDOW_ROUTE) TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); <if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
else <TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the imagelength is set correctly, * then re-set it and clear the image length. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
&else <TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (!tif->tif_flags) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((td->td_debuglevel == 0) && (td->td_debuglevel == 0)) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
#endif
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If the &int' flags are used, so we can ignore the &int' flags. */ tif->tif_flags = 0;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_samples & SAVEBITS) == 0) TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_samples & SAVEBITS) == 0) &TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
#ifdef MAC if (!BindSetModule()) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &#endif
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_planarconfig == PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); tif->tif_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) <if (td->td_mapmap == NULL) &if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Note that this may not have any possible result. */ if (td->td_flags == TIFF_F_MAP) /* * Reset the buffer. */ td->td_flags = TIFF_F_MAP;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if (!SWINDOW_ROUTE) <TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); <if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return (tmsize_t) -1;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
printf("TIFFWriteEncodedStrip()<n");
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_len!= 0) <if (td->td_len <0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (!BASE_REFLOW) <td->td_td_td_stripsperimage = BASE_REFERENCE; return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '&0') td->td_stripperimage = td->td_imagelength;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
/* * Note that this may not have any possible result. */ if (td->td_flags == TIFF_F_MAP) </* * Reset the buffer. */ td->td_flags = TIFF_F_MAP;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
&else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the &int' flags are used, so we can ignore the int' flags. */ tif->tif_flags = 0;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_xnstrips) &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_ynstrips = td->td_xnstrips;
if (td->td_type == TIFF_INT) &if (td->td_type == TIFF_INTERFACE) return ((tmsize_t) -1); TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
if (td->td_pmapspace == NULL) &td->td_spmapspace = NULL;
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_len!= 0) &if (td->td_len <0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
return ((tmsize_t) - 1);
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_flags & TIFFF_NOFREE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_len!= 0) <if (td->td_len &0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * Make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (!tif->tif_flags) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
td->td_flags |= (TIFF_FICT_DIR_FILE); td->td_flags |= TIFF_FICT_DIR_FILE;
if (td->td_flags & TIFFF_NOFREE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (tif->tif_reflowend) <TIFF_RETURN(tif->tif_reflowend, tif->tif_reflowend);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
<else <TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
<else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
td->td_planarconfig = PLANARCONFIG_SEPARATE;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the int' flags are used, so we can ignore the int' flags. */ tif->tif_flags = 0;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_len!= 0) <if (td->td_len &0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * See if we have a row of space. */ td->td_reshape = td->td_reshape - (td->td_reshape * td->td_mapmap->td_reshape); if (td->td_reshape == 0) &td->td_reshape = td->td_reshape;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_len!= 0) if (td->td_len 0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_xnstrips) </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_ynstrips = td->td_xnstrips;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&#endif
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_flags & TIFFF_NOFREE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if ((td->td_samples & <SAVEBITS) == 0) <TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return 0;
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) &/* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if (!SWINDOW_ROUTE) <TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_len!= 0) <if (td->td_len 0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (tif->tif_mode == FILE_B_DIR) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
printf("TIFFWriteEncodedStrip()&n");
if (!SWINDOW_ROUTE) <TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); &if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if ((td->td_nstrips &0) || (td->td_planarconfig <0)) return (-1);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); #endif
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
#ifdef MAC if (!BindSetModule()) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); #endif
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
&else TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_len!= 0) &if (td->td_len <0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (!WRITECHECKSTRIPS(tif, module)) return ((tmsize_t) -1);
else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_len!= 0) &if (td->td_len 0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curcurp = td->td_curcurp;
<else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_cc.c_datasize 0) &TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
<else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
<else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (!tif->tif_flags) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if (td->td_len!= 0) if (td->td_len 0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (!tif->tif_curdir) tif->tif_curdir = strip;
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If the int' flags are used, so we can ignore the &int' flags. */ tif->tif_flags = 0;
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
&/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_xoptions) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_resetmode) &TIFFErrorExt(td->td_resetmode, module, "TIFFResetmode %s", td->td_resetmode);
if (tif->tif_stripspaces == NULL) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_maxdata) <td->td_maxdata = 0;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * Note that this may not have any possible result. */ if (td->td_flags == TIFF_F_MAP) &/* * Reset the buffer. */ td->td_flags = TIFF_F_MAP;
else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
&else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
</* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curcurp = td->td_curcurp;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * See if we have a row of space. */ td->td_reshape = td->td_reshape - (td->td_reshape * td->td_mapmap->td_reshape); if (td->td_reshape == 0) <td->td_reshape = td->td_reshape;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_xnstrips) /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_ynstrips = td->td_xnstrips;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
td->td_flags |= &(TIFF_FICT_DIR_FILE); td->td_flags |= TIFF_FICT_DIR_FILE;
if (tif->tif_mode == FILE_B_DIR) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_cc.c_datasize &0) &TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
<if (!WRITECHECKSTRIPS(tif, module)) return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) if (td->td_mapmap == NULL) &if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
TIFFWriteEncodedStrip(tif, uint32 strip, void* data, tmsize_t cc) &static const char module[] = "TIFFWriteEncodedStrip";
else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
TIFFWriteEncodedStrip(tif, uint32 strip, void* data, tmsize_t cc) <static const char module[] = "TIFFWriteEncodedStrip";
if (tif->tif_mode == FILE_B_DIR) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_nstrips <0) || (td->td_planarconfig &0)) return (-1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
<if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
&/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) /* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if ((td->td_nstrips 0) || (td->td_planarconfig <0)) return (-1);
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
<else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
<if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return -1;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
<else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
<else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (tif->tif_mode == FILE_B_DIR) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_len!= 0) &if (td->td_len <0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) <TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <#endif
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_len!= 0) if (td->td_len &0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) &td->td_planarconfig == PLANARCONFIG_SEPARATE;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) <TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); #endif
<else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips)
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_type == TIFF_INT) <if (td->td_type == TIFF_INTERFACE) return ((tmsize_t) -1); TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (!tif->tif_curdir) <tif->tif_curdir = strip;
/* * If the <int' flags are used, so we can ignore the int' flags. */ tif->tif_flags = 0;
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
return (tmsize_t) -1;
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '0') td->td_stripperimage = td->td_imagelength;
else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_maxdata) &td->td_maxdata = 0;
if (td->td_freecc) &TIFFErrorExt(tif->tif_clientdata, module, "Can not freecc %s with freecc" % td->td_freecc); return ((tmsize_t) -1);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If the data is not created, use the tif file. */ if (td->td_map.tqe_map.size() == 0) &if (td->td_map.tqe_map.size() == 0) return ((td->td_map.tqe_map.size() - 1) == 0) return ((td->td_map.tqe_map.size() - 1) == 0);
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_nstrips = td->td_nstrips; td->td_planarconfig == PLANARCONFIG_SEPARATE; if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_len!= 0) if (td->td_len &0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * * We need to use a sysconf with the sysconf with the sysconf with the sysconf flag. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_nstrips &0) || (td->td_planarconfig 0)) return (-1);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((td->td_samples & <SAVEBITS) == 0) &TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
&if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the <int' flags are used, so we can ignore the <int' flags. */ tif->tif_flags = 0;
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
else TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
&else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) if (td->td_mapmap == NULL) <if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_flags & TIFFF_NOFREE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_len!= 0) &if (td->td_len &0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_nstrips &0) || (td->td_planarconfig &0)) return (-1);
if (td->td_freecc) TIFFErrorExt(tif->tif_clientdata, module, "Can not freecc %s with freecc" % td->td_freecc); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) <TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &#endif
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
&else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip == td->td_nstrips) td->td_planarconfig == PLANARCONFIG_SEPARATE;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
TIFFErrorExt(tif->tif_clientdata, module, "Can not expand image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (tif->tif_reflowend) TIFF_RETURN(tif->tif_reflowend, tif->tif_reflowend);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '&0') &td->td_stripperimage = td->td_imagelength;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
<else TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (tif->tif_mode == FILE_B_DIR) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_len!= 0) &if (td->td_len &0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_len!= 0) if (td->td_len <0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_len!= 0) <if (td->td_len 0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
<else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_len!= 0) &if (td->td_len 0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
<else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
<else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
printf("TIFFWriteEncodedStripn");
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (!BASE_REFLOW) &td->td_td_td_stripsperimage = BASE_REFERENCE; return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (tif->tif_stripspaces == NULL) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (!BASE_REFLOW) td->td_td_td_stripsperimage = BASE_REFERENCE; return ((tmsize_t) -1);
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_cc.c_datasize <0) TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
if (td->td_len!= 0) if (td->td_len <0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
printf("TIFFWriteEncodedStrip()n");
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip >= td->td_nstrips) <td->td_planarconfig == PLANARCONFIG_SEPARATE
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <#endif
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
&else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
<else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '0') &td->td_stripperimage = td->td_imagelength;
if (!SWINDOW_ROUTE) &TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); &if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
#ifdef MAC if (!BindSetModule()) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &#endif
&else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) &/* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if (td->td_flags & TIFFF_NOFREE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * The ptr array must be a string of numbers. */ if (td->td_planarconfig == INTF_BLOCK || td->td_planarconfig == INTF_BLOCK) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_maxdata) td->td_maxdata = 0;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * The ptr array must be a string of numbers. */ if (td->td_planarconfig == INTF_BLOCK || td->td_planarconfig == INTF_BLOCK) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
<else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (tif->tif_mode == FILE_B_DIR) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
<else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
&else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_planarconfig) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) &TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &#endif
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_len!= 0) if (td->td_len &0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
<else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_clean_page = (td->td_clean_page % td->td_clean_page) * td->td_clean_page; td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page); td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page) * td->td_clean_page; if (td->td_clean_page == td->td_clean_page) if (td->td_clean_page == td->td_clean_page
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (!SWINDOW_ROUTE) &TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); <if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_type == TIFF_INT) if (td->td_type == TIFF_INTERFACE) return ((tmsize_t) -1); TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
&else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
<else &TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
<else &TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_len!= 0) <if (td->td_len <0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&else &TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) <if (td->td_mapmap == NULL) <if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) </* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
<else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_cc.c_datasize &0) TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) /* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
<else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_cc.c_datasize 0) <TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_nstrips = td->td_nstrips; td->td_planarconfig == PLANARCONFIG_SEPARATE; if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) &if (td->td_mapmap == NULL) if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) </* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) td->td_planarconfig == PLANARCONFIG_SEPARATE;
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_pmapspace == NULL) td->td_spmapspace = NULL;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '&0') <td->td_stripperimage = td->td_imagelength;
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return -1;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_len!= 0) <if (td->td_len &0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
<else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_xoptions) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_freecc) <TIFFErrorExt(tif->tif_clientdata, module, "Can not freecc %s with freecc" % td->td_freecc); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
#ifdef MAC if (!BindSetModule()) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); #endif
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &#endif
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&if (!WRITECHECKSTRIPS(tif, module)) return ((tmsize_t) -1);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_clean_page = (td->td_clean_page % td->td_clean_page) * td->td_clean_page; td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page); td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page) * td->td_clean_page; if (td->td_clean_page == td->td_clean_page) &if (td->td_clean_page == td->td_clean_page
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) &td->td_planarconfig == PLANARCONFIG_SEPARATE;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
else TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) <td->td_planarconfig == PLANARCONFIG_SEPARATE;
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_nstrips) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
if (tif->tif_stripspaces == NULL) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
&/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curcurp = td->td_curcurp;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) &TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <#endif
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_samples & &SAVEBITS) == 0) TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((td->td_debuglevel == 0) && (td->td_debuglevel == 0)) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * * We need to use a sysconf with the sysconf with the sysconf with the sysconf flag. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) 0);
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (!tif->tif_curdir) &tif->tif_curdir = strip;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
printf("TIFFWriteEncodedStrip<n");
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
#ifdef MAC if (!BindSetModule()) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <#endif
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_nstrips 0) || (td->td_planarconfig 0)) return (-1);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
TIFFERRORExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) &if (td->td_mapmap == NULL) &if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
&else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_len!= 0) if (td->td_len <0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can't grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
&else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && (td->td_planarconfig == PLANARCONFIG_SEPARATE)) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((td->td_samples & <SAVEBITS) == 0) TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &td->td_planarconfig == PLANARCONFIG_SEPARATE;
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_nstrips <0) || (td->td_planarconfig 0)) return (-1);
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_xoptions) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_cc.c_datasize 0) TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
/* * See if we have a row of space. */ td->td_reshape = td->td_reshape - (td->td_reshape * td->td_mapmap->td_reshape); if (td->td_reshape == 0) td->td_reshape = td->td_reshape;
if (strip == td->td_nstrips) <td->td_planarconfig == PLANARCONFIG_SEPARATE;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_row) * td->td_row;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '0') <td->td_stripperimage = td->td_imagelength;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If the data is not created, use the tif file. */ if (td->td_map.tqe_map.size() == 0) if (td->td_map.tqe_map.size() == 0) return ((td->td_map.tqe_map.size() - 1) == 0) return ((td->td_map.tqe_map.size() - 1) == 0);
else &TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * This is only if the image length is in a separate plane. */ if (td->td_td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
&else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_samples & SAVEBITS) == 0) <TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
#ifdef DEBUG if ((tif->tif_canonical_filename = tif->tif_canonical_filename)!= NULL) &TIFFErrorExt(tif->tif_canonical_filename, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); #endif
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
&else TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * Make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1) - 1;
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (!WRITECHECKSTRIPS(tif, module)) return ((tmsize_t) -1);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes."); return ((tmsize_t) -1);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
&else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_flags & TIFFF_NOFREE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
#ifdef MAC if (!BindSetModule()) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <#endif
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_len!= 0) if (td->td_len 0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
<else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * * We need to use a sysconf with the sysconf with the sysconf with the sysconf flag. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) <if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '<0') &td->td_stripperimage = td->td_imagelength;
TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
printf("TIFFWriteEncodedStrip&n");
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '<0') <td->td_stripperimage = td->td_imagelength;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) &/* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if (tif->tif_mode == FILE_B_DIR) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
/* * This is only if the image length is in a separate plane. */ if (td->td_td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
<else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_samples & &SAVEBITS) == 0) <TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
&else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
&if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (tif->tif_reflowend) &TIFF_RETURN(tif->tif_reflowend, tif->tif_reflowend);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &&if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
TIFFerrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t)-1);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_cc.c_datasize <0) <TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
&else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
/* * Only allow the list of the data in a section. This is used by a TIFF_int std.tif_name(); */ if (td->td_names[0] == '<0') td->td_stripperimage = td->td_imagelength;
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (!SWINDOW_ROUTE) TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); &if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_len!= 0) <if (td->td_len 0) <TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
/* * The ptr array must be a string of numbers. */ if (td->td_planarconfig == INTF_BLOCK || td->td_planarconfig == INTF_BLOCK) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
<else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
td->td_flags |= <(TIFF_FICT_DIR_FILE); td->td_flags |= TIFF_FICT_DIR_FILE;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_cc.c_datasize <0) &TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) /* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * FIXME::__STYLE__ (in case 0) */ if (td->td_namespace) </* * FIXME::__STYLE__ (in case 0) */ if (td->td_nstrips && td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_rawplanar = TIFFhowmany_32(td->td_rawplanar, td->td_rawplanar);
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
if (td->td_pmapspace == NULL) <td->td_spmapspace = NULL;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if (strip >= td->td_nstrips) <td->td_planarconfig == PLANARCONFIG_SEPARATE;
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_flags & TIFFF_NOFREE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
</* * Handle delay of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row;
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
&else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) - 1);
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (strip >= td->td_nstrips) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the imagelength is set correctly, * then re-set it and clear the image length. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If the &int' flags are used, so we can ignore the <int' flags. */ tif->tif_flags = 0;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
#ifdef MAC if (!BindSetModule()) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); #endif
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips <0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_resetmode) <TIFFErrorExt(td->td_resetmode, module, "TIFFResetmode %s", td->td_resetmode);
if (td->td_len!= 0) &if (td->td_len 0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
if (td->td_nstrips) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
return ((tmsize_t) -1);
/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_nstrips = td->td_nstrips; td->td_planarconfig == PLANARCONFIG_SEPARATE; if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * If the int' flags are used, so we can ignore the <int' flags. */ tif->tif_flags = 0;
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
&else &TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
if (td->td_len!= 0) <if (td->td_len <0) TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
#ifdef MAC if (!BindSetModule()) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &#endif
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
&else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (!SWINDOW_ROUTE) &TIFFErrorExt(tif->tif_clientdata, module, "Was 0x%02x", td->td_clientdata, strip); if (!SWINDOW_ROUTE) return ((tmsize_t) -1); if (!WINDOW_ROWS(tif, 1, module)) return ((tmsize_t) -1); td->td_row = strip; td->td_row = (strip % td->td_row) * td->td_row;
if (tif->tif_mode == FILE_B_DIR) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
else if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
<if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) &/* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
&else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_flags & TIFFF_NOFREE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
&else &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_resize = strip; td->td_stripsize = strip; td->td_rowstrip = strip;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
<else <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
&/* * Handle delay of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_len!= 0) &if (td->td_len &0) &TIFFErrorExt(td->td_len, module, "TIFFLen failed"); return ((tmsize_t) -1);
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) &if (td->td_mapmap == NULL) <if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) <TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) /* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * Handle delay of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row;
else <TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
return -1;
/* * Add all resources to the user * and the resource pointer and then we make sure that there's a bit of space in the buffer. */ if (td->td_mapmap!= NULL) <if (td->td_mapmap == NULL) if (!TIFF_IS_MPTY(td->td_mapmap)) return ((tmsize_t) -1);
TIFFWriteEncodedStrip(tif, uint32 strip, void* data, tmsize_t cc) static const char module[] = "TIFFWriteEncodedStrip";
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else &/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
&else &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &<if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = PLANARCONFIG_SEPARATE; TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
/* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_clean_page = (td->td_clean_page % td->td_clean_page) * td->td_clean_page; td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page); td->td_clean_page = (td->td_clean_page % td->td_clean_page % td->td_clean_page) * td->td_clean_page; if (td->td_clean_page == td->td_clean_page) <if (td->td_clean_page == td->td_clean_page
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (td->td_nstrips) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the data is not created, use the tif file. */ if (td->td_map.tqe_map.size() == 0) <if (td->td_map.tqe_map.size() == 0) return ((td->td_map.tqe_map.size() - 1) == 0) return ((td->td_map.tqe_map.size() - 1) == 0);
if (td->td_nstrips 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_samples & &SAVEBITS) == 0) &TIFFErrorExt(td->td_samples, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
/* * Check if there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_planarconfig = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BuFFERCHECK(tif)) return ((tmsize_t) -1); td->td_curs
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) &td->td_planarconfig == PLANARCONFIG_SEPARATE
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
#ifdef MAC if (!BindSetModule()) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <#endif
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if ((td->td_debuglevel == 0) && (td->td_debuglevel == 0)) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
</* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
td->td_nstrips = 0; /* * Check out if there's space. * We're trying to remove some of the info in the list. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_prevline && td->td_prevline) <if (td->td_prevline && td->td_prevline) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if ((td->td_nstrips 0) || (td->td_planarconfig &0)) return (-1);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
else &TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * This is only if the image length is in a separate plane. */ if (td->td_td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_nstrips <0) || (td->td_planarconfig <0)) return (-1);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
<else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <&if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) </* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) &td->td_canonpath = td->td_canonpath; <<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_resetmode) TIFFErrorExt(td->td_resetmode, module, "TIFFResetmode %s", td->td_resetmode);
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) if (td->td_canonpath) td->td_canonpath = td->td_canonpath; &<if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
if (td->td_nstrips &0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * Try to make sure there's space. * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!td->td_stripsperimage) return ((tmsize_t) -1); td->t
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rv = td->td_rv;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_nstrips &0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) &/* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
&/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) /* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; &td->td_curthread = NULL;
if (td->td_flags & TIFFF_NOFREE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_flags = TIFFGrowStrips(tif, 1, module);
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If the imagelength is set correctly, * then re-set it and clear the image length. */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If the first path has already been specified. */ if ((td->td_planarconfig == PLANARCONFIG_SEPARATE) && td->td_canonpath) &if (td->td_canonpath) <td->td_canonpath = td->td_canonpath; <if (!td->td_canonpath) return ((tmsize_t) -1); td->td_canonpath = td->td_canonpath;
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BufferCheck(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips &0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if (td->td_imagelength == 0) &/* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_cc.c_datasize &0) <TIFFCALL_LATE_REQUIRED(td->td_cc, td->td_cc, td->td_cc.c_datasize);
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) /* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
&else TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_planarconfig) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
<else TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_statsrsh_rsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bsrsh_bs
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (tif->tif_mode == FILE_B_DIR) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); tif->tif_curstrip = strip; td->td_row = (strip % td->td_rowsperstrip);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
</* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BuFFERCHECK(tif)) return ((tmsize_t) -1);
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; &if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
</* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) &td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw
if ((tif->tif_nstrips) && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
/* * If we need the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_cleanupstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstripstrips
if (td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); /* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips <0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if (td->td_nstrips) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) &if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; <else /* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if ((td->td_vp)!= 0) <if (td->td_vp->vp_stripsize == 0) </* * Handle delayed allocation of data buffer. This allows it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_vp = td->td_vp; &else </* * Handle delayed allocation of data buffer. This permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1);
if (td->td_prevline && td->td_prevline) &if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
/* * See if we need to have to read a bit of the string. * * We don't want to be able to read a bit of the string from the library and we can * just read the atoms. */ if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (td->td_imagelength == 0) </* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (td->td_imagelength == 0) /* * Set the image length for td->td_strip. */ if (td->td_nstrips == 0) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(td->td_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_nstrips && td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td->td_rowsperstrip;
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
if (strip == td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
/* * Add the strip object to the object list. */ if (! td->td_space_attributes) </* * Set the directory information as it is a non-txt on the * table. */ if (td->td_nstrips == 0) &TIFFErrorExt(td->td_space_attributes, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_space_attributes = &td->td_space_attributes; if (td->td_space_attributes == 0) TIFFErrorExt(tif->tif_space_attributes, module
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) <if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= &TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; <if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (td->td_prevline && td->td_prevline) if (td->td_prevline && td->td_prevline) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_remove_rpath(td->td_remove_rpath);
else <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips <0) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curcurproc = td->td_curproc; td->td_curcurproc = td->td_curproc;
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
if (strip >= td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &/* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
<else <TIFFErrorExt(tif->tif_clientdata, module, "Cannot grow image by strips when using separate planes"); return ((tmsize_t) -1);
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) <if (td->td_curthread == NULL) &/* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) /* * Get the code to a buffer. */ td->td_curthread = NULL; td->td_curthread = NULL;
/* * In the case of a more * binary-size space, make sure there's space. */ if (td->td_flags & TIFF_VARIABLE_S) &if (td->td_flags & TIFF_VARIABLE_S) <td->td_flags &= <TIFF_VARIABLE_S; td->td_flags |= TIFF_VARIABLE_S; &if (td->td_flags & TIFF_VARIABLE_S) if (td->td_flags & TIFF_VARIABLE_S) td->td_flags &= TIFF_VARIABLE_S; td->td_flags &= TIFF_VARIABLE_S;
if (strip >= td->td_nstrips) td->td_planarconfig == PLANARCONFIG_SEPARATE;
if (strip >= td->td_nstrips) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); </* * Handle delayed allocation of data buffer. This * permits it to be sized according to the directory * info. */ if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength,
if (td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <<if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
if (strip == td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_planarconfig == PLANARCONFIG_SEPARATE; <&if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = strip; td->td_row = td->td_row; if (!td->td_init) return ((td->td_init) -1); td->td_nstrips = td->td_planarconfig;
&if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes");
if (td->td_nstrips)
/* * We don't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_curstrip = strip; td->td_row = (strip % td->td_stripsperimage) * td->td_row; <if (!WIFFERCHECKSTRIPS(tif, module)) return ((tmsize_t) -1); td
if ((tif->tif_curthread == NULL) && (tif->tif_curthread == NULL)) &if (td->td_curthread == NULL) </* * This should be an "error" message. */ if ((td->td_curthread == NULL) && (td->td_curthread == NULL)) &/* * Get the code to a buffer. */ td->td_curthread = NULL; <td->td_curthread = NULL;
/* * We can't support dynamically growing files that * have data organized in separate bitplanes because * it's too painful. In that case we require that * the imagelength be set properly before the first * write (so that the strips array will be fully * allocated above). */ if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_raw_stripstrip = strip; td->td_raw_row = (strip % td->td_raw_stripstrip); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) &if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); &if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1);
/* * If it's an empty flag, do we really need to update it */ if (tif->tif_planarconfig == PLANARCONFIG_SEPARATE) if (td->td_planarconfig == PLANARCONFIG_SEPARATE) &TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!TIFFGrowStrips(tif, 1, module)) return ((tmsize_t) -1); td->td_rowsperimage = TIFFhowmany_32(td->td_image
if (strip >= td->td_nstrips) td->td_planarconfig == PLANARCONFIG_SEPARATE
if (td->td_nstrips) <if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
<#endif
if (td->td_planarconfig == PLANARCONFIG_SEPARATE) TIFFErrorExt(tif->tif_clientdata, module, "Can not grow image by strips when using separate planes"); return ((tmsize_t) -1); <if (!BUFFERCHECK(tif)) return ((tmsize_t) -1); td->td_stripsperimage = TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);
