golden:
case COND_RESULT_UNSET: return COND_RESULT_UNSET; default: break;
inference:

#endif
return COND_RESULT_FALSE;
break;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
config_check_cond_nocache(srv, con, dc->parent);
config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_FALSE:
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
srv_sock = con->srv_socket;
config_check_cond_cached(srv, con, dc->parent->key);
splx(s);
config_check_cond_nocache(srv, con, dc->context_ndx);
config_check_cond_nocache(srv, con, dc->parent->key);
*/
config_check_cond_cache(srv, con, dc->parent);
return (COND_RESULT_FALSE);
/* pass the rules */
/* make sure prev is checked first */
default: return COND_RESULT_FALSE;
/* check parent first */
config_check_cond_cached(srv, con, dc->context_ndx);
case COND_RESULT_FALSE: break;
default: break;
TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
config_check_cond_nocache(srv, con, dc->parent->context_ndx);
case COND_RESULT_FALSE: return COND_RESULT_FALSE;
#ifdef DEBUG
if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (config_check_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
config_check_cond_cache(srv, con, dc->parent->key);
else  config_check_cond_nocache(srv, con, dc->parent);
config_check_cond_cache(srv, con, dc->context_ndx);
return COND_RESULT_TRUE;
srv = con->srv_socket;
if (!con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->parent)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
config_check_cond_nocache(srv, con, con->context_ndx);
if (con->conf.log_condition_handling == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
return COND_RESULT_UNSET;
else  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_RESULT_UNSET:
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
config_check_cond_cached(srv, con, dc->prev);
config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE;
/* XXX */
free(srv);
/* one of prev set me to FALSE */
return NULL;
return 0;
config_check_cond_nocache(srv, con, dc->prev);
int i;
log_error_write(srv, __LINE__, "sb", "go parent", dc->parent->key);
if (config_check_cond_cache(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
/*
if (config_check_cond_cache(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
#ifdef DIAGNOSTIC
/* return COND_RESULT_FALSE;
COND_RESULT_FALSE = COND_RESULT_FALSE;
__FILE__ = __LINE__;
else  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
else  return COND_RESULT_FALSE;
free(dc->context_ndx);
if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_condition_handling)  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling)  config_check_cond_cached(srv, con, dc->parent->key);
config_check_cond_nocache();
*srv_sock = con->srv_socket;
log_error_write(srv, __LINE__, __LINE__, "sb", "go parent", dc->parent->key);
dc->prev = NULL;
if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
else  config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling)
if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)
config_check_cond_cached(srv, con, dc->context_ndx->key);
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)
case COND_RESULT_FALSE: case COND_RESULT_FALSE:
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->prev) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
con->conf.log_condition_handling = COND_RESULT_FALSE;
log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
if (srv == NULL) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, con->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE) return COND_RESULT_FALSE;
else
if (con->conf.log_condition_handling) return COND_RESULT_FALSE;
log_error_write(srv, __FILE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
/* make sure prev is checked first */ config_check_cond_cached(srv, con, dc->prev);
dc->context_ndx = con->srv_socket;
else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
config_check_cond_free(srv);
config_check_cond_nocache(srv, con, dc->parent, NULL);
config_check_cond_nocache(srv, con);
__LINE__ = "sb", "go parent", dc->parent->key);
case COMP_UNSET:
config_check_cond_nocache(srv, con, con->parent->context_ndx);
return config_check_cond_nocache(srv, con, dc->parent);
case COND_RESULT_FALSE: log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
error("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
config_check_cond_nocache(srv, con, dc->conf);
config_check_cond_cache(srv, con, dc->prev);
config_check_cond_cached(srv, con, con->cond_cache[dc->context_ndx].result);
config_check_cond_nocache_check(srv, con, dc->parent);
(void) config_check_cond_nocache(srv, con, dc->parent);
if (config_check_cond_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
case COMP_COND_UNSET:
log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key);
/* make sure prev is checked first */ config_check_cond_cached(srv, con, dc->parent);
if (con->conf.verbose)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* return COND_RESULT_FALSE; */
config_check_cond_nocache_free(srv);
else  config_check_cond_nocache(srv, con, dc->context_ndx);
if (srv == NULL)  return COND_RESULT_FALSE;
config_check_cond_nocache(srv, con, dc->parent->key, NULL);
if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling)  config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling) config_check_cond_cached(srv, con, dc->parent);
else  config_check_cond_nocache(srv, con, dc->parent->context_ndx);
config_check_cond_cached(srv, con, dc->parent) = COND_RESULT_FALSE;
if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
else if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling == COND_RESULT_FALSE)
else  config_check_cond_nocache(srv, con, dc->parent->key);
config_check_cond_nocache_cache(srv, con, dc->parent);
config_check_cond_nocache(srv, con, dc->context_ndx, NULL);
config_check_cond_cached(srv, con, con->parent->key);
if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result)  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) config_check_cond_cached(srv, con, dc->parent->key);
/* make sure prev is checked first */ config_check_cond_cached(srv, con, dc->parent->key);
if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)
config_check_cond_nocache_cached(srv, con, dc->parent);
if (dc->parent)  config_check_cond_cached(srv, con, dc->parent);
config_check_cond_nocache(srv, con, con->srv_socket);
default:
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT)  return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->context->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
else config_check_cond_nocache(srv, con, dc->parent);
if (config_check_cond_cached(srv, con, dc->prev->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE)  config_check_cond_cached(srv, con, dc->parent->key);
config_check_cond_nocache(srv, con, con->conf.log_condition_handling);
log_error_write(srv, __FILE__, __LINE__, "sb", "go", dc->parent->key);
case COND_RESULT_FALSE: config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_FALSE: config_check_cond_nocache(srv, con, dc->parent);
if (config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE)  config_check_cond_cached(srv, con, dc->parent);
continue;
else  config_check_cond_cached(srv, con, dc->parent->key);
case COND_RESULT_FALSE: config_check_cond_cached(srv, con, dc->parent); break;
if (dc->parent) config_check_cond_cached(srv, con, dc->parent->key);
if (COND_RESULT_FALSE == con->cond_cache[con->context_ndx].result)  return COND_RESULT_FALSE;
config_check_cond_nocache_check(srv, con, dc->parent->key);
if (!dc->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure prev is checked first */ config_check_cond_cached(srv, con, dc->context_ndx);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING)  fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE;  if (dc->dc.debug)  fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling)  return COND_RESULT_FALSE;  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;
case COND_RESULT_EXCEPTION: /* * No memory, only * this is a case LOG_COND_LOADING */
if (con->conf.log_condition_handling && con->conf.log_condition_handling->pg)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* check parent first */ if (dc->parent && con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->conf.sock_result)  config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (con->conf.conf_cond_cache_cond_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.conf_conf_state & conf->conf.conf_state)  if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET)  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
case COMP_RESULT_READY: config_check_cond_nocache(srv, con, dc->context_ndx);
if (dc->context_ndx->cache_switch)  config_check_cond_nocache(srv, con, dc->context_ndx->cache_switch);
/* just do a dev */ if (con->conf.d_flags & COND_UNSET)  config_check_cond_nocache(srv, con, con->conf.d_flags & COND_UNSET);
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key);  /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;  /* pass the rules */ switch (dc->comp)  case COND_RESULT_FALSE: break;  case COND_RESULT_FALSE: if (con->conf.log
case COND_PREFIX:
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL)  /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE)  if (con->conf.log_condition_handling == COND_RESULT_FALSE)  config_check_cond_cached(srv, con, dc->parent->key);   if (con->conf.log_condition_handling == COND_RESULT_FALSE)  config_check_cond_cached(srv, con, dc->parent->key);   if (dc->prev)  if (dc->prev)  config_check_cond_cached(srv, con, dc->prev);  if (dc->comp == CON
/* if the conditional isn't specified */ if (con->conf.log_condition_handling)  /* the conditions can be created while we haven't clear any problems. */ case COMP_NO_COND: /* the conditions will be changed as well as to make sure we have a cond_cond_cache_saved */
/* pass the rules */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: /* return the rule */ case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: /* return the rule */ case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ_ONLY_STATUS: case COMP_READ
if (srv == -1)  srv =  &srv->srv_socket;  if (!srv->srv_socket)  if (dc->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket);  return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE)  if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;   if (dc->prev)  if (con->conf.log_state & COND_RESULT_FALSE)  if (con->conf.log_state & COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key);  /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result)  log_error_write(srv, __
if (con->conf.verbose)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result)  config_check_cond_cached(srv, con, dc->parent);
case COND_RUN:
/* check parent first */ if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx)  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;   if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling)  config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;   if (dc->dc->srv)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (con->conf.log_condition_hand
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr)  if (!con->cond_cache[con->cond_pr_pr_pr].result)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
if (dc->conf.log_conf)  if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
case COND_UNSET: case COND_UNSET:
/* handle connection flags */ if (config_check_cond_flags)  if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;   if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;  if (dc->prev)  if (config_check_cond_cached(srv, con, dc->parent
/* a check for dc->context_ndx */
if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name)  if (con->conf.log_condition_handling)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
case COMP_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_COND_NO_COND_COND_NO_COND_NO_COND_COND_NO_COND_NO_COND_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_
if (!con->cond_cache[dc->prev->key].result)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
if (dc->cache_path == NULL)  if (con->conf.log_queue_handled)  log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
/* not defined */
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result)  if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result)  /* check parent first */ return COND_RESULT_FALSE;  if (dc->parent && con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("
if (dc->flags & COND_RESULT_LOCK)  if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH])  if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_cond_cache[dc->comp])  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_cond_cache[dc->context
/* try to free the client's password */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (con->conf.conf.log_condition_handling)  /* check if we're going to a parent, or this will work in some case */ config_check_cond_cached(srv, con, dc->parent->key);
#ifdef WIN_INET /* * if the virtual host hasn't been WANTED, we'll have a WANTED session. */ if (dc->socket_events_report_flags & DEBUG_COND)  DEBUG_COND("cond[%d] hasn't WANTED, need to set up the session" "need to return" "one of the WANTED event" "device.noevent.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report
/* check for */
/* if config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key);  if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;   if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]);  return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
if (con->conf.log_cond_cache[dc->context_ndx].result)
case _COND_DEC_PROT_COND_NO_ACCESS: /* do we're logging out? */
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
if (srv == -1)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* for sure we have to run config_check_cond_nocache(a p) */ if (p)  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling)  config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
case COMP_DEBUG: log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
/* not a working directory, */ if (dc->debug_config)  if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
case COND_RESULT_UNSET: if (con->conf.log_condition_handling)  /* pass the rules */ config_check_cond_cached(srv, con, dc->parent->key);
case COMP_COND_UNSET: case COMP_COND_NOT_UNSET:
case ACCESS_ENTRY_HAS_OBSERVER: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTERVAL_HANDLE: case ACCESS_INTE
#ifdef MAKE_NO_COND_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_NO_COND_COND_NO_COND_COND_NO_COND_COND_NO_COND_NO_COND_CON
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  #endif
/* if (con->conf.log_condition_handling == COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE)  if (con->conf.get_conditional_type() == COND_RESULT_FALSE)  if (con->conf.get_conditional_type() == COND_RESULT_FALSE)  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;   if (dc->prev)  if (con->conf.get_conditional_type() == COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key);  if (!con->conditional_is_valid[dc->comp])  if (con->conf
case COND_RESULT_FALSE: if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* ensure prev is checked first */
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling)  /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result)  /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result)  config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
case COND_STYLE_FORWARD_DEBUG_PRIVATE: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STYLE_PREFIX_NOT_FOUND: case COND_STY
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v)  /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v)  /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v)  /* get the cache */  /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v)  /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COND_RESULT_UNSET: /* check prev is checked first */ if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp))  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;   /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp)  if (ptr->conf.log_condition_handling)  TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp);  return COND_RESULT_FALSE;
if (con->conf.context_ndx == 0)  config_check_cond_cached(srv, con, dc->parent);
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result)  config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy)  config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
/* XXX */ config_check_cond_nocache(srv, con, dc->parent);
case COMP_OK:  /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;   if (dc->prev)  if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key);  /* one of prev set me to FALSE */ if (COND_RESUL
/* one of the prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  return COND_RESULT_FALSE;
case COND_RESULT_DEBUG_CACHE:
if (con->conf.verbose)  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;   if (dc->prev)  if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key);  /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);   else  /* invalid or disabled
/* handle request for the dummy link's node */ if (dc->dummy_link_state == D_COND_COND_NEEDGIANT)  /* must have at least 'COND' */ con->conf.conf.log_cond_cached(srv, con, dc->dummy_link_state);
if (con->conf.log_cond_freecache)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
/* XXX: Don't try to call config_check_cond_nocache_cache() on any device */
if (con->conf.stats_check)  if (con->conf.stats_check)  /* pass the rules */ switch (dc->comp)  case COND_RESULT_FALSE:  if (dc->dc->flags & COND_RESULT_FALSE)  return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent)  if (con->conf.context_ndx->parent)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;   if (con->conf.log_condition
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE)  /* no error for cond config.n*/ return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize)  if (con->conf.log_cond_cache_handling)  /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key);  if (dc->prev)  if (con->conf.log_condition_handling)  /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result)  if (COND_RESULT_FALSE == con->cond_cache[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %
/* freeing dc->comp.dc_host_key */ if (dc->cond_host_key == 0)  config_check_cond_nocache_check(srv, con, dc->dc_host_key);
/* * check if this is set */
if (!con->conf.log_condition_handling)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  config_check_cond_cached(srv, con, dc->context_ndx);  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_
if (dc->dc_conf)  return COND_RESULT_FALSE;
case COMP_COND_DEBUG:
/* use a proxy */ if (dc->parent)  config_check_cond_nocache(srv, con, dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog)  case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE)  if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (dc->dd_flags)  config_check_cond_cached(srv, con, dc->dd_flags);  if (dc->dd_flags)  if (dc->dd_flags)  config_check_cond_cached(srv, con, dc->dd_f
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags)  if (dc->result_flags)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* config_check_cond_nocache_failed*/ if (dc->parent->context_ndx)  config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.log_condition_handling)  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE)  if (con->conf.log_condition_handling)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* if (dc->conf.cond_cache[dc->context_ndx].cache_syspath)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_DEBUG: /* don't know if this is a cond */ break;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
if (!dc->parent->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
case SYS_LOG_EXIT_SUPPORTS: case SYS_LOG_TEST: case SYS_LOG_TEST: /* set log error */ break;
case COND_RESULT_READY:
if (dc->inv_parent)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->context_ndx)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (dc->parent)  config_check_cond_cached(srv, con, dc->parent);
/* XXX - Don't need to stdout because dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
case COMP_RESULT_FALSE: case COMP_RESULT_NONE: case COMP_RESULT_NONE: case COMP_RESULT_NONE: case COMP_RESULT_NOT_CONTENT: case COMP_RESULT_NONE: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_NONE: case COMP_RESULT_NONE: case COMP_RESULT_CONTENT: case COMP_RESULT_NONE: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT_CONTENT: case COMP_RESULT
if (!dc->conf.cond_cache[dc->context_ndx].result)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* * To create a cond config check of cdas a caller, we are using a connection. This means that a * condas a dc should get a condas. */ con->conf.config_cond_cached(srv, con, dc->parent->key);
case COND_RESULT_DEC: case COND_RESULT_FALSE: /* pass the rule */ break; case COND_RESULT_NONE: /* pass the rule */ break; case COND_RESULT_TEST: /* pass the rule */ break;
/* wait for cond_result_sync */ if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COMP_UNSET: /* pass the rules */ if (dc->prev)  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT)  /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* XXX should not do this, just try to check the dummy buffer. */ if (con->conf.log_condition_handling)  splx(s); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_TRUE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* no prev */
case COND_RESULT_FALSE: if (dc->context_ndx)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
case _DEBUG: /* * Not sure how to get error code */ if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* XXX we need to run it - skip it and */ /* XXX - "start ncache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.cache.c
/* if we were just done a cond_disconnection we're going to do with cond_disconnection */ con->disconnection = con->disconnection;
case COMP_COND_REFERENCE:
if (con->conf.cond_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (dc->flags & D_ERROR)  if (dc->cache_reflags)  if (dc->cache_reflags)  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;   if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->parent)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (con->conf.log_cond_no_result)  config_check_cond_no_result_no_result(srv, con, con->cond_cache[dc->context_ndx].result));
/* pass the rules */ switch (dc->comp)  case COMP_COND_UNSET: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case
if (dc->conf.signal_dup(srv, NULL) == 0)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_FORELOCK_HOST: case COND_FORELOCK_HOST:
if (con->conf.cond_cond_check_cond_free(dc->dc_socket, dc->dc_socket))  return COND_RESULT_FALSE;
if (con->conf.conf.log_cond_cache)  config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
#ifdef INCLUDE_DEBUG printf("cond_conf.cond_cache = %sn", con->conf.cond_cache->key); #endif
case COND_FIXED_PROPERTY_BY_ADDR: /* Cond */ case COND_FIXED_PROPERTY_BY_ADDR: /* Cond */ case COND_FIXED_PROPERTY_BY_ADDR: /* Cond */ case COND_FIXED_PROPERTY_BY_ADDR: /* Cond */
case COMP_COND_COND_UNSET: /* pass the rules */ break;
case COMP_COND_CANNOTATION: case COMP_COND_UNSET: case COMP_COND_UNSET: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_CANNOTATION: case COMP_COND_
if (dc->parent)  if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);   if (dc->prev)  if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key);  /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  return COND_RESULT_FALSE;  if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d]
/* we have to deallocate the first child of the cond. */ if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
if (!dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->d_conf.io_flags & (COND_RESULT_FALSE | COND_RESULT_FALSE))  return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE)  /* reset this checker in the log */ if (dc->comp)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result)  /* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR)  dc->parent->key = 0;
/* if this is a temporary dummy cond. */ if (config_check_cond_cached(srv, con, con->dummy) == COND_RESULT_FALSE)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result)  config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key])  config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key])  if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key])  config_check_cond_cached(srv, con, con->prev);  /* one
/* pass the rules */ switch (dc->comp)  case COMP_DTOR:
if (dc->dc_parent)  if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  /* break the rule */ if (!con->conditional_is_valid[dc->comp])  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;  if (dc->context_ndx)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_UNSET;
/* create a resource pointer */ if (con->conf.conf.conf.conf.conf_cond_cancelled)  log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling)  if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
/* fprintf(srv, "cond_result:%d: %sn", __FILE__, __LINE__, dc->parent->key, con->conf.get());
if (con->conf.verbose)  printf("%s: %sn", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
if (srv == -1) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;
/* check the default child in the prev system, and res = * the default child. */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)  return COND_RESULT_FALSE;  if (dc->prev)  if (con->conf.log_condition_handling)  TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);  return COND_RESULT_FALSE;

/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (srv == -1) <srv = &srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX - Don't need to stdout because dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (srv == -1) srv = &srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (srv == -1) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
<if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->cache_path == NULL) if (con->conf.log_queue_handled) <log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_parent) if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (srv == -1) &srv = &srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
&if (!dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->parent) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
#ifdef INCLUDE_DEBUG printf("cond_conf.cond_cache = %s<n", con->conf.cond_cache->key); #endif
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX - Don't need to stdout because &dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
&else log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
<else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not a working directory, */ if (dc->debug_config) <if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (srv == -1) <srv = &&srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (config_check_cond_cache(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
<if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
else log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* for sure we have to run config_check_cond_nocache(a p) */ if (p) &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
else return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
else &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
else if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->conf.log_conf) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
<else &config_check_cond_nocache(srv, con, dc->parent);
if (!dc->parent->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle request for the dummy link's node */ if (dc->dummy_link_state == D_COND_COND_NEEDGIANT) &/* must have at least 'COND' */ con->conf.conf.log_cond_cached(srv, con, dc->dummy_link_state);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* handle request for the dummy link's node */ if (dc->dummy_link_state == D_COND_COND_NEEDGIANT) </* must have at least 'COND' */ con->conf.conf.log_cond_cached(srv, con, dc->dummy_link_state);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.verbose) <printf("%s: %s<n", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
if (dc->cache_path == NULL) &if (con->conf.log_queue_handled) log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_condition_handling) return COND_RESULT_FALSE;
if (srv == -1) &srv = <&srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
<if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) &/* no error for cond config.<n*/ return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->prev->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (srv == -1) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.conf_cond_cache_cond_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) <srv = &srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (srv == -1) <srv = <&srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (srv == -1) &srv = &&srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.verbose) &printf("%s: %s&n", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (srv == -1) srv = &srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
else
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
config_check_cond_cached(srv, con, dc->parent->key);
if (!con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE;
if (dc->conf.log_conf) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (srv == -1) &srv = &&srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
<else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE)
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
<else &return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (!con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (srv == -1) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* try to free the client's password */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
<if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
<else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (srv == -1) <srv = <&srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (!con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
&else <config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* pass the rules */ switch (dc->comp) <case COMP_COND_UNSET: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling && con->conf.log_condition_handling->pg) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (srv == -1) srv = &srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling && con->conf.log_condition_handling->pg) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
&else &config_check_cond_nocache(srv, con, dc->parent);
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) &if (!con->cond_cache[con->cond_pr_pr_pr].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
<else &config_check_cond_cached(srv, con, dc->parent);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling) config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
/* if (con->conf.log_condition_handling == COND_RESULT_FALSE) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
else <config_check_cond_cached(srv, con, dc->parent);
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* config_check_cond_nocache_failed*/ if (dc->parent->context_ndx) <config_check_cond_cached(srv, con, dc->parent->key);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (srv == -1) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (srv == -1) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling)
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling) <config_check_cond_cached(srv, con, dc->parent->key);
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
&else <config_check_cond_cached(srv, con, dc->parent);
/* XXX - Don't need to stdout because <dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->parent) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->cache_path == NULL) if (con->conf.log_queue_handled) &log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (srv == -1) &srv = &srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* for sure we have to run config_check_cond_nocache(a p) */ if (p) return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->context->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->parent) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* fprintf(srv, "cond_result:%d: %sn", __FILE__, __LINE__, dc->parent->key, con->conf.get());
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!dc->parent->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_condition_handling) <config_check_cond_cached(srv, con, dc->parent);
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
<else if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else config_check_cond_nocache(srv, con, dc->parent->key);
case _DEBUG: /* * Not sure how to get error code */ if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (srv == -1) &srv = &&srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && con->conf.log_condition_handling->pg) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_UNSET: if (con->conf.log_condition_handling) /* pass the rules */ config_check_cond_cached(srv, con, dc->parent->key);
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->conf.log_conf) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* if config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
else if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* try to free the client's password */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!dc->parent->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
return COND_RESULT_TRUE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.log_condition_handling) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
return (COND_RESULT_FALSE);
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->parent) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->parent) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (srv == -1) &srv = &&srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
<else <config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (!dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (!con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (srv == -1) &srv = &&srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* check the default child in the prev system, and res = * the default child. */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
<return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
<else config_check_cond_nocache(srv, con, dc->parent);
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
config_check_cond_cached(srv, con, dc->parent);
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &#endif
&else if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (srv == -1) srv = <&srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
<else &config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cache(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* <return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
else config_check_cond_cached(srv, con, dc->parent->key);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) &/* no error for cond config.n*/ return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (srv == -1) srv = <&srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) config_check_cond_cached(srv, con, dc->parent->key);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
else &config_check_cond_nocache(srv, con, dc->parent);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (srv == -1) <srv = &&srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* not a working directory, */ if (dc->debug_config) &if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->cache_path == NULL) &if (con->conf.log_queue_handled) <log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
<if (!con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* pass the rules */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->parent) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
&else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&else <config_check_cond_nocache(srv, con, dc->parent->key);
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->d_conf.io_flags & (COND_RESULT_FALSE | COND_RESULT_FALSE)) <return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (srv == NULL) return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (srv == -1) &srv = &srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
else <config_check_cond_cached(srv, con, dc->parent);
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; #endif
if (!con->cond_cache[dc->context_ndx].result) &return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
<else &config_check_cond_cached(srv, con, dc->parent);
&else
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
else &config_check_cond_nocache(srv, con, dc->parent->key);
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
<else <return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (!dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* wait for cond_result_sync */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (srv == -1) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
/* config_check_cond_nocache_failed*/ if (dc->parent->context_ndx) &config_check_cond_cached(srv, con, dc->parent->key);
else <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
<else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (srv == -1) srv = &srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) </* no error for cond config.&n*/ return COND_RESULT_FALSE;
if (srv == -1) srv = <&srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
&else &config_check_cond_nocache(srv, con, dc->parent);
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.verbose) &printf("%s: %s<n", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* if config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else &config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* one of the prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE;
/* fprintf(srv, "cond_result:%d: %s&n", __FILE__, __LINE__, dc->parent->key, con->conf.get());
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* if this is a temporary dummy cond. */ if (config_check_cond_cached(srv, con, con->dummy) == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
else if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else config_check_cond_cached(srv, con, dc->parent);
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->context_ndx->cache_switch) &config_check_cond_nocache(srv, con, dc->context_ndx->cache_switch);
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
<else if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_cond_freecache) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not a working directory, */ if (dc->debug_config) if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check parent first */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_state & COND_RESULT_TRUE) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&else if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->conf.log_conf) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
&else config_check_cond_nocache(srv, con, dc->parent);
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) </* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) <dc->parent->key = 0;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
#ifdef INCLUDE_DEBUG printf("cond_conf.cond_cache = %sn", con->conf.cond_cache->key); #endif
#endif
if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result)
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (config_check_cond_cache(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
<else
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* pass the rules */ switch (dc->comp) &case COMP_DTOR:
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (!dc->parent->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) if (!con->cond_cache[con->cond_pr_pr_pr].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->d_conf.io_flags & (COND_RESULT_FALSE | COND_RESULT_FALSE)) &return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) &/* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) dc->parent->key = 0;
if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (!dc->parent->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* if this is a temporary dummy cond. */ if (config_check_cond_cached(srv, con, con->dummy) == COND_RESULT_FALSE) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (srv == -1) &srv = &srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (srv == -1) <srv = &srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <#endif
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
else &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* freeing dc->comp.dc_host_key */ if (dc->cond_host_key == 0) &config_check_cond_nocache_check(srv, con, dc->dc_host_key);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) if (!con->cond_cache[con->cond_pr_pr_pr].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&#endif
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
else <return COND_RESULT_FALSE;
if (dc->inv_parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
&else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
else config_check_cond_nocache(srv, con, dc->parent->key);
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key);
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&if (!dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.conf.log_cond_cache) config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&else <return COND_RESULT_FALSE;
if (srv == -1) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (!con->cond_cache[dc->context_ndx].result) &config_check_cond_cached(srv, con, dc->parent);
if (config_check_cond_cached(srv, con, dc->prev) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* if (dc->conf.cond_cache[dc->context_ndx].cache_syspath) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (srv == -1) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
<if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_freecache) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
<else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
<if (!dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (!dc->parent->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) &printf("%s: %sn", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
<if (!dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* wait for cond_result_sync */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (srv == -1) &srv = &srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (con->conf.log_condition_handling == COND_RESULT_FALSE) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* not a working directory, */ if (dc->debug_config) &if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (srv == -1) &srv = &srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) printf("%s: %sn", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
&else <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (!dc->parent->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (srv == -1) &srv = <&srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
&else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
<else <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_condition_handling) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->parent) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* handle request for the dummy link's node */ if (dc->dummy_link_state == D_COND_COND_NEEDGIANT) /* must have at least 'COND' */ con->conf.conf.log_cond_cached(srv, con, dc->dummy_link_state);
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (srv == -1) <srv = <&srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
else if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (!dc->parent->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->dc_parent) &if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (srv == -1) srv = <&srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* XXX - Don't need to stdout because dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (srv == -1) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key);
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->conf.log_conf) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
else &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
&if (!dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
else <config_check_cond_nocache(srv, con, dc->parent->context_ndx);
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
&else &config_check_cond_nocache(srv, con, dc->parent->key);
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->dc_conf) &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->parent) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* check parent first */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!dc->parent->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
&if (!dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (config_check_cond_cached(srv, con, dc->prev->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_UNSET: if (con->conf.log_condition_handling) &/* pass the rules */ config_check_cond_cached(srv, con, dc->parent->key);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) /* no error for cond config.<n*/ return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
else &config_check_cond_cached(srv, con, dc->parent);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!dc->parent->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->parent) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (!dc->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<else return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!dc->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.conf.log_cond_cache) <config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->cache_path == NULL) &if (con->conf.log_queue_handled) &log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (srv == -1) <srv = &&srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
&else &return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (srv == -1) &srv = <&srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (!dc->parent->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) </* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) dc->parent->key = 0;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (srv == -1) srv = &srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->parent) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->parent) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->parent) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* if (dc->conf.cond_cache[dc->context_ndx].cache_syspath) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (srv == -1) srv = &&srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!dc->parent->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
else <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->conf.sock_result) &config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (config_check_cond_cached(srv, con, con->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_freecache) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
if (!dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* fprintf(srv, "cond_result:%d: %s<n", __FILE__, __LINE__, dc->parent->key, con->conf.get());
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
&else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) </* no error for cond config.n*/ return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
&else &config_check_cond_cached(srv, con, dc->parent);
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
<else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) /* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) &dc->parent->key = 0;
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->dc_conf) return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) /* no error for cond config.n*/ return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (config_check_cond_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
<else log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (srv == -1) srv = <&srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
<if (!dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* freeing dc->comp.dc_host_key */ if (dc->cond_host_key == 0) <config_check_cond_nocache_check(srv, con, dc->dc_host_key);
if (srv == -1) <srv = &&srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (config_check_cond_cache(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT) return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->cache_path == NULL) <if (con->conf.log_queue_handled) <log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
&else &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* we have to deallocate the first child of the cond. */ if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<else <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (!con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* pass the rules */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
&else if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.log_condition_handling) &config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
else if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (!dc->parent->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COND_RESULT_FALSE: return COND_RESULT_FALSE;
return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
else <config_check_cond_nocache(srv, con, dc->parent->key);
if (srv == -1) srv = &&srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
else &config_check_cond_cached(srv, con, dc->parent->key);
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!dc->parent->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
else <config_check_cond_nocache(srv, con, dc->parent);
else log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->parent) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&else config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->parent) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (!dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (config_check_cond_cached(srv, con) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
else config_check_cond_cached(srv, con, dc->parent);
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check parent first */ if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) srv = <&srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (srv == -1) srv = &srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* config_check_cond_nocache_failed*/ if (dc->parent->context_ndx) config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<else <config_check_cond_nocache(srv, con, dc->parent);
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (COND_RESULT_FALSE == con->cond_cache[con->context_ndx].result) &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->prev) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else &config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (srv == NULL) <return COND_RESULT_FALSE;
if (srv == -1) &srv = <&srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_cond_no_result) <config_check_cond_no_result_no_result(srv, con, con->cond_cache[dc->context_ndx].result));
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_no_result) config_check_cond_no_result_no_result(srv, con, con->cond_cache[dc->context_ndx].result));
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->conf.sock_result) config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (!con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not a working directory, */ if (dc->debug_config) if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (srv == -1) srv = &&srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) &if (!con->cond_cache[con->cond_pr_pr_pr].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.cond_cond_check_cond_free(dc->dc_socket, dc->dc_socket)) &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.conf.log_condition_handling) &/* check if we're going to a parent, or this will work in some case */ config_check_cond_cached(srv, con, dc->parent->key);
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check parent first */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
&if (!con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_UNSET: /* check prev is checked first */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
<#endif
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (config_check_cond_cache(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<else &config_check_cond_nocache(srv, con, dc->context_ndx);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
<else <config_check_cond_nocache(srv, con, dc->parent->context_ndx);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.verbose) <printf("%s: %s&n", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (COND_RESULT_FALSE == con->cond_cache[con->context_ndx].result) <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (srv == -1) &srv = &&srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->dc_parent) <if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* just do a dev */ if (con->conf.d_flags & COND_UNSET) &config_check_cond_nocache(srv, con, con->conf.d_flags & COND_UNSET);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) <if (!con->cond_cache[con->cond_pr_pr_pr].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (dc->parent) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (!dc->parent->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
<else &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (srv == -1) srv = &&srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not a working directory, */ if (dc->debug_config) <if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (srv == -1) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else <config_check_cond_nocache(srv, con, dc->parent);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
#ifdef INCLUDE_DEBUG printf("cond_conf.cond_cache = %s&n", con->conf.cond_cache->key); #endif
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (srv == -1) <srv = &srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
<else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) &/* no error for cond config.&n*/ return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (!con->cond_cache[dc->context_ndx].result) <return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
<else config_check_cond_cached(srv, con, dc->parent->key);
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* pass the rules */ switch (dc->comp) case COMP_COND_UNSET: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case
&if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
else &config_check_cond_nocache(srv, con, dc->context_ndx);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) /* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) <dc->parent->key = 0;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
else <config_check_cond_nocache(srv, con, dc->context_ndx);
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (srv == -1) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
#ifdef WIN_INET /* * if the virtual host hasn't been WANTED, we'll have a WANTED session. */ if (dc->socket_events_report_flags & DEBUG_COND) <DEBUG_COND("cond[%d] hasn't WANTED, need to set up the session" "need to return" "one of the WANTED event" "device.noevent.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report
if (dc->dc_parent) &if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_UNSET: /* check prev is checked first */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX - Don't need to stdout because <dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->cache_path == NULL) if (con->conf.log_queue_handled) log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<else &config_check_cond_nocache(srv, con, dc->parent);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
<else <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* just do a dev */ if (con->conf.d_flags & COND_UNSET) config_check_cond_nocache(srv, con, con->conf.d_flags & COND_UNSET);
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
<if (!dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->context->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->parent) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* XXX should not do this, just try to check the dummy buffer. */ if (con->conf.log_condition_handling) <splx(s); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (srv == -1) srv = &srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (srv == -1) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
<if (!con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* pass the rules */ switch (dc->comp) <case COMP_DTOR:
&if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
<if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
<if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (srv == -1) &srv = &&srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->parent) &config_check_cond_cached(srv, con, dc->parent);
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
<else config_check_cond_nocache(srv, con, dc->context_ndx);
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_TRUE) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->parent) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (srv == -1) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
else &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->parent) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
<else config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (srv == -1) <srv = &&srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->dc_parent) if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
&else <config_check_cond_cached(srv, con, dc->parent->key);
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!dc->parent->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (!dc->parent->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case _DEBUG: /* * Not sure how to get error code */ if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* if config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
<else &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_condition_handling) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
<else &config_check_cond_nocache(srv, con, dc->parent->key);
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
<else <config_check_cond_cached(srv, con, dc->parent);
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->parent) <config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* freeing dc->comp.dc_host_key */ if (dc->cond_host_key == 0) config_check_cond_nocache_check(srv, con, dc->dc_host_key);
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* create a resource pointer */ if (con->conf.conf.conf.conf.conf_cond_cancelled) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (con->conf.log_condition_handling == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* check parent first */ if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE)
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check parent first */ if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* if (dc->conf.cond_cache[dc->context_ndx].cache_syspath) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (srv == -1) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!dc->parent->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &#endif
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) <if (!con->cond_cache[con->cond_pr_pr_pr].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (srv == -1) srv = &srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->parent) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
else return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* not a working directory, */ if (dc->debug_config) <if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (srv == -1) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (!dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (srv == -1) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else <config_check_cond_nocache(srv, con, dc->parent);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
&else <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (!dc->parent->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
return COND_RESULT_UNSET;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
<if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
<if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.cond_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* create a resource pointer */ if (con->conf.conf.conf.conf.conf_cond_cancelled) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (!dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
<if (!dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (srv == -1) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (srv == -1) &srv = <&srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
<else config_check_cond_nocache(srv, con, dc->parent->key);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->inv_parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
else &config_check_cond_nocache(srv, con, dc->parent);
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
<else return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
default: return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
&else &config_check_cond_cached(srv, con, dc->parent);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) srv = &&srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* check the default child in the prev system, and res = * the default child. */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (srv == -1) <srv = &srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* try to free the client's password */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) &config_check_cond_cached(srv, con, dc->parent->key);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (srv == -1) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) if (!con->cond_cache[con->cond_pr_pr_pr].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (srv == -1) &srv = <&srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (!dc->parent->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* one of the prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_UNSET: if (con->conf.log_condition_handling) </* pass the rules */ config_check_cond_cached(srv, con, dc->parent->key);
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; #endif
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&if (!dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (!dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) <config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (srv == -1) <srv = <&srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!dc->parent->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (srv == -1) <srv = &&srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
else config_check_cond_nocache(srv, con, dc->parent);
if (config_check_cond_cached(srv, con, con->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) &/* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) &dc->parent->key = 0;
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* XXX - Don't need to stdout because <dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.context_ndx == 0) <config_check_cond_cached(srv, con, dc->parent);
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* create a resource pointer */ if (con->conf.conf.conf.conf.conf_cond_cancelled) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (srv == -1) <srv = &srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->parent) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &#endif
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_conf) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE)
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) &/* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->dc_parent) <if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (srv == -1) <srv = &&srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (!dc->parent->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (srv == -1) &srv = <&srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (srv == -1) <srv = &srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (config_check_cond_cache(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; #endif
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
&return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <#endif
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.log_cond_cache[dc->context_ndx].result)
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
&if (!dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&else config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->prev) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (!dc->parent->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case _DEBUG: /* * Not sure how to get error code */ if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->parent) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.cond_cond_check_cond_free(dc->dc_socket, dc->dc_socket)) return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
break;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->parent) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (config_check_cond_cached(srv, con, dc->prev->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
&if (!dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (srv == -1) <srv = <&srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (!dc->parent->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (!con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
<if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* use a proxy */ if (dc->parent) &config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->parent);
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.cond_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* XXX should not do this, just try to check the dummy buffer. */ if (con->conf.log_condition_handling) splx(s); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
<if (!dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.conf.log_cond_cache) &config_check_cond_cached(srv, con, dc->parent); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (srv == -1) srv = &&srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (!con->cond_cache[dc->context_ndx].result) <config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) <return COND_RESULT_FALSE;
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
<if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->conf.log_conf) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (!dc->parent->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (srv == -1) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
<else <config_check_cond_cached(srv, con, dc->parent->key);
if (!dc->parent->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->conf.signal_dup(srv, NULL) == 0) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
else &config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (!dc->parent->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) printf("%s: %s&n", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_condition_handling) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->parent) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_nocache(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->dc_parent) if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (srv == -1) &srv = &srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* XXX - Don't need to stdout because &dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) &/* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) <dc->parent->key = 0;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
<if (!con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case SYS_LOG_EXIT_SUPPORTS: case SYS_LOG_TEST: case SYS_LOG_TEST: /* set log error */ break;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
case COND_RESULT_FALSE: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->conf.log_conf) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (srv == -1) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->cache_path == NULL) <if (con->conf.log_queue_handled) &log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (srv == -1) srv = &&srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
&else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.stats_check) <if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (srv == -1) <srv = &&srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
&else <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (dc->inv_parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (srv == -1) srv = &srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
<else <config_check_cond_nocache(srv, con, dc->parent->key);
if (con->conf.conf.log_condition_handling) /* check if we're going to a parent, or this will work in some case */ config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.log_cond_no_result) &config_check_cond_no_result_no_result(srv, con, con->cond_cache[dc->context_ndx].result));
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) &return COND_RESULT_FALSE;
/* XXX - Don't need to stdout because &dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
&else <config_check_cond_nocache(srv, con, dc->parent->context_ndx);
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* check the default child in the prev system, and res = * the default child. */ if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else <config_check_cond_nocache(srv, con, dc->context_ndx);
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* wait for cond_result_sync */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* pass the rules */ switch (dc->comp) case COMP_DTOR:
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
<else config_check_cond_cached(srv, con, dc->parent);
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.stats_check) <if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
&else &return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.context_ndx == 0) &config_check_cond_cached(srv, con, dc->parent);
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) <TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* if the conditional isn't specified */ if (con->conf.log_condition_handling) &/* the conditions can be created while we haven't clear any problems. */ case COMP_NO_COND: /* the conditions will be changed as well as to make sure we have a cond_cond_cache_saved */
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (con->conf.log_condition_handling == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) &srv = <&srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (srv == -1) srv = <&srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (!dc->conf.cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) &if (!con->cond_cache[con->cond_pr_pr_pr].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (srv == -1) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.context_ndx == 0) config_check_cond_cached(srv, con, dc->parent);
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (srv == -1) srv = <&srv->srv_socket; <if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->conf.signal_dup(srv, NULL) == 0) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
#ifdef XP_MAC if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <#endif
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) &config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.stats_check) if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
&else <config_check_cond_nocache(srv, con, dc->parent);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
else &config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->cache_path == NULL) <if (con->conf.log_queue_handled) log_error_write(srv, __FILE__, __LINE__, "sb", "go to child", dc->parent->key);
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) </* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX should not do this, just try to check the dummy buffer. */ if (con->conf.log_condition_handling) &splx(s); return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_condition_handling) &config_check_cond_cached(srv, con, dc->parent);
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (config_check_cond_cached(srv, con, dc->context->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (srv == -1) srv = <&srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
&if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* not a working directory, */ if (dc->debug_config) if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (srv == -1) srv = &&srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_TRUE) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
&if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) &config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT) &return COND_RESULT_FALSE;
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* use a proxy */ if (dc->parent) config_check_cond_nocache(srv, con, dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (srv == -1) &srv = <&srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) /* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) dc->parent->key = 0;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) &if (dc->result_flags) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.verbose) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* handle connection flags */ if (config_check_cond_flags) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
else <config_check_cond_cached(srv, con, dc->parent->key);
&else config_check_cond_nocache(srv, con, dc->parent);
if (dc->dc_parent) <if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else config_check_cond_nocache(srv, con, dc->context_ndx);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* one of the prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.conf_conf_state & conf->conf.conf_state) if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (!con->cond_cache[dc->prev->key].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
else config_check_cond_nocache(srv, con, dc->parent);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (srv == -1) &srv = &srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->conf.sock_result) <config_check_cond_nocache(srv, con, dc->parent->context_ndx);
if (config_check_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) /* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) <config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->d_conf.io_flags & (COND_RESULT_FALSE | COND_RESULT_FALSE)) return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.verbose) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&else &config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
&else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_state & COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) </* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) &config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
/* return COND_RESULT_FALSE;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* if the conditional isn't specified */ if (con->conf.log_condition_handling) </* the conditions can be created while we haven't clear any problems. */ case COMP_NO_COND: /* the conditions will be changed as well as to make sure we have a cond_cond_cache_saved */
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (!dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
&else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
/* just do a dev */ if (con->conf.d_flags & COND_UNSET) <config_check_cond_nocache(srv, con, con->conf.d_flags & COND_UNSET);
if (srv == NULL) &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
<else config_check_cond_nocache(srv, con, dc->parent);
&else &config_check_cond_nocache(srv, con, dc->context_ndx);
else config_check_cond_nocache(srv, con, dc->context_ndx);
if (con->conf.log_condition_handling == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (dc->parent) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (srv == -1) &srv = &&srv->srv_socket; <if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* if this is a temporary dummy cond. */ if (config_check_cond_cached(srv, con, con->dummy) == COND_RESULT_FALSE) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->conf.signal_dup(srv, NULL) == 0) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (srv == -1) <srv = &srv->srv_socket; <if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
&else &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (srv == -1) <srv = <&srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->parent) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (dc->parent) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (srv == -1) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
else if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) </* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
#ifdef WIN_INET /* * if the virtual host hasn't been WANTED, we'll have a WANTED session. */ if (dc->socket_events_report_flags & DEBUG_COND) DEBUG_COND("cond[%d] hasn't WANTED, need to set up the session" "need to return" "one of the WANTED event" "device.noevent.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report
if (dc->parent) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (srv == -1) <srv = <&srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->context_ndx->cache_switch) <config_check_cond_nocache(srv, con, dc->context_ndx->cache_switch);
if (con->conf.verbose) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->context_ndx->cache_switch) config_check_cond_nocache(srv, con, dc->context_ndx->cache_switch);
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (srv == -1) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COMP_OK: &/* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (!con->cond_cache[dc->prev->key].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
&else config_check_cond_cached(srv, con, dc->parent);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) &if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
<return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) <if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
<if (!dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* XXX avoid a bug that happened when */ if (con->conf.pr_pr_pr) <if (!con->cond_cache[con->cond_pr_pr_pr].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", con->cond_cache[con->cond_pr_pr_pr]);
if (!dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* if the conditional isn't specified */ if (con->conf.log_condition_handling) /* the conditions can be created while we haven't clear any problems. */ case COMP_NO_COND: /* the conditions will be changed as well as to make sure we have a cond_cond_cache_saved */
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (srv == -1) srv = &&srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
else <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_UNSET: /* check prev is checked first */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
<else <config_check_cond_nocache(srv, con, dc->context_ndx);
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
&else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* XXX - Don't need to stdout because dc->comp' can't really work */ if (dc->conf.conf.log_cond_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* use a proxy */ if (dc->parent) <config_check_cond_nocache(srv, con, dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
&else log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
<else config_check_cond_cached(srv, con, dc->parent);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; <if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (dc->parent) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* XXX: We haven't got any ncache information from the config_check_cond_nocache and we have to be * testing for this purpose. */ if (con->conf.log_condition_handling) /* try to make sure cond_comp has been checked */ if (!con->cond_cache[dc->prev].result) &/* make sure prev is checked first */ config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) config_check_cond_cache(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp
<if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->context_ndx) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
&else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) &if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
if (srv == -1) <srv = <&srv->srv_socket; &if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling) config_check_cond_cached(srv, con, dc->parent);
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) &if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent);
if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
&if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.verbose) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->flags & D_ERROR) if (dc->cache_reflags) <if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) /* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE;
if (srv == -1) <srv = <&srv->srv_socket; if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->dc_parent) &if (config_check_cond_cached(srv, con, dc->dc_parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* XXX Check the client before returning a parent. */ if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) <if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (dc->flags & COND_RESULT_LOCK) if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
&if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.verbose) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
if (srv == -1) &srv = &&srv->srv_socket; if (!srv->srv_socket) if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) /* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
<else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
else config_check_cond_cached(srv, con, dc->parent);
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) </* no error for cond config.<n*/ return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COMP_UNSET: if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.conf_cond_cache_cond_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (con->conf.conf_conf_state & conf->conf.conf_state) <if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) &case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & COND_RESULT_LOCK) <if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.stats_check) &if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) <if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); <return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) &fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) <fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.conf_cond_cache_cond_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
case COMP_OK: /* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (dc->parent) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &&if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.cond_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->dc_flags & DD_NO_CREAT) &/* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %dn", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_nocache(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) &/* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* pass the rules */ switch (dc->comp) &case COMP_COND_UNSET: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case COMP_COND_NO_SESSION: case
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key);
if (dc->flags & D_ERROR) if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (config_check_cond_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_FALSE: if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
else <config_check_cond_nocache(srv, con, dc->parent);
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* * XXX check if the data packet is not NULL. */ if (con->conf.log_condition_handling) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
&if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->flags & COND_RESULT_LOCK) &if (con->conf.log_cond_cache[dc->flags & COND_RESULT_LATCH]) if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->comp]) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_cond_cache[dc->context
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
<if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (dc->parent->key == COND_RESULT_FALSE) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (con->conf.stats_check) if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) <case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) <if (dc->cache_reflags) if (dc->cache_reflags) if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* freed cache if possible */ if (con->conf.log_cond_handling) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) &if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (srv == -1) <srv = &&srv->srv_socket; if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
if (!con->conf.log_condition_handling) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, con->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_OK: </* check if dc->sockets are valid */ case COMP_OK: /* check if this isn't possible */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESUL
if (COND_RESULT_FALSE == con->cond_cache[con->context_ndx].result) return COND_RESULT_FALSE;
if (con->conf.log_condition_handling == COND_RESULT_FALSE) &config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.stats_check) if (con->conf.stats_check) &/* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
if (con->conf.conf.log_condition_handling) </* check if we're going to a parent, or this will work in some case */ config_check_cond_cached(srv, con, dc->parent->key);
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; <if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
<else &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
case COMP_UNSET: /* pass the rules */ if (dc->prev) <if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) if (dc->result_flags) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->conf.log_conf) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d<n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
&if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) config_check_cond_cached(srv, con, con->prev); /* one
/* handle connection flags */ if (config_check_cond_flags) <if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); <if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->prev) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) &/* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* let the parent set it back */ config_check_cond_cached(srv, con, dc->parent->key, con->conf.conf.comp_key); /* check this */ if (!dc->result_flags) <if (dc->result_flags) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
&else return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.conf_conf_state & conf->conf.conf_state) &if (con->conf.conf_conf_flags & SYS_COND_USER_DEC_F_INET) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &config_check_cond_cached(srv, con, con->prev); /* one
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) return COND_RESULT_FALSE; &if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) <if (con->conf.context_ndx->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* no ptr.no_ptrs!= NULL */ if (!ptr->comp) if (ptr->conf.log_condition_handling) &TRACE("ptr[%d] is valid: %d", ptr->comp, ptr->comp); &return COND_RESULT_FALSE;
/* we have to deallocate the first child of the cond. */ if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) <config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.verbose) <printf("%s: %sn", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
case COND_RESULT_TEST: case COND_RESULT_TEST: if (!con->cond_cache[dc->context_ndx].result) <log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; /* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: break; case COND_RESULT_FALSE: if (con->conf.log
/* freed cache if possible */ if (con->conf.log_cond_handling) return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
case COMP_UNSET: /* pass the rules */ if (dc->prev) if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* handle connection flags */ if (config_check_cond_flags) &if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->prev) if (config_check_cond_cached(srv, con, dc->parent
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; <if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* not a working directory, */ if (dc->debug_config) &if (config_check_cond_cached(srv, con, dc->debug_config) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) &if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); &if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
if (dc->context_ndx) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->parent) <if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.stats_check) <if (con->conf.stats_check) </* pass the rules */ switch (dc->comp) case COND_RESULT_FALSE: &if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (config_check_cond_cached(srv, con) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) <if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) &if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
else if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
/* * try to resolve the first '%s' to the client */ if (con->conf.context_ndx && con->conf.context_ndx->parent) &if (con->conf.context_ndx->parent) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition
if (con->conf.cond_cond_check_cond_free(dc->dc_socket, dc->dc_socket)) <return COND_RESULT_FALSE;
<if (dc->parent) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
else <return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; if (dc->prev) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* try to handle the device ->->parent->parent->key. */ if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* * Don't make sure our db and db. */ if (con->conf.log_type == COND_RESULT_FALSE) /* no error for cond config.&n*/ return COND_RESULT_FALSE;
case COND_RESULT_DEAD_UNSET: /* pass the rules */ switch (dc->dd_dialog) <case COND_RESULT_DEAD_SLOT: if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->dd_flags) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_flags); if (dc->dd_flags) if (dc->dd_flags) config_check_cond_cached(srv, con, dc->dd_f
/* make sure dc->prev is checked first */ if (dc->conf.log_condition_handling && con->conf.log_condition_handling) <config_check_cond_cached(srv, con, con->dc->prev); /* one of prev set me to FALSE */ if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &if (dc->dc->srv) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_hand
<if (dc->parent) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); &if (dc->prev) <if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* we have to deallocate the first child of the cond. */ if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->parent->key);
&if (!dc->prev) if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
if (srv == -1) <srv = &srv->srv_socket; &if (!srv->srv_socket) &if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* freed cache if possible */ if (con->conf.log_cond_handling) &return COND_RESULT_FALSE; &if (dc->prev) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) &/* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
case COMP_UNSET: if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) &config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
#ifdef WIN_INET /* * if the virtual host hasn't been WANTED, we'll have a WANTED session. */ if (dc->socket_events_report_flags & DEBUG_COND) &DEBUG_COND("cond[%d] hasn't WANTED, need to set up the session" "need to return" "one of the WANTED event" "device.noevent.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report.cs.report
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) &/* reset this checker in the log */ if (dc->comp) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* check the name of a non-zero address. */ if (con->conf.context_ndx == NULL) /* only need to get the name of the object in the local domain. */ if (con->conf.log_condition_handling == COND_RESULT_FALSE) <if (con->conf.log_condition_handling == COND_RESULT_FALSE) <config_check_cond_cached(srv, con, dc->parent->key); if (con->conf.log_condition_handling == COND_RESULT_FALSE) config_check_cond_cached(srv, con, dc->parent->key); if (dc->prev) if (dc->prev) config_check_cond_cached(srv, con, dc->prev); if (dc->comp == CON
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* check for parent is valid */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", con->parent->key); &if (config_check_cond_cached(srv, con, con->conf.log_condition_handling) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", con->comp, con->conditional_is_valid[dc->prev->key]); return COND_RESULT_FALSE;
/* pass the rules */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
case COND_RESULT_FALSE: if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con
if (con->conf.log_condition_handling && COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE; &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) <return COND_RESULT_FALSE; &&if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_state & COND_RESULT_FALSE) <if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->parent) if (con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
case COMP_UNSET: /* pass the rules */ if (dc->prev) &if (dc->prev) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
/* XXX */ if (dc->initialize) &if (con->conf.log_cond_cache_handling) </* not implemented */ config_check_cond_cached(srv, con, dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) /* one of prev set me to FALSE */ config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev].result) if (COND_RESULT_FALSE == con->cond_cache[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %
/* for all node-get_defaults for */ if (con->conf.log_cond_cache[dc->conf.dc_slot].result) </* if it is a cond_result_deadlock, check the hostname of this * server's packets. */ if (con->conf.conf.log_cond_cond_flags & ND_ERROR) &dc->parent->key = 0;
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; &/* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
/* * If we have to set a variable, or a variable that is set, use default - to prevent any cases in the next config. */ if (con->conf.comp_state == COND_COND_COND_UNSET) &if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (srv == -1) &srv = &srv->srv_socket; &if (!srv->srv_socket) <if (dc->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", srv->srv_socket, con->srv_socket); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (!dc->conf.cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) /* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* if (dc->cond_cache[dc->cond_cache[dc->context_ndx].name) &if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (dc->conf.log_conf) <if (con->conf.log_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.stats_check) &if (con->conf.stats_check) /* pass the rules */ switch (dc->comp) &case COND_RESULT_FALSE: <if (dc->dc->flags & COND_RESULT_FALSE) return COND_RESULT_FALSE;
case COND_RESULT_NON_COND: if (con->conf.log_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) </* check parent first */ return COND_RESULT_FALSE; if (dc->parent && con->conf.log_condition_handling) <log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
if (con->conf.log_condition_handling &&!con->conf.log_condition_handling) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) config_check_cond_cached(srv, con, dc->context_ndx); if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_
<if (!con->cond_cache[dc->context_ndx].flags & COND_RESULT_FALSE) <if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); &return COND_RESULT_FALSE;
/* for sure we have to run config_check_cond_nocache(a p) */ if (p) <return COND_RESULT_FALSE;
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE;
case COMP_UNSET: if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE; </* break the rule */ if (!con->conditional_is_valid[dc->comp]) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET; if (dc->context_ndx) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) if (dc->cache_reflags) <if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
/* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->comp].result) &config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, dc->prev); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) &if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) <config_check_cond_cached(srv, con, con->prev); /* one
if (dc->dc_flags & DD_NO_CREAT) </* all the prev keys in the prev will have to be checked */ if (!con->cond_cache[dc->dc_flags].result) &if (con->conf.log_condition_handling) &TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional
case COND_SUPPORTS_KERB_POLLING: /* check parent first */ if (dc->parent && dc->parent->context_ndx) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[d
if (dc->parent->key == COND_RESULT_FALSE) <if (con->conf.log_condition_handling) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; &if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_UNSET;
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ /* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
/* * get a dummy case. */ if (!dc->si_is_valid(dc->si_comp)) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; </* get dummy case. */ config_check_cond_cached(srv, con, dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->dc->d
if (dc->parent) <if (con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); <if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) return COND_RESULT_FALSE; if (!con->conditional_is_valid[dc->comp]) if (con->conf.log_condition_handling) TRACE("cond[%d]
if (con->conf.log_cond_flags & CF_FRAG_FRAG_POLLING) <fprintf(stderr, "cond_cond_nocache: config_check_cond_nocache %d&n", con->cond_cache[dc->context_ndx].result); return COND_RESULT_FALSE; &if (dc->dc.debug) &fprintf(stderr, "cond_cond_cache %dn", con->dc->dc.debug); return COND_RESULT_FALSE;
if (con->conf.verbose) &if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; &<if (dc->prev) if (con->conf.log_condition_handling) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* make sure prev is checked first */ if (COND_RESULT_FALSE == con->cond_cache[dc->prev->key]) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); else /* invalid or disabled
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ </* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (con->conf.log_state & COND_RESULT_FALSE) &if (config_check_cond_cached(srv, con, dc->parent->key) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <<if (dc->prev) if (con->conf.log_state & COND_RESULT_FALSE) if (con->conf.log_state & COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); /* one of prev set me to FALSE */ if (COND_RESULT_FALSE == con->cond_cache[dc->cond_state].result) log_error_write(srv, __
if (dc->context_ndx) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) &return COND_RESULT_FALSE; <if (dc->prev) if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (dc->parent) config_check_cond_cached(srv, con, dc->parent);
/* skip for all dummy rules */ if (!dc->cond_cache[dc->context_ndx].result) config_check_cond_cache(srv, con, dc->context_ndx); /* skip for dummy rules */ if (dc->dummy) <config_check_cond_cached(srv, con, dc->dummy) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
else config_check_cond_nocache(srv, con, dc->parent->context_ndx);
/* FIXME: Can't set this check if it does so that it is safe to just revert. */ if (con->conf.log_condition_handling && con->conf.log_condition_handling && con->conf.log_condition_handling == COND_RESULT_FALSE) </* reset this checker in the log */ if (dc->comp) &if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (con->conf.log_condition_handling &&!con->cond_cache[dc->context_ndx].result) if (con->conf.log_condition_handling && con->cond_cache[dc->context_ndx].result) /* check parent first */ return COND_RESULT_FALSE; &if (dc->parent && con->conf.log_condition_handling) &log_error_write(srv, __FILE__, __LINE__, "sb", "go parent", dc->parent->key); if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.log_condition_handling) TRACE("
/* not initialized */ if (con->conf.cond_cache[dc->context_ndx].pci_v) </* we have to allocate the cache to pci. This * doesn't happen yet, if we've just deleted it yet */ if (con->conf.cond_cache[dc->context_ndx].pci_v) /* get the cache */ if (con->conf.cond_cache[dc->context_ndx].pci_v) &/* get the cache */ &/* * Set pci is the pci. It will be used by pci. We don't allow * an internal conflict between prev and pci. */ if (dc->conf.cond_cache[dc->context_ndx].pci_v) /* make sure prev is checked first */ if (con->conf.cond_cache[d
if (config_check_cond_cached(srv, con, dc->context_ndx) == COND_RESULT_FALSE) return COND_RESULT_FALSE;
if (con->conf.get_conditional_type() == COND_RESULT_FALSE) &if (con->conf.get_conditional_type() == COND_RESULT_FALSE) <if (con->conf.get_conditional_type() == COND_RESULT_FALSE) if (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) return COND_RESULT_FALSE; if (dc->prev) if (con->conf.get_conditional_type() == COND_RESULT_FALSE) log_error_write(srv, __FILE__, __LINE__, "sb", "go prev", dc->prev->key); if (!con->conditional_is_valid[dc->comp]) if (con->conf
if (!con->cond_cache[dc->context_ndx].result) <if (con->conf.log_condition_handling) <TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); <return COND_RESULT_FALSE;
if (dc->flags & D_ERROR) &if (dc->cache_reflags) &if (dc->cache_reflags) &if (!con->conditional_is_valid[dc->comp]) <if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]); return COND_RESULT_FALSE; if (con->conf.log_condition_handling) TRACE("cond[%d] is valid: %d", dc->comp, con->conditional_is_valid[dc->comp]);
if (con->conf.verbose) printf("%s: %s<n", con->cond_cache[dc->context_ndx].result, con->cond_cache[dc->context_ndx].result);
